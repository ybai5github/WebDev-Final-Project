{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\n\nconst net_1 = require(\"net\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst constants_1 = require(\"./constants\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst admin_1 = require(\"./admin\");\n\nconst make_client_1 = require(\"./make-client\");\n\nfunction channelRefToMessage(ref) {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\n\nfunction subchannelRefToMessage(ref) {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  };\n}\n\nfunction serverRefToMessage(ref) {\n  return {\n    server_id: ref.id\n  };\n}\n\nfunction socketRefToMessage(ref) {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\n\n\nconst TARGET_RETAINED_TRACES = 32;\n\nclass ChannelzTrace {\n  constructor() {\n    this.events = [];\n    this.eventsLogged = 0;\n    this.creationTimestamp = new Date();\n  }\n\n  addTrace(severity, description, child) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n      childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n    }); // Whenever the trace array gets too large, discard the first half\n\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n\n    this.eventsLogged += 1;\n  }\n\n  getTraceMessage() {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        };\n      })\n    };\n  }\n\n}\n\nexports.ChannelzTrace = ChannelzTrace;\n\nclass ChannelzChildrenTracker {\n  constructor() {\n    this.channelChildren = new Map();\n    this.subchannelChildren = new Map();\n    this.socketChildren = new Map();\n  }\n\n  refChild(child) {\n    var _a, _b, _c;\n\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.channelChildren.set(child.id, trackedChild);\n          break;\n        }\n\n      case 'subchannel':\n        {\n          let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.subchannelChildren.set(child.id, trackedChild);\n          break;\n        }\n\n      case 'socket':\n        {\n          let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.socketChildren.set(child.id, trackedChild);\n          break;\n        }\n    }\n  }\n\n  unrefChild(child) {\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = this.channelChildren.get(child.id);\n\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n\n            if (trackedChild.count === 0) {\n              this.channelChildren.delete(child.id);\n            } else {\n              this.channelChildren.set(child.id, trackedChild);\n            }\n          }\n\n          break;\n        }\n\n      case 'subchannel':\n        {\n          let trackedChild = this.subchannelChildren.get(child.id);\n\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n\n            if (trackedChild.count === 0) {\n              this.subchannelChildren.delete(child.id);\n            } else {\n              this.subchannelChildren.set(child.id, trackedChild);\n            }\n          }\n\n          break;\n        }\n\n      case 'socket':\n        {\n          let trackedChild = this.socketChildren.get(child.id);\n\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n\n            if (trackedChild.count === 0) {\n              this.socketChildren.delete(child.id);\n            } else {\n              this.socketChildren.set(child.id, trackedChild);\n            }\n          }\n\n          break;\n        }\n    }\n  }\n\n  getChildLists() {\n    const channels = [];\n\n    for (const {\n      ref\n    } of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n\n    const subchannels = [];\n\n    for (const {\n      ref\n    } of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n\n    const sockets = [];\n\n    for (const {\n      ref\n    } of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n\n    return {\n      channels,\n      subchannels,\n      sockets\n    };\n  }\n\n}\n\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\n\nclass ChannelzCallTracker {\n  constructor() {\n    this.callsStarted = 0;\n    this.callsSucceeded = 0;\n    this.callsFailed = 0;\n    this.lastCallStartedTimestamp = null;\n  }\n\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n\n}\n\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\n\nfunction getNextId() {\n  return nextId++;\n}\n\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\n\nfunction registerChannelzChannel(name, getInfo) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'channel'\n  };\n  channels[id] = {\n    ref,\n    getInfo\n  };\n  return ref;\n}\n\nexports.registerChannelzChannel = registerChannelzChannel;\n\nfunction registerChannelzSubchannel(name, getInfo) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'subchannel'\n  };\n  subchannels[id] = {\n    ref,\n    getInfo\n  };\n  return ref;\n}\n\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\n\nfunction registerChannelzServer(getInfo) {\n  const id = getNextId();\n  const ref = {\n    id,\n    kind: 'server'\n  };\n  servers[id] = {\n    ref,\n    getInfo\n  };\n  return ref;\n}\n\nexports.registerChannelzServer = registerChannelzServer;\n\nfunction registerChannelzSocket(name, getInfo) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'socket'\n  };\n  sockets[id] = {\n    ref,\n    getInfo\n  };\n  return ref;\n}\n\nexports.registerChannelzSocket = registerChannelzSocket;\n\nfunction unregisterChannelzRef(ref) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n\n    case 'server':\n      delete servers[ref.id];\n      return;\n\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\n\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\n\nfunction parseIPv6Section(addressSection) {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\n\n\nfunction parseIPv6Chunk(addressChunk) {\n  if (addressChunk === '') {\n    return [];\n  }\n\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result = [];\n  return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\n\n\nfunction ipAddressStringToBuffer(ipAddress) {\n  if (net_1.isIPv4(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if (net_1.isIPv6(ipAddress)) {\n    let leftSection;\n    let rightSection;\n    const doubleColonIndex = ipAddress.indexOf('::');\n\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\n\nfunction connectivityStateToMessage(state) {\n  switch (state) {\n    case connectivity_state_1.ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n\n    case connectivity_state_1.ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n\n    case connectivity_state_1.ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n\n    case connectivity_state_1.ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n\n    case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\n\nfunction dateToProtoTimestamp(date) {\n  if (!date) {\n    return null;\n  }\n\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: millisSinceEpoch / 1000 | 0,\n    nanos: millisSinceEpoch % 1000 * 1000000\n  };\n}\n\nfunction getChannelMessage(channelEntry) {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\n\nfunction GetChannel(call, callback) {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n\n  if (channelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n\n  callback(null, {\n    channel: getChannelMessage(channelEntry)\n  });\n}\n\nfunction GetTopChannels(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n\n    if (channelEntry === undefined) {\n      continue;\n    }\n\n    resultList.push(getChannelMessage(channelEntry));\n\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction getServerMessage(serverEntry) {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\n\nfunction GetServer(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n\n  callback(null, {\n    server: getServerMessage(serverEntry)\n  });\n}\n\nfunction GetServers(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_server_id);\n\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n\n    if (serverEntry === undefined) {\n      continue;\n    }\n\n    resultList.push(getServerMessage(serverEntry));\n\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction GetSubchannel(call, callback) {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {\n    subchannel: subchannelMessage\n  });\n}\n\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n  var _a;\n\n  if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\n\nfunction GetSocket(call, callback) {\n  var _a, _b, _c, _d, _e;\n\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n\n  if (socketEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n      other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n      local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n      remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n    }\n  } : null;\n  const socketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n        value: resolvedInfo.localFlowControlWindow\n      } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n        value: resolvedInfo.remoteFlowControlWindow\n      } : null\n    }\n  };\n  callback(null, {\n    socket: socketMessage\n  });\n}\n\nfunction GetServerSockets(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo(); // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList = [];\n  let i = 0;\n\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\n\nfunction getChannelzHandlers() {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\n\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\n\nfunction getChannelzServiceDefinition() {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n\n\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync;\n\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`]\n  });\n  const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\n\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\n\nfunction setup() {\n  admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\n\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["channelRefToMessage","ref","channel_id","id","name","subchannelRefToMessage","subchannel_id","serverRefToMessage","server_id","socketRefToMessage","socket_id","TARGET_RETAINED_TRACES","ChannelzTrace","constructor","creationTimestamp","Date","addTrace","severity","description","child","timestamp","events","push","childChannel","kind","undefined","childSubchannel","length","slice","eventsLogged","getTraceMessage","creation_timestamp","dateToProtoTimestamp","num_events_logged","map","event","channel_ref","subchannel_ref","exports","ChannelzChildrenTracker","Map","refChild","trackedChild","channelChildren","get","_a","count","set","subchannelChildren","_b","socketChildren","_c","unrefChild","delete","getChildLists","channels","values","subchannels","sockets","ChannelzCallTracker","addCallStarted","callsStarted","lastCallStartedTimestamp","addCallSucceeded","callsSucceeded","addCallFailed","callsFailed","nextId","getNextId","servers","registerChannelzChannel","getInfo","registerChannelzSubchannel","registerChannelzServer","registerChannelzSocket","unregisterChannelzRef","parseIPv6Section","addressSection","numberValue","Number","parseInt","parseIPv6Chunk","addressChunk","bytePairs","split","section","result","concat","ipAddressStringToBuffer","ipAddress","net_1","Buffer","from","Uint8Array","segment","leftSection","rightSection","doubleColonIndex","indexOf","substring","leftBuffer","rightBuffer","middleBuffer","alloc","connectivityStateToMessage","state","connectivity_state_1","CONNECTING","IDLE","READY","SHUTDOWN","TRANSIENT_FAILURE","date","millisSinceEpoch","getTime","seconds","nanos","getChannelMessage","channelEntry","resolvedInfo","data","target","calls_started","callTracker","calls_succeeded","calls_failed","last_call_started_timestamp","trace","children","GetChannel","call","callback","channelId","request","constants_1","NOT_FOUND","channel","GetTopChannels","maxResults","max_results","resultList","i","start_channel_id","end","getServerMessage","serverEntry","listen_socket","listenerChildren","GetServer","serverId","server","GetServers","start_server_id","GetSubchannel","subchannelId","subchannelEntry","subchannelMessage","socket_ref","subchannel","subchannelAddressToAddressMessage","subchannelAddress","subchannel_address_1","address","tcpip_address","ip_address","host","port","uds_address","filename","path","GetSocket","socketId","socketEntry","securityMessage","security","model","tls","cipher_suite","cipherSuiteStandardName","standard_name","other_name","cipherSuiteOtherName","local_certificate","localCertificate","remote_certificate","remoteCertificate","_d","socketMessage","local","localAddress","remote","remoteAddress","remote_name","remoteName","_e","keep_alives_sent","keepAlivesSent","streams_started","streamsStarted","streams_succeeded","streamsSucceeded","streams_failed","streamsFailed","last_local_stream_created_timestamp","lastLocalStreamCreatedTimestamp","last_remote_stream_created_timestamp","lastRemoteStreamCreatedTimestamp","messages_received","messagesReceived","messages_sent","messagesSent","last_message_received_timestamp","lastMessageReceivedTimestamp","last_message_sent_timestamp","lastMessageSentTimestamp","local_flow_control_window","localFlowControlWindow","value","remote_flow_control_window","remoteFlowControlWindow","socket","GetServerSockets","startId","start_socket_id","allSockets","sessionChildren","sort","ref1","ref2","getChannelzHandlers","loadedChannelzDefinition","getChannelzServiceDefinition","loaderLoadSync","require","loadSync","loadedProto","keepCase","longs","String","enums","defaults","oneofs","includeDirs","__dirname","channelzGrpcObject","make_client_1","grpc","channelz","v1","Channelz","service","setup","admin_1"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/channelz.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIPv4, isIPv6 } from \"net\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { Status } from \"./constants\";\nimport { Timestamp } from \"./generated/google/protobuf/Timestamp\";\nimport { Channel as ChannelMessage } from \"./generated/grpc/channelz/v1/Channel\";\nimport { ChannelConnectivityState__Output } from \"./generated/grpc/channelz/v1/ChannelConnectivityState\";\nimport { ChannelRef as ChannelRefMessage } from \"./generated/grpc/channelz/v1/ChannelRef\";\nimport { ChannelTrace } from \"./generated/grpc/channelz/v1/ChannelTrace\";\nimport { GetChannelRequest__Output } from \"./generated/grpc/channelz/v1/GetChannelRequest\";\nimport { GetChannelResponse } from \"./generated/grpc/channelz/v1/GetChannelResponse\";\nimport { sendUnaryData, ServerUnaryCall } from \"./server-call\";\nimport { ServerRef as ServerRefMessage } from \"./generated/grpc/channelz/v1/ServerRef\";\nimport { SocketRef as SocketRefMessage } from \"./generated/grpc/channelz/v1/SocketRef\";\nimport { isTcpSubchannelAddress, SubchannelAddress } from \"./subchannel-address\";\nimport { SubchannelRef as SubchannelRefMessage } from \"./generated/grpc/channelz/v1/SubchannelRef\";\nimport { GetServerRequest__Output } from \"./generated/grpc/channelz/v1/GetServerRequest\";\nimport { GetServerResponse } from \"./generated/grpc/channelz/v1/GetServerResponse\";\nimport { Server as ServerMessage } from \"./generated/grpc/channelz/v1/Server\";\nimport { GetServersRequest__Output } from \"./generated/grpc/channelz/v1/GetServersRequest\";\nimport { GetServersResponse } from \"./generated/grpc/channelz/v1/GetServersResponse\";\nimport { GetTopChannelsRequest__Output } from \"./generated/grpc/channelz/v1/GetTopChannelsRequest\";\nimport { GetTopChannelsResponse } from \"./generated/grpc/channelz/v1/GetTopChannelsResponse\";\nimport { GetSubchannelRequest__Output } from \"./generated/grpc/channelz/v1/GetSubchannelRequest\";\nimport { GetSubchannelResponse } from \"./generated/grpc/channelz/v1/GetSubchannelResponse\";\nimport { Subchannel as SubchannelMessage } from \"./generated/grpc/channelz/v1/Subchannel\";\nimport { GetSocketRequest__Output } from \"./generated/grpc/channelz/v1/GetSocketRequest\";\nimport { GetSocketResponse } from \"./generated/grpc/channelz/v1/GetSocketResponse\";\nimport { Socket as SocketMessage } from \"./generated/grpc/channelz/v1/Socket\";\nimport { Address } from \"./generated/grpc/channelz/v1/Address\";\nimport { Security } from \"./generated/grpc/channelz/v1/Security\";\nimport { GetServerSocketsRequest__Output } from \"./generated/grpc/channelz/v1/GetServerSocketsRequest\";\nimport { GetServerSocketsResponse } from \"./generated/grpc/channelz/v1/GetServerSocketsResponse\";\nimport { ChannelzDefinition, ChannelzHandlers } from \"./generated/grpc/channelz/v1/Channelz\";\nimport { ProtoGrpcType as ChannelzProtoGrpcType } from \"./generated/channelz\";\nimport type { loadSync } from '@grpc/proto-loader';\nimport { registerAdminService } from \"./admin\";\nimport { loadPackageDefinition } from \"./make-client\";\n\nexport type TraceSeverity = 'CT_UNKNOWN' | 'CT_INFO' | 'CT_WARNING' | 'CT_ERROR';\n\nexport interface ChannelRef {\n  kind: 'channel';\n  id: number;\n  name: string;\n}\n\nexport interface SubchannelRef {\n  kind: 'subchannel';\n  id: number;\n  name: string;\n}\n\nexport interface ServerRef {\n  kind: 'server';\n  id: number;\n}\n\nexport interface SocketRef {\n  kind: 'socket';\n  id: number;\n  name: string;\n}\n\nfunction channelRefToMessage(ref: ChannelRef): ChannelRefMessage {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\n\nfunction subchannelRefToMessage(ref: SubchannelRef): SubchannelRefMessage {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  }\n}\n\nfunction serverRefToMessage(ref: ServerRef): ServerRefMessage {\n  return {\n    server_id: ref.id\n  }\n}\n\nfunction socketRefToMessage(ref: SocketRef): SocketRefMessage {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  }\n}\n\ninterface TraceEvent {\n  description: string;\n  severity: TraceSeverity;\n  timestamp: Date;\n  childChannel?: ChannelRef;\n  childSubchannel?: SubchannelRef;\n}\n\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\n\nexport class ChannelzTrace {\n  events: TraceEvent[] = [];\n  creationTimestamp: Date;\n  eventsLogged: number = 0;\n\n  constructor() {\n    this.creationTimestamp = new Date();\n  }\n\n  addTrace(severity: TraceSeverity, description: string, child?: ChannelRef | SubchannelRef) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: child?.kind === 'channel' ? child : undefined,\n      childSubchannel: child?.kind === 'subchannel' ? child : undefined\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n\n  getTraceMessage(): ChannelTrace {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        }\n      })\n    };\n  }\n}\n\nexport class ChannelzChildrenTracker {\n  private channelChildren: Map<number, {ref: ChannelRef, count: number}> = new Map<number, {ref: ChannelRef, count: number}>();\n  private subchannelChildren: Map<number, {ref: SubchannelRef, count: number}> = new Map<number, {ref: SubchannelRef, count: number}>();\n  private socketChildren: Map<number, {ref: SocketRef, count: number}> = new Map<number, {ref: SocketRef, count: number}>();\n\n  refChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        let trackedChild = this.channelChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.channelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'subchannel':{\n        let trackedChild = this.subchannelChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.subchannelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'socket':{\n        let trackedChild = this.socketChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.socketChildren.set(child.id, trackedChild);\n        break;\n      }\n    }\n  }\n\n  unrefChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        let trackedChild = this.channelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.channelChildren.delete(child.id);\n          } else {\n            this.channelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'subchannel': {\n        let trackedChild = this.subchannelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.subchannelChildren.delete(child.id);\n          } else {\n            this.subchannelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'socket': {\n        let trackedChild = this.socketChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.socketChildren.delete(child.id);\n          } else {\n            this.socketChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  getChildLists(): ChannelzChildren {\n    const channels: ChannelRef[] = [];\n    for (const {ref} of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n    const subchannels: SubchannelRef[] = [];\n    for (const {ref} of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n    const sockets: SocketRef[] = [];\n    for (const {ref} of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n    return {channels, subchannels, sockets};\n  }\n}\n\nexport class ChannelzCallTracker {\n  callsStarted: number = 0;\n  callsSucceeded: number = 0;\n  callsFailed: number = 0;\n  lastCallStartedTimestamp: Date | null = null;\n\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\n\nexport interface ChannelzChildren {\n  channels: ChannelRef[];\n  subchannels: SubchannelRef[];\n  sockets: SocketRef[];\n}\n\nexport interface ChannelInfo {\n  target: string;\n  state: ConnectivityState;\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  children: ChannelzChildren;\n}\n\nexport interface SubchannelInfo extends ChannelInfo {}\n\nexport interface ServerInfo {\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  listenerChildren: ChannelzChildren;\n  sessionChildren: ChannelzChildren;\n}\n\nexport interface TlsInfo {\n  cipherSuiteStandardName: string | null;\n  cipherSuiteOtherName: string | null;\n  localCertificate: Buffer | null;\n  remoteCertificate: Buffer | null;\n}\n\nexport interface SocketInfo {\n  localAddress: SubchannelAddress | null;\n  remoteAddress: SubchannelAddress | null;\n  security: TlsInfo | null;\n  remoteName: string | null;\n  streamsStarted: number;\n  streamsSucceeded: number;\n  streamsFailed: number;\n  messagesSent: number;\n  messagesReceived: number;\n  keepAlivesSent: number;\n  lastLocalStreamCreatedTimestamp: Date | null;\n  lastRemoteStreamCreatedTimestamp: Date | null;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n  localFlowControlWindow: number | null;\n  remoteFlowControlWindow: number | null;\n}\n\ninterface ChannelEntry {\n  ref: ChannelRef;\n  getInfo(): ChannelInfo;\n}\n\ninterface SubchannelEntry {\n  ref: SubchannelRef;\n  getInfo(): SubchannelInfo;\n}\n\ninterface ServerEntry {\n  ref: ServerRef;\n  getInfo(): ServerInfo;\n}\n\ninterface SocketEntry {\n  ref: SocketRef;\n  getInfo(): SocketInfo;\n}\n\nlet nextId = 1;\n\nfunction getNextId(): number {\n  return nextId++;\n}\n\nconst channels: (ChannelEntry | undefined)[] = [];\nconst subchannels: (SubchannelEntry | undefined)[] = [];\nconst servers: (ServerEntry | undefined)[] = [];\nconst sockets: (SocketEntry | undefined)[] = [];\n\nexport function registerChannelzChannel(name: string, getInfo: () => ChannelInfo): ChannelRef {\n  const id = getNextId();\n  const ref: ChannelRef = {id, name, kind: 'channel'};\n  channels[id] = { ref, getInfo };\n  return ref;\n}\n\nexport function registerChannelzSubchannel(name: string, getInfo:() => SubchannelInfo): SubchannelRef {\n  const id = getNextId();\n  const ref: SubchannelRef = {id, name, kind: 'subchannel'};\n  subchannels[id] = { ref, getInfo };\n  return ref;\n}\n\nexport function registerChannelzServer(getInfo: () => ServerInfo): ServerRef {\n  const id = getNextId();\n  const ref: ServerRef = {id, kind: 'server'};\n  servers[id] = { ref, getInfo };\n  return ref;\n}\n\nexport function registerChannelzSocket(name: string, getInfo: () => SocketInfo): SocketRef {\n  const id = getNextId();\n  const ref: SocketRef = {id, name, kind: 'socket'};\n  sockets[id] = { ref, getInfo};\n  return ref;\n}\n\nexport function unregisterChannelzRef(ref: ChannelRef | SubchannelRef | ServerRef | SocketRef) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n    case 'server':\n      delete servers[ref.id];\n      return;\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\n\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection: string): [number, number] {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk: string): number[] {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result: number[] = [];\n  return result.concat(...bytePairs);\n}\n\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns \n */\nfunction ipAddressStringToBuffer(ipAddress: string): Buffer | null {\n  if (isIPv4(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if (isIPv6(ipAddress)) {\n    let leftSection: string;\n    let rightSection: string;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\n\nfunction connectivityStateToMessage(state: ConnectivityState): ChannelConnectivityState__Output {\n  switch (state) {\n    case ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n    case ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n    case ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n    case ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n    case ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\n\nfunction dateToProtoTimestamp(date?: Date | null): Timestamp | null {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: (millisSinceEpoch / 1000) | 0,\n    nanos: (millisSinceEpoch % 1000) * 1_000_000\n  }\n}\n\nfunction getChannelMessage(channelEntry: ChannelEntry): ChannelMessage {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\n\nfunction GetChannel(call: ServerUnaryCall<GetChannelRequest__Output, GetChannelResponse>, callback: sendUnaryData<GetChannelResponse>): void {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n  if (channelEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n  callback(null, {channel: getChannelMessage(channelEntry)});\n}\n\nfunction GetTopChannels(call: ServerUnaryCall<GetTopChannelsRequest__Output, GetTopChannelsResponse>, callback: sendUnaryData<GetTopChannelsResponse>): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ChannelMessage[] = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n    if (channelEntry === undefined) {\n      continue;\n    }\n    resultList.push(getChannelMessage(channelEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction getServerMessage(serverEntry: ServerEntry): ServerMessage {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\n\nfunction GetServer(call: ServerUnaryCall<GetServerRequest__Output, GetServerResponse>, callback: sendUnaryData<GetServerResponse>): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  callback(null, {server: getServerMessage(serverEntry)});\n}\n\nfunction GetServers(call: ServerUnaryCall<GetServersRequest__Output, GetServersResponse>, callback: sendUnaryData<GetServersResponse>): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ServerMessage[] = [];\n  let i = Number.parseInt(call.request.start_server_id);\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n    if (serverEntry === undefined) {\n      continue;\n    }\n    resultList.push(getServerMessage(serverEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction GetSubchannel(call: ServerUnaryCall<GetSubchannelRequest__Output, GetSubchannelResponse>, callback: sendUnaryData<GetSubchannelResponse>): void {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage: SubchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {subchannel: subchannelMessage});\n}\n\nfunction subchannelAddressToAddressMessage(subchannelAddress: SubchannelAddress): Address {\n  if (isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: ipAddressStringToBuffer(subchannelAddress.host) ?? undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\n\nfunction GetSocket(call: ServerUnaryCall<GetSocketRequest__Output, GetSocketResponse>, callback: sendUnaryData<GetSocketResponse>): void {\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n  if (socketEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage: Security | null = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: resolvedInfo.security.cipherSuiteStandardName ?? undefined,\n      other_name: resolvedInfo.security.cipherSuiteOtherName ?? undefined,\n      local_certificate: resolvedInfo.security.localCertificate ?? undefined,\n      remote_certificate: resolvedInfo.security.remoteCertificate ?? undefined\n    }\n  } : null;\n  const socketMessage: SocketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: resolvedInfo.remoteName ?? undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null,\n    }\n  };\n  callback(null, {socket: socketMessage});\n}\n\nfunction GetServerSockets(call: ServerUnaryCall<GetServerSocketsRequest__Output, GetServerSocketsResponse>, callback: sendUnaryData<GetServerSocketsResponse>): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList: SocketRefMessage[] = [];\n  let i = 0;\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\n\nexport function getChannelzHandlers(): ChannelzHandlers {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\n\nlet loadedChannelzDefinition: ChannelzDefinition | null = null;\n\nexport function getChannelzServiceDefinition(): ChannelzDefinition {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync as typeof loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [\n      `${__dirname}/../../proto`\n    ]\n  });\n  const channelzGrpcObject = loadPackageDefinition(loadedProto) as unknown as ChannelzProtoGrpcType;\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\n\nexport function setup() {\n  registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}"]},"metadata":{},"sourceType":"script"}