{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Metadata = void 0;\n\nconst logging_1 = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\n\nfunction isLegalKey(key) {\n  return LEGAL_KEY_REGEX.test(key);\n}\n\nfunction isLegalNonBinaryValue(value) {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\n\nfunction isBinaryKey(key) {\n  return key.endsWith('-bin');\n}\n\nfunction isCustomMetadata(key) {\n  return !key.startsWith('grpc-');\n}\n\nfunction normalizeKey(key) {\n  return key.toLowerCase();\n}\n\nfunction validate(key, value) {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n\n  if (value !== null && value !== undefined) {\n    if (isBinaryKey(key)) {\n      if (!(value instanceof Buffer)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (value instanceof Buffer) {\n        throw new Error(\"keys that don't end with '-bin' must have String values\");\n      }\n\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n      }\n    }\n  }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\n\n\nclass Metadata {\n  constructor(options) {\n    this.internalRepr = new Map();\n\n    if (options === undefined) {\n      this.options = {};\n    } else {\n      this.options = options;\n    }\n  }\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  set(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  add(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    const existingValue = this.internalRepr.get(key);\n\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n\n\n  remove(key) {\n    key = normalizeKey(key);\n    validate(key);\n    this.internalRepr.delete(key);\n  }\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n\n\n  get(key) {\n    key = normalizeKey(key);\n    validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n\n\n  getMap() {\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = v instanceof Buffer ? v.slice() : v;\n      }\n    });\n    return result;\n  }\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n\n\n  clone() {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n    this.internalRepr.forEach((value, key) => {\n      const clonedValue = value.map(v => {\n        if (v instanceof Buffer) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n      newInternalRepr.set(key, clonedValue);\n    });\n    return newMetadata;\n  }\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n\n\n  merge(other) {\n    other.internalRepr.forEach((values, key) => {\n      const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n      this.internalRepr.set(key, mergedValue);\n    });\n  }\n\n  setOptions(options) {\n    this.options = options;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n\n\n  toHttp2Headers() {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(value => {\n        if (value instanceof Buffer) {\n          return value.toString('base64');\n        } else {\n          return value;\n        }\n      });\n    });\n    return result;\n  } // For compatibility with the other Metadata implementation\n\n\n  _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n  /**\n   * This modifies the behavior of JSON.stringify to show an object\n   * representation of the metadata map.\n   */\n\n\n  toJSON() {\n    const result = {};\n\n    for (const [key, values] of this.internalRepr.entries()) {\n      result[key] = values;\n    }\n\n    return result;\n  }\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n\n\n  static fromHttp2Headers(headers) {\n    const result = new Metadata();\n    Object.keys(headers).forEach(key => {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        return;\n      }\n\n      const values = headers[key];\n\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach(v => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            result.add(key, values);\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        logging_1.log(constants_1.LogVerbosity.ERROR, message);\n      }\n    });\n    return result;\n  }\n\n}\n\nexports.Metadata = Metadata;","map":{"version":3,"mappings":"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","names":["LEGAL_KEY_REGEX","LEGAL_NON_BINARY_VALUE_REGEX","isLegalKey","key","test","isLegalNonBinaryValue","value","isBinaryKey","endsWith","isCustomMetadata","startsWith","normalizeKey","toLowerCase","validate","Error","undefined","Buffer","Metadata","constructor","options","Map","set","internalRepr","add","existingValue","get","push","remove","delete","getMap","result","forEach","values","length","v","slice","clone","newMetadata","newInternalRepr","clonedValue","map","from","merge","other","mergedValue","concat","setOptions","getOptions","toHttp2Headers","toString","_getCoreRepresentation","toJSON","entries","fromHttp2Headers","headers","Object","keys","charAt","Array","isArray","split","trim","error","message","logging_1","constants_1","ERROR","exports"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/metadata.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\n\nexport type MetadataValue = string | Buffer;\nexport type MetadataObject = Map<string, MetadataValue[]>;\n\nfunction isLegalKey(key: string): boolean {\n  return LEGAL_KEY_REGEX.test(key);\n}\n\nfunction isLegalNonBinaryValue(value: string): boolean {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\n\nfunction isBinaryKey(key: string): boolean {\n  return key.endsWith('-bin');\n}\n\nfunction isCustomMetadata(key: string): boolean {\n  return !key.startsWith('grpc-');\n}\n\nfunction normalizeKey(key: string): string {\n  return key.toLowerCase();\n}\n\nfunction validate(key: string, value?: MetadataValue): void {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n  if (value !== null && value !== undefined) {\n    if (isBinaryKey(key)) {\n      if (!(value instanceof Buffer)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (value instanceof Buffer) {\n        throw new Error(\n          \"keys that don't end with '-bin' must have String values\"\n        );\n      }\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error(\n          'Metadata string value \"' + value + '\" contains illegal characters'\n        );\n      }\n    }\n  }\n}\n\nexport interface MetadataOptions {\n  /* Signal that the request is idempotent. Defaults to false */\n  idempotentRequest?: boolean;\n  /* Signal that the call should not return UNAVAILABLE before it has\n   * started. Defaults to false. */\n  waitForReady?: boolean;\n  /* Signal that the call is cacheable. GRPC is free to use GET verb.\n   * Defaults to false */\n  cacheableRequest?: boolean;\n  /* Signal that the initial metadata should be corked. Defaults to false. */\n  corked?: boolean;\n}\n\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nexport class Metadata {\n  protected internalRepr: MetadataObject = new Map<string, MetadataValue[]>();\n  private options: MetadataOptions;\n\n  constructor(options?: MetadataOptions) {\n    if (options === undefined) {\n      this.options = {};\n    } else {\n      this.options = options;\n    }\n  }\n\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  set(key: string, value: MetadataValue): void {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  add(key: string, value: MetadataValue): void {\n    key = normalizeKey(key);\n    validate(key, value);\n\n    const existingValue: MetadataValue[] | undefined = this.internalRepr.get(\n      key\n    );\n\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n  remove(key: string): void {\n    key = normalizeKey(key);\n    validate(key);\n    this.internalRepr.delete(key);\n  }\n\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n  get(key: string): MetadataValue[] {\n    key = normalizeKey(key);\n    validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n  getMap(): { [key: string]: MetadataValue } {\n    const result: { [key: string]: MetadataValue } = {};\n\n    this.internalRepr.forEach((values, key) => {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = v instanceof Buffer ? v.slice() : v;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n  clone(): Metadata {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n\n    this.internalRepr.forEach((value, key) => {\n      const clonedValue: MetadataValue[] = value.map((v) => {\n        if (v instanceof Buffer) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n\n      newInternalRepr.set(key, clonedValue);\n    });\n\n    return newMetadata;\n  }\n\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n  merge(other: Metadata): void {\n    other.internalRepr.forEach((values, key) => {\n      const mergedValue: MetadataValue[] = (\n        this.internalRepr.get(key) || []\n      ).concat(values);\n\n      this.internalRepr.set(key, mergedValue);\n    });\n  }\n\n  setOptions(options: MetadataOptions) {\n    this.options = options;\n  }\n\n  getOptions(): MetadataOptions {\n    return this.options;\n  }\n\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n  toHttp2Headers(): http2.OutgoingHttpHeaders {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result: http2.OutgoingHttpHeaders = {};\n    this.internalRepr.forEach((values, key) => {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map((value) => {\n        if (value instanceof Buffer) {\n          return value.toString('base64');\n        } else {\n          return value;\n        }\n      });\n    });\n    return result;\n  }\n\n  // For compatibility with the other Metadata implementation\n  private _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n\n  /**\n   * This modifies the behavior of JSON.stringify to show an object\n   * representation of the metadata map.\n   */\n  toJSON() {\n    const result: { [key: string]: MetadataValue[] } = {};\n    for (const [key, values] of this.internalRepr.entries()) {\n      result[key] = values;\n    }\n    return result;\n  }\n\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n  static fromHttp2Headers(headers: http2.IncomingHttpHeaders): Metadata {\n    const result = new Metadata();\n    Object.keys(headers).forEach((key) => {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        return;\n      }\n\n      const values = headers[key];\n\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach((value) => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach((v) => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach((value) => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            result.add(key, values);\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        log(LogVerbosity.ERROR, message);\n      }\n    });\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}