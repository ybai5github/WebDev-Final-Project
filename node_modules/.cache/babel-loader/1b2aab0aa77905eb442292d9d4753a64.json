{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChildLoadBalancerHandler = void 0;\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst TYPE_NAME = 'child_load_balancer_helper';\n\nclass ChildLoadBalancerHandler {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.currentChild = null;\n    this.pendingChild = null;\n    this.ChildPolicyHelper = class {\n      constructor(parent) {\n        this.parent = parent;\n        this.child = null;\n      }\n\n      createSubchannel(subchannelAddress, subchannelArgs) {\n        return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n      }\n\n      updateState(connectivityState, picker) {\n        var _a;\n\n        if (this.calledByPendingChild()) {\n          if (connectivityState !== connectivity_state_1.ConnectivityState.READY) {\n            return;\n          }\n\n          (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n          this.parent.currentChild = this.parent.pendingChild;\n          this.parent.pendingChild = null;\n        } else if (!this.calledByCurrentChild()) {\n          return;\n        }\n\n        this.parent.channelControlHelper.updateState(connectivityState, picker);\n      }\n\n      requestReresolution() {\n        var _a;\n\n        const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n\n        if (this.child === latestChild) {\n          this.parent.channelControlHelper.requestReresolution();\n        }\n      }\n\n      setChild(newChild) {\n        this.child = newChild;\n      }\n\n      addChannelzChild(child) {\n        this.parent.channelControlHelper.addChannelzChild(child);\n      }\n\n      removeChannelzChild(child) {\n        this.parent.channelControlHelper.removeChannelzChild(child);\n      }\n\n      calledByPendingChild() {\n        return this.child === this.parent.pendingChild;\n      }\n\n      calledByCurrentChild() {\n        return this.child === this.parent.currentChild;\n      }\n\n    };\n  }\n  /**\n   * Prerequisites: lbConfig !== null and lbConfig.name is registered\n   * @param addressList\n   * @param lbConfig\n   * @param attributes\n   */\n\n\n  updateAddressList(addressList, lbConfig, attributes) {\n    let childToUpdate;\n\n    if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {\n      const newHelper = new this.ChildPolicyHelper(this);\n      const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);\n      newHelper.setChild(newChild);\n\n      if (this.currentChild === null) {\n        this.currentChild = newChild;\n        childToUpdate = this.currentChild;\n      } else {\n        if (this.pendingChild) {\n          this.pendingChild.destroy();\n        }\n\n        this.pendingChild = newChild;\n        childToUpdate = this.pendingChild;\n      }\n    } else {\n      if (this.pendingChild === null) {\n        childToUpdate = this.currentChild;\n      } else {\n        childToUpdate = this.pendingChild;\n      }\n    }\n\n    childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n  }\n\n  exitIdle() {\n    if (this.currentChild) {\n      this.currentChild.exitIdle();\n\n      if (this.pendingChild) {\n        this.pendingChild.exitIdle();\n      }\n    }\n  }\n\n  resetBackoff() {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n\n  destroy() {\n    if (this.currentChild) {\n      this.currentChild.destroy();\n      this.currentChild = null;\n    }\n\n    if (this.pendingChild) {\n      this.pendingChild.destroy();\n      this.pendingChild = null;\n    }\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n}\n\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;","map":{"version":3,"mappings":"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","names":["TYPE_NAME","ChildLoadBalancerHandler","constructor","channelControlHelper","parent","createSubchannel","subchannelAddress","subchannelArgs","updateState","connectivityState","picker","calledByPendingChild","connectivity_state_1","READY","currentChild","_a","destroy","pendingChild","calledByCurrentChild","requestReresolution","latestChild","child","setChild","newChild","addChannelzChild","removeChannelzChild","updateAddressList","addressList","lbConfig","attributes","childToUpdate","getTypeName","getLoadBalancerName","newHelper","ChildPolicyHelper","load_balancer_1","exitIdle","resetBackoff","exports"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/load-balancer-child-handler.ts"],"sourcesContent":["/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  createLoadBalancer,\n} from './load-balancer';\nimport { SubchannelAddress } from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { Picker } from './picker';\nimport { ChannelRef, SubchannelRef } from './channelz';\nimport { SubchannelInterface } from './subchannel-interface';\n\nconst TYPE_NAME = 'child_load_balancer_helper';\n\nexport class ChildLoadBalancerHandler implements LoadBalancer {\n  private currentChild: LoadBalancer | null = null;\n  private pendingChild: LoadBalancer | null = null;\n\n  private ChildPolicyHelper = class {\n    private child: LoadBalancer | null = null;\n    constructor(private parent: ChildLoadBalancerHandler) {}\n    createSubchannel(\n      subchannelAddress: SubchannelAddress,\n      subchannelArgs: ChannelOptions\n    ): SubchannelInterface {\n      return this.parent.channelControlHelper.createSubchannel(\n        subchannelAddress,\n        subchannelArgs\n      );\n    }\n    updateState(connectivityState: ConnectivityState, picker: Picker): void {\n      if (this.calledByPendingChild()) {\n        if (connectivityState !== ConnectivityState.READY) {\n          return;\n        }\n        this.parent.currentChild?.destroy();\n        this.parent.currentChild = this.parent.pendingChild;\n        this.parent.pendingChild = null;\n      } else if (!this.calledByCurrentChild()) {\n        return;\n      }\n      this.parent.channelControlHelper.updateState(connectivityState, picker);\n    }\n    requestReresolution(): void {\n      const latestChild = this.parent.pendingChild ?? this.parent.currentChild;\n      if (this.child === latestChild) {\n        this.parent.channelControlHelper.requestReresolution();\n      }\n    }\n    setChild(newChild: LoadBalancer) {\n      this.child = newChild;\n    }\n    addChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.addChannelzChild(child);\n    }\n    removeChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.removeChannelzChild(child);\n    }\n    \n    private calledByPendingChild(): boolean {\n      return this.child === this.parent.pendingChild;\n    }\n    private calledByCurrentChild(): boolean {\n      return this.child === this.parent.currentChild;\n    }\n  };\n\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {}\n\n  /**\n   * Prerequisites: lbConfig !== null and lbConfig.name is registered\n   * @param addressList\n   * @param lbConfig\n   * @param attributes\n   */\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig,\n    attributes: { [key: string]: unknown }\n  ): void {\n    let childToUpdate: LoadBalancer;\n    if (\n      this.currentChild === null ||\n      this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()\n    ) {\n      const newHelper = new this.ChildPolicyHelper(this);\n      const newChild = createLoadBalancer(lbConfig, newHelper)!;\n      newHelper.setChild(newChild);\n      if (this.currentChild === null) {\n        this.currentChild = newChild;\n        childToUpdate = this.currentChild;\n      } else {\n        if (this.pendingChild) {\n          this.pendingChild.destroy();\n        }\n        this.pendingChild = newChild;\n        childToUpdate = this.pendingChild;\n      }\n    } else {\n      if (this.pendingChild === null) {\n        childToUpdate = this.currentChild;\n      } else {\n        childToUpdate = this.pendingChild;\n      }\n    }\n    childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n  }\n  exitIdle(): void {\n    if (this.currentChild) {\n      this.currentChild.exitIdle();\n      if (this.pendingChild) {\n        this.pendingChild.exitIdle();\n      }\n    }\n  }\n  resetBackoff(): void {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n  destroy(): void {\n    if (this.currentChild) {\n      this.currentChild.destroy();\n      this.currentChild = null;\n    }\n    if (this.pendingChild) {\n      this.pendingChild.destroy();\n      this.pendingChild = null;\n    }\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}