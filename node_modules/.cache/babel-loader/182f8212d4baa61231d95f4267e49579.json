{"ast":null,"code":"// The framer consists of two [Transform Stream][1] subclasses that operate in [object mode][2]:\n// the Serializer and the Deserializer\n// [1]: https://nodejs.org/api/stream.html#stream_class_stream_transform\n// [2]: https://nodejs.org/api/stream.html#stream_new_stream_readable_options\nvar assert = require('assert');\n\nvar Transform = require('stream').Transform;\n\nexports.Serializer = Serializer;\nexports.Deserializer = Deserializer;\nvar logData = Boolean(process.env.HTTP2_LOG_DATA);\nvar MAX_PAYLOAD_SIZE = 16384;\nvar WINDOW_UPDATE_PAYLOAD_SIZE = 4; // Serializer\n// ----------\n//\n//     Frame Objects\n//     * * * * * * * --+---------------------------\n//                     |                          |\n//                     v                          v           Buffers\n//      [] -----> Payload Ser. --[buffers]--> Header Ser. --> * * * *\n//     empty      adds payload                adds header\n//     array        buffers                     buffer\n\nfunction Serializer(log) {\n  this._log = log.child({\n    component: 'serializer'\n  });\n  Transform.call(this, {\n    objectMode: true\n  });\n}\n\nSerializer.prototype = Object.create(Transform.prototype, {\n  constructor: {\n    value: Serializer\n  }\n}); // When there's an incoming frame object, it first generates the frame type specific part of the\n// frame (payload), and then then adds the header part which holds fields that are common to all\n// frame types (like the length of the payload).\n\nSerializer.prototype._transform = function _transform(frame, encoding, done) {\n  this._log.trace({\n    frame: frame\n  }, 'Outgoing frame');\n\n  assert(frame.type in Serializer, 'Unknown frame type: ' + frame.type);\n  var buffers = [];\n  Serializer[frame.type](frame, buffers);\n  var length = Serializer.commonHeader(frame, buffers);\n  assert(length <= MAX_PAYLOAD_SIZE, 'Frame too large!');\n\n  for (var i = 0; i < buffers.length; i++) {\n    if (logData) {\n      this._log.trace({\n        data: buffers[i]\n      }, 'Outgoing data');\n    }\n\n    this.push(buffers[i]);\n  }\n\n  done();\n}; // Deserializer\n// ------------\n//\n//     Buffers\n//     * * * * --------+-------------------------\n//                     |                        |\n//                     v                        v           Frame Objects\n//      {} -----> Header Des. --{frame}--> Payload Des. --> * * * * * * *\n//     empty      adds parsed              adds parsed\n//     object  header properties        payload properties\n\n\nfunction Deserializer(log, role) {\n  this._role = role;\n  this._log = log.child({\n    component: 'deserializer'\n  });\n  Transform.call(this, {\n    objectMode: true\n  });\n\n  this._next(COMMON_HEADER_SIZE);\n}\n\nDeserializer.prototype = Object.create(Transform.prototype, {\n  constructor: {\n    value: Deserializer\n  }\n}); // The Deserializer is stateful, and it's two main alternating states are: *waiting for header* and\n// *waiting for payload*. The state is stored in the boolean property `_waitingForHeader`.\n//\n// When entering a new state, a `_buffer` is created that will hold the accumulated data (header or\n// payload). The `_cursor` is used to track the progress.\n\nDeserializer.prototype._next = function (size) {\n  this._cursor = 0;\n  this._buffer = new Buffer(size);\n  this._waitingForHeader = !this._waitingForHeader;\n\n  if (this._waitingForHeader) {\n    this._frame = {};\n  }\n}; // Parsing an incoming buffer is an iterative process because it can hold multiple frames if it's\n// large enough. A `cursor` is used to track the progress in parsing the incoming `chunk`.\n\n\nDeserializer.prototype._transform = function _transform(chunk, encoding, done) {\n  var cursor = 0;\n\n  if (logData) {\n    this._log.trace({\n      data: chunk\n    }, 'Incoming data');\n  }\n\n  while (cursor < chunk.length) {\n    // The content of an incoming buffer is first copied to `_buffer`. If it can't hold the full\n    // chunk, then only a part of it is copied.\n    var toCopy = Math.min(chunk.length - cursor, this._buffer.length - this._cursor);\n    chunk.copy(this._buffer, this._cursor, cursor, cursor + toCopy);\n    this._cursor += toCopy;\n    cursor += toCopy; // When `_buffer` is full, it's content gets parsed either as header or payload depending on\n    // the actual state.\n    // If it's header then the parsed data is stored in a temporary variable and then the\n    // deserializer waits for the specified length payload.\n\n    if (this._cursor === this._buffer.length && this._waitingForHeader) {\n      var payloadSize = Deserializer.commonHeader(this._buffer, this._frame);\n\n      if (payloadSize <= MAX_PAYLOAD_SIZE) {\n        this._next(payloadSize);\n      } else {\n        this.emit('error', 'FRAME_SIZE_ERROR');\n        return;\n      }\n    } // If it's payload then the the frame object is finalized and then gets pushed out.\n    // Unknown frame types are ignored.\n    //\n    // Note: If we just finished the parsing of a header and the payload length is 0, this branch\n    // will also run.\n\n\n    if (this._cursor === this._buffer.length && !this._waitingForHeader) {\n      if (this._frame.type) {\n        var error = Deserializer[this._frame.type](this._buffer, this._frame, this._role);\n\n        if (error) {\n          this._log.error('Incoming frame parsing error: ' + error);\n\n          this.emit('error', error);\n        } else {\n          this._log.trace({\n            frame: this._frame\n          }, 'Incoming frame');\n\n          this.push(this._frame);\n        }\n      } else {\n        this._log.error('Unknown type incoming frame'); // Ignore it other than logging\n\n      }\n\n      this._next(COMMON_HEADER_SIZE);\n    }\n  }\n\n  done();\n}; // [Frame Header](https://tools.ietf.org/html/rfc7540#section-4.1)\n// --------------------------------------------------------------\n//\n// HTTP/2 frames share a common base format consisting of a 9-byte header followed by 0 to 2^24 - 1\n// bytes of data.\n//\n// Additional size limits can be set by specific application uses. HTTP limits the frame size to\n// 16,384 octets by default, though this can be increased by a receiver.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                 Length (24)                   |\n//     +---------------+---------------+---------------+\n//     |   Type (8)    |   Flags (8)   |\n//     +-+-----------------------------+---------------+---------------+\n//     |R|                 Stream Identifier (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                     Frame Data (0...)                       ...\n//     +---------------------------------------------------------------+\n//\n// The fields of the frame header are defined as:\n//\n// * Length:\n//   The length of the frame data expressed as an unsigned 24-bit integer. The 9 bytes of the frame\n//   header are not included in this value.\n//\n// * Type:\n//   The 8-bit type of the frame. The frame type determines how the remainder of the frame header\n//   and data are interpreted. Implementations MUST ignore unsupported and unrecognized frame types.\n//\n// * Flags:\n//   An 8-bit field reserved for frame-type specific boolean flags.\n//\n//   Flags are assigned semantics specific to the indicated frame type. Flags that have no defined\n//   semantics for a particular frame type MUST be ignored, and MUST be left unset (0) when sending.\n//\n// * R:\n//   A reserved 1-bit field. The semantics of this bit are undefined and the bit MUST remain unset\n//   (0) when sending and MUST be ignored when receiving.\n//\n// * Stream Identifier:\n//   A 31-bit stream identifier. The value 0 is reserved for frames that are associated with the\n//   connection as a whole as opposed to an individual stream.\n//\n// The structure and content of the remaining frame data is dependent entirely on the frame type.\n\n\nvar COMMON_HEADER_SIZE = 9;\nvar frameTypes = [];\nvar frameFlags = {};\nvar genericAttributes = ['type', 'flags', 'stream'];\nvar typeSpecificAttributes = {};\n\nSerializer.commonHeader = function writeCommonHeader(frame, buffers) {\n  var headerBuffer = new Buffer(COMMON_HEADER_SIZE);\n  var size = 0;\n\n  for (var i = 0; i < buffers.length; i++) {\n    size += buffers[i].length;\n  }\n\n  headerBuffer.writeUInt8(0, 0);\n  headerBuffer.writeUInt16BE(size, 1);\n  var typeId = frameTypes.indexOf(frame.type); // If we are here then the type is valid for sure\n\n  headerBuffer.writeUInt8(typeId, 3);\n  var flagByte = 0;\n\n  for (var flag in frame.flags) {\n    var position = frameFlags[frame.type].indexOf(flag);\n    assert(position !== -1, 'Unknown flag for frame type ' + frame.type + ': ' + flag);\n\n    if (frame.flags[flag]) {\n      flagByte |= 1 << position;\n    }\n  }\n\n  headerBuffer.writeUInt8(flagByte, 4);\n  assert(0 <= frame.stream && frame.stream < 0x7fffffff, frame.stream);\n  headerBuffer.writeUInt32BE(frame.stream || 0, 5);\n  buffers.unshift(headerBuffer);\n  return size;\n};\n\nDeserializer.commonHeader = function readCommonHeader(buffer, frame) {\n  if (buffer.length < 9) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var totallyWastedByte = buffer.readUInt8(0);\n  var length = buffer.readUInt16BE(1); // We do this just for sanity checking later on, to make sure no one sent us a\n  // frame that's super large.\n\n  length += totallyWastedByte << 16;\n  frame.type = frameTypes[buffer.readUInt8(3)];\n\n  if (!frame.type) {\n    // We are required to ignore unknown frame types\n    return length;\n  }\n\n  frame.flags = {};\n  var flagByte = buffer.readUInt8(4);\n  var definedFlags = frameFlags[frame.type];\n\n  for (var i = 0; i < definedFlags.length; i++) {\n    frame.flags[definedFlags[i]] = Boolean(flagByte & 1 << i);\n  }\n\n  frame.stream = buffer.readUInt32BE(5) & 0x7fffffff;\n  return length;\n}; // Frame types\n// ===========\n// Every frame type is registered in the following places:\n//\n// * `frameTypes`: a register of frame type codes (used by `commonHeader()`)\n// * `frameFlags`: a register of valid flags for frame types (used by `commonHeader()`)\n// * `typeSpecificAttributes`: a register of frame specific frame object attributes (used by\n//   logging code and also serves as documentation for frame objects)\n// [DATA Frames](https://tools.ietf.org/html/rfc7540#section-6.1)\n// ------------------------------------------------------------\n//\n// DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a\n// stream.\n//\n// The DATA frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n\n\nframeTypes[0x0] = 'DATA';\nframeFlags.DATA = ['END_STREAM', 'RESERVED2', 'RESERVED4', 'PADDED'];\ntypeSpecificAttributes.DATA = ['data'];\n\nSerializer.DATA = function writeData(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.DATA = function readData(buffer, frame) {\n  var dataOffset = 0;\n  var paddingLength = 0;\n\n  if (frame.flags.PADDED) {\n    if (buffer.length < 1) {\n      // We must have at least one byte for padding control, but we don't. Bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    paddingLength = buffer.readUInt8(dataOffset) & 0xff;\n    dataOffset = 1;\n  }\n\n  if (paddingLength) {\n    if (paddingLength >= buffer.length - 1) {\n      // We don't have enough room for the padding advertised - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n}; // [HEADERS](https://tools.ietf.org/html/rfc7540#section-6.2)\n// --------------------------------------------------------------\n//\n// The HEADERS frame (type=0x1) allows the sender to create a stream.\n//\n// The HEADERS frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame contains the entire payload necessary to provide\n//   a complete set of headers.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n// * PRIORITY (0x20):\n//   Bit 6 being set indicates that the Exlusive Flag (E), Stream Dependency, and Weight fields are\n//   present.\n\n\nframeTypes[0x1] = 'HEADERS';\nframeFlags.HEADERS = ['END_STREAM', 'RESERVED2', 'END_HEADERS', 'PADDED', 'RESERVED5', 'PRIORITY'];\ntypeSpecificAttributes.HEADERS = ['priorityDependency', 'priorityWeight', 'exclusiveDependency', 'headers', 'data']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+---------------+-------------------------------+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+-----------------------------------------------+\n//     |                   Header Block Fragment (*)                 ...\n//     +---------------------------------------------------------------+\n//     |                           Padding (*)                       ...\n//     +---------------------------------------------------------------+\n//\n// The payload of a HEADERS frame contains a Headers Block\n\nSerializer.HEADERS = function writeHeadersPriority(frame, buffers) {\n  if (frame.flags.PRIORITY) {\n    var buffer = new Buffer(5);\n    assert(0 <= frame.priorityDependency && frame.priorityDependency <= 0x7fffffff, frame.priorityDependency);\n    buffer.writeUInt32BE(frame.priorityDependency, 0);\n\n    if (frame.exclusiveDependency) {\n      buffer[0] |= 0x80;\n    }\n\n    assert(0 <= frame.priorityWeight && frame.priorityWeight <= 0xff, frame.priorityWeight);\n    buffer.writeUInt8(frame.priorityWeight, 4);\n    buffers.push(buffer);\n  }\n\n  buffers.push(frame.data);\n};\n\nDeserializer.HEADERS = function readHeadersPriority(buffer, frame) {\n  var minFrameLength = 0;\n\n  if (frame.flags.PADDED) {\n    minFrameLength += 1;\n  }\n\n  if (frame.flags.PRIORITY) {\n    minFrameLength += 5;\n  }\n\n  if (buffer.length < minFrameLength) {\n    // Peer didn't send enough data - bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dataOffset = 0;\n  var paddingLength = 0;\n\n  if (frame.flags.PADDED) {\n    paddingLength = buffer.readUInt8(dataOffset) & 0xff;\n    dataOffset = 1;\n  }\n\n  if (frame.flags.PRIORITY) {\n    var dependencyData = new Buffer(4);\n    buffer.copy(dependencyData, 0, dataOffset, dataOffset + 4);\n    dataOffset += 4;\n    frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n    dependencyData[0] &= 0x7f;\n    frame.priorityDependency = dependencyData.readUInt32BE(0);\n    frame.priorityWeight = buffer.readUInt8(dataOffset);\n    dataOffset += 1;\n  }\n\n  if (paddingLength) {\n    if (buffer.length - dataOffset < paddingLength) {\n      // Not enough data left to satisfy the advertised padding - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n}; // [PRIORITY](https://tools.ietf.org/html/rfc7540#section-6.3)\n// -------------------------------------------------------\n//\n// The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream.\n//\n// The PRIORITY frame does not define any flags.\n\n\nframeTypes[0x2] = 'PRIORITY';\nframeFlags.PRIORITY = [];\ntypeSpecificAttributes.PRIORITY = ['priorityDependency', 'priorityWeight', 'exclusiveDependency']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+\n//\n// The payload of a PRIORITY frame contains an exclusive bit, a 31-bit dependency, and an 8-bit weight\n\nSerializer.PRIORITY = function writePriority(frame, buffers) {\n  var buffer = new Buffer(5);\n  assert(0 <= frame.priorityDependency && frame.priorityDependency <= 0x7fffffff, frame.priorityDependency);\n  buffer.writeUInt32BE(frame.priorityDependency, 0);\n\n  if (frame.exclusiveDependency) {\n    buffer[0] |= 0x80;\n  }\n\n  assert(0 <= frame.priorityWeight && frame.priorityWeight <= 0xff, frame.priorityWeight);\n  buffer.writeUInt8(frame.priorityWeight, 4);\n  buffers.push(buffer);\n};\n\nDeserializer.PRIORITY = function readPriority(buffer, frame) {\n  if (buffer.length < 5) {\n    // PRIORITY frames are 5 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dependencyData = new Buffer(4);\n  buffer.copy(dependencyData, 0, 0, 4);\n  frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n  dependencyData[0] &= 0x7f;\n  frame.priorityDependency = dependencyData.readUInt32BE(0);\n  frame.priorityWeight = buffer.readUInt8(4);\n}; // [RST_STREAM](https://tools.ietf.org/html/rfc7540#section-6.4)\n// -----------------------------------------------------------\n//\n// The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.\n//\n// No type-flags are defined.\n\n\nframeTypes[0x3] = 'RST_STREAM';\nframeFlags.RST_STREAM = [];\ntypeSpecificAttributes.RST_STREAM = ['error']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                         Error Code (32)                       |\n//     +---------------------------------------------------------------+\n//\n// The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error\n// code (see Error Codes). The error code indicates why the stream is being terminated.\n\nSerializer.RST_STREAM = function writeRstStream(frame, buffers) {\n  var buffer = new Buffer(4);\n  var code = errorCodes.indexOf(frame.error);\n  assert(0 <= code && code <= 0xffffffff, code);\n  buffer.writeUInt32BE(code, 0);\n  buffers.push(buffer);\n};\n\nDeserializer.RST_STREAM = function readRstStream(buffer, frame) {\n  if (buffer.length < 4) {\n    // RST_STREAM is 4 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.error = errorCodes[buffer.readUInt32BE(0)];\n\n  if (!frame.error) {\n    // Unknown error codes are considered equivalent to INTERNAL_ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n}; // [SETTINGS](https://tools.ietf.org/html/rfc7540#section-6.5)\n// -------------------------------------------------------\n//\n// The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints\n// communicate.\n//\n// The SETTINGS frame defines the following flag:\n// * ACK (0x1):\n//   Bit 1 being set indicates that this frame acknowledges receipt and application of the peer's\n//   SETTINGS frame.\n\n\nframeTypes[0x4] = 'SETTINGS';\nframeFlags.SETTINGS = ['ACK'];\ntypeSpecificAttributes.SETTINGS = ['settings']; // The payload of a SETTINGS frame consists of zero or more settings. Each setting consists of a\n// 16-bit identifier, and an unsigned 32-bit value.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |         Identifier(16)          |        Value (32)           |\n//     +-----------------+---------------------------------------------+\n//     ...Value                          |\n//     +---------------------------------+\n//\n// Each setting in a SETTINGS frame replaces the existing value for that setting.  Settings are\n// processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to\n// maintain any state other than the current value of settings.  Therefore, the value of a setting\n// is the last value that is seen by a receiver. This permits the inclusion of the same settings\n// multiple times in the same SETTINGS frame, though doing so does nothing other than waste\n// connection capacity.\n\nSerializer.SETTINGS = function writeSettings(frame, buffers) {\n  var settings = [],\n      settingsLeft = Object.keys(frame.settings);\n  definedSettings.forEach(function (setting, id) {\n    if (setting.name in frame.settings) {\n      settingsLeft.splice(settingsLeft.indexOf(setting.name), 1);\n      var value = frame.settings[setting.name];\n      settings.push({\n        id: id,\n        value: setting.flag ? Boolean(value) : value\n      });\n    }\n  });\n  assert(settingsLeft.length === 0, 'Unknown settings: ' + settingsLeft.join(', '));\n  var buffer = new Buffer(settings.length * 6);\n\n  for (var i = 0; i < settings.length; i++) {\n    buffer.writeUInt16BE(settings[i].id & 0xffff, i * 6);\n    buffer.writeUInt32BE(settings[i].value, i * 6 + 2);\n  }\n\n  buffers.push(buffer);\n};\n\nDeserializer.SETTINGS = function readSettings(buffer, frame, role) {\n  frame.settings = {}; // Receipt of a SETTINGS frame with the ACK flag set and a length\n  // field value other than 0 MUST be treated as a connection error\n  // (Section 5.4.1) of type FRAME_SIZE_ERROR.\n\n  if (frame.flags.ACK && buffer.length != 0) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  if (buffer.length % 6 !== 0) {\n    return 'PROTOCOL_ERROR';\n  }\n\n  for (var i = 0; i < buffer.length / 6; i++) {\n    var id = buffer.readUInt16BE(i * 6) & 0xffff;\n    var setting = definedSettings[id];\n\n    if (setting) {\n      if (role == 'CLIENT' && setting.name == 'SETTINGS_ENABLE_PUSH') {\n        return 'SETTINGS frame on client got SETTINGS_ENABLE_PUSH';\n      }\n\n      var value = buffer.readUInt32BE(i * 6 + 2);\n      frame.settings[setting.name] = setting.flag ? Boolean(value & 0x1) : value;\n    }\n  }\n}; // The following settings are defined:\n\n\nvar definedSettings = []; // * SETTINGS_HEADER_TABLE_SIZE (1):\n//   Allows the sender to inform the remote endpoint of the size of the header compression table\n//   used to decode header blocks.\n\ndefinedSettings[1] = {\n  name: 'SETTINGS_HEADER_TABLE_SIZE',\n  flag: false\n}; // * SETTINGS_ENABLE_PUSH (2):\n//   This setting can be use to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame\n//   if it receives this setting set to a value of 0. The default value is 1, which indicates that\n//   push is permitted.\n\ndefinedSettings[2] = {\n  name: 'SETTINGS_ENABLE_PUSH',\n  flag: true\n}; // * SETTINGS_MAX_CONCURRENT_STREAMS (3):\n//   indicates the maximum number of concurrent streams that the sender will allow.\n\ndefinedSettings[3] = {\n  name: 'SETTINGS_MAX_CONCURRENT_STREAMS',\n  flag: false\n}; // * SETTINGS_INITIAL_WINDOW_SIZE (4):\n//   indicates the sender's initial stream window size (in bytes) for new streams.\n\ndefinedSettings[4] = {\n  name: 'SETTINGS_INITIAL_WINDOW_SIZE',\n  flag: false\n}; // * SETTINGS_MAX_FRAME_SIZE (5):\n//   indicates the maximum size of a frame the receiver will allow.\n\ndefinedSettings[5] = {\n  name: 'SETTINGS_MAX_FRAME_SIZE',\n  flag: false\n}; // [PUSH_PROMISE](https://tools.ietf.org/html/rfc7540#section-6.6)\n// ---------------------------------------------------------------\n//\n// The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the\n// sender intends to initiate.\n//\n// The PUSH_PROMISE frame defines the following flags:\n//\n// * END_PUSH_PROMISE (0x4):\n//   The END_PUSH_PROMISE bit indicates that this frame contains the entire payload necessary to\n//   provide a complete set of headers.\n\nframeTypes[0x5] = 'PUSH_PROMISE';\nframeFlags.PUSH_PROMISE = ['RESERVED1', 'RESERVED2', 'END_PUSH_PROMISE', 'PADDED'];\ntypeSpecificAttributes.PUSH_PROMISE = ['promised_stream', 'headers', 'data']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+-----------------------------------------------+\n//     |X|                Promised-Stream-ID (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                 Header Block Fragment (*)                   ...\n//     +---------------------------------------------------------------+\n//     |                         Padding (*)                         ...\n//     +---------------------------------------------------------------+\n//\n// The PUSH_PROMISE frame includes the unsigned 31-bit identifier of\n// the stream the endpoint plans to create along with a minimal set of headers that provide\n// additional context for the stream.\n\nSerializer.PUSH_PROMISE = function writePushPromise(frame, buffers) {\n  var buffer = new Buffer(4);\n  var promised_stream = frame.promised_stream;\n  assert(0 <= promised_stream && promised_stream <= 0x7fffffff, promised_stream);\n  buffer.writeUInt32BE(promised_stream, 0);\n  buffers.push(buffer);\n  buffers.push(frame.data);\n};\n\nDeserializer.PUSH_PROMISE = function readPushPromise(buffer, frame) {\n  if (buffer.length < 4) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dataOffset = 0;\n  var paddingLength = 0;\n\n  if (frame.flags.PADDED) {\n    if (buffer.length < 5) {\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    paddingLength = buffer.readUInt8(dataOffset) & 0xff;\n    dataOffset = 1;\n  }\n\n  frame.promised_stream = buffer.readUInt32BE(dataOffset) & 0x7fffffff;\n  dataOffset += 4;\n\n  if (paddingLength) {\n    if (buffer.length - dataOffset < paddingLength) {\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n}; // [PING](https://tools.ietf.org/html/rfc7540#section-6.7)\n// -----------------------------------------------\n//\n// The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the\n// sender, as well as determining whether an idle connection is still functional.\n//\n// The PING frame defines one type-specific flag:\n//\n// * ACK (0x1):\n//   Bit 1 being set indicates that this PING frame is a PING response.\n\n\nframeTypes[0x6] = 'PING';\nframeFlags.PING = ['ACK'];\ntypeSpecificAttributes.PING = ['data']; // In addition to the frame header, PING frames MUST contain 8 additional octets of opaque data.\n\nSerializer.PING = function writePing(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.PING = function readPing(buffer, frame) {\n  if (buffer.length !== 8) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.data = buffer;\n}; // [GOAWAY](https://tools.ietf.org/html/rfc7540#section-6.8)\n// ---------------------------------------------------\n//\n// The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this connection.\n//\n// The GOAWAY frame does not define any flags.\n\n\nframeTypes[0x7] = 'GOAWAY';\nframeFlags.GOAWAY = [];\ntypeSpecificAttributes.GOAWAY = ['last_stream', 'error']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |X|                  Last-Stream-ID (31)                        |\n//     +-+-------------------------------------------------------------+\n//     |                      Error Code (32)                          |\n//     +---------------------------------------------------------------+\n//\n// The last stream identifier in the GOAWAY frame contains the highest numbered stream identifier\n// for which the sender of the GOAWAY frame has received frames on and might have taken some action\n// on.\n//\n// The GOAWAY frame also contains a 32-bit error code (see Error Codes) that contains the reason for\n// closing the connection.\n\nSerializer.GOAWAY = function writeGoaway(frame, buffers) {\n  var buffer = new Buffer(8);\n  var last_stream = frame.last_stream;\n  assert(0 <= last_stream && last_stream <= 0x7fffffff, last_stream);\n  buffer.writeUInt32BE(last_stream, 0);\n  var code = errorCodes.indexOf(frame.error);\n  assert(0 <= code && code <= 0xffffffff, code);\n  buffer.writeUInt32BE(code, 4);\n  buffers.push(buffer);\n};\n\nDeserializer.GOAWAY = function readGoaway(buffer, frame) {\n  if (buffer.length !== 8) {\n    // GOAWAY must have 8 bytes\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.last_stream = buffer.readUInt32BE(0) & 0x7fffffff;\n  frame.error = errorCodes[buffer.readUInt32BE(4)];\n\n  if (!frame.error) {\n    // Unknown error types are to be considered equivalent to INTERNAL ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n}; // [WINDOW_UPDATE](https://tools.ietf.org/html/rfc7540#section-6.9)\n// -----------------------------------------------------------------\n//\n// The WINDOW_UPDATE frame (type=0x8) is used to implement flow control.\n//\n// The WINDOW_UPDATE frame does not define any flags.\n\n\nframeTypes[0x8] = 'WINDOW_UPDATE';\nframeFlags.WINDOW_UPDATE = [];\ntypeSpecificAttributes.WINDOW_UPDATE = ['window_size']; // The payload of a WINDOW_UPDATE frame is a 32-bit value indicating the additional number of bytes\n// that the sender can transmit in addition to the existing flow control window. The legal range\n// for this field is 1 to 2^31 - 1 (0x7fffffff) bytes; the most significant bit of this value is\n// reserved.\n\nSerializer.WINDOW_UPDATE = function writeWindowUpdate(frame, buffers) {\n  var buffer = new Buffer(4);\n  var window_size = frame.window_size;\n  assert(0 < window_size && window_size <= 0x7fffffff, window_size);\n  buffer.writeUInt32BE(window_size, 0);\n  buffers.push(buffer);\n};\n\nDeserializer.WINDOW_UPDATE = function readWindowUpdate(buffer, frame) {\n  if (buffer.length !== WINDOW_UPDATE_PAYLOAD_SIZE) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.window_size = buffer.readUInt32BE(0) & 0x7fffffff;\n\n  if (frame.window_size === 0) {\n    return 'PROTOCOL_ERROR';\n  }\n}; // [CONTINUATION](https://tools.ietf.org/html/rfc7540#section-6.10)\n// ------------------------------------------------------------\n//\n// The CONTINUATION frame (type=0x9) is used to continue a sequence of header block fragments.\n//\n// The CONTINUATION frame defines the following flag:\n//\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame ends the sequence of header block fragments\n//   necessary to provide a complete set of headers.\n\n\nframeTypes[0x9] = 'CONTINUATION';\nframeFlags.CONTINUATION = ['RESERVED1', 'RESERVED2', 'END_HEADERS'];\ntypeSpecificAttributes.CONTINUATION = ['headers', 'data'];\n\nSerializer.CONTINUATION = function writeContinuation(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.CONTINUATION = function readContinuation(buffer, frame) {\n  frame.data = buffer;\n}; // [ALTSVC](https://tools.ietf.org/html/rfc7838#section-4)\n// ------------------------------------------------------------\n//\n// The ALTSVC frame (type=0xA) advertises the availability of an alternative service to the client.\n//\n// The ALTSVC frame does not define any flags.\n\n\nframeTypes[0xA] = 'ALTSVC';\nframeFlags.ALTSVC = []; //     0                   1                   2                   3\n//     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//    |         Origin-Len (16)       | Origin? (*)                 ...\n//    +-------------------------------+----------------+--------------+\n//    |                   Alt-Svc-Field-Value (*)                   ...\n//    +---------------------------------------------------------------+\n//\n// The ALTSVC frame contains the following fields:\n//\n// Origin-Len: An unsigned, 16-bit integer indicating the length, in\n//    octets, of the Origin field.\n//\n// Origin: An OPTIONAL sequence of characters containing ASCII\n//    serialisation of an origin ([RFC6454](https://tools.ietf.org/html/rfc6454),\n//    Section 6.2) that the alternate service is applicable to.\n//\n// Alt-Svc-Field-Value: A sequence of octets (length determined by\n//    subtracting the length of all preceding fields from the frame\n//    length) containing a value identical to the Alt-Svc field value\n//    defined in (Section 3)[https://tools.ietf.org/html/rfc7838#section-3]\n//    (ABNF production \"Alt-Svc\").\n\ntypeSpecificAttributes.ALTSVC = ['maxAge', 'port', 'protocolID', 'host', 'origin'];\n\nfunction istchar(c) {\n  return '!#$&\\'*+-.^_`|~1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.indexOf(c) > -1;\n}\n\nfunction hexencode(s) {\n  var t = '';\n\n  for (var i = 0; i < s.length; i++) {\n    if (!istchar(s[i])) {\n      t += '%';\n      t += new Buffer(s[i]).toString('hex');\n    } else {\n      t += s[i];\n    }\n  }\n\n  return t;\n}\n\nSerializer.ALTSVC = function writeAltSvc(frame, buffers) {\n  var buffer = new Buffer(2);\n  buffer.writeUInt16BE(frame.origin.length, 0);\n  buffers.push(buffer);\n  buffers.push(new Buffer(frame.origin, 'ascii'));\n  var fieldValue = hexencode(frame.protocolID) + '=\"' + frame.host + ':' + frame.port + '\"';\n\n  if (frame.maxAge !== 86400) {\n    // 86400 is the default\n    fieldValue += \"; ma=\" + frame.maxAge;\n  }\n\n  buffers.push(new Buffer(fieldValue, 'ascii'));\n};\n\nfunction stripquotes(s) {\n  var start = 0;\n  var end = s.length;\n\n  while (start < end && s[start] === '\"') {\n    start++;\n  }\n\n  while (end > start && s[end - 1] === '\"') {\n    end--;\n  }\n\n  if (start >= end) {\n    return \"\";\n  }\n\n  return s.substring(start, end);\n}\n\nfunction splitNameValue(nvpair) {\n  var eq = -1;\n  var inQuotes = false;\n\n  for (var i = 0; i < nvpair.length; i++) {\n    if (nvpair[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (inQuotes) {\n      continue;\n    }\n\n    if (nvpair[i] === '=') {\n      eq = i;\n      break;\n    }\n  }\n\n  if (eq === -1) {\n    return {\n      'name': nvpair,\n      'value': null\n    };\n  }\n\n  var name = stripquotes(nvpair.substring(0, eq).trim());\n  var value = stripquotes(nvpair.substring(eq + 1).trim());\n  return {\n    'name': name,\n    'value': value\n  };\n}\n\nfunction splitHeaderParameters(hv) {\n  return parseHeaderValue(hv, ';', splitNameValue);\n}\n\nfunction parseHeaderValue(hv, separator, callback) {\n  var start = 0;\n  var inQuotes = false;\n  var values = [];\n\n  for (var i = 0; i < hv.length; i++) {\n    if (hv[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (inQuotes) {\n      // Just skip this\n      continue;\n    }\n\n    if (hv[i] === separator) {\n      var newValue = hv.substring(start, i).trim();\n\n      if (newValue.length > 0) {\n        newValue = callback(newValue);\n        values.push(newValue);\n      }\n\n      start = i + 1;\n    }\n  }\n\n  var newValue = hv.substring(start).trim();\n\n  if (newValue.length > 0) {\n    newValue = callback(newValue);\n    values.push(newValue);\n  }\n\n  return values;\n}\n\nfunction rsplit(s, delim, count) {\n  var nsplits = 0;\n  var end = s.length;\n  var rval = [];\n\n  for (var i = s.length - 1; i >= 0; i--) {\n    if (s[i] === delim) {\n      var t = s.substring(i + 1, end);\n      end = i;\n      rval.unshift(t);\n      nsplits++;\n\n      if (nsplits === count) {\n        break;\n      }\n    }\n  }\n\n  if (end !== 0) {\n    rval.unshift(s.substring(0, end));\n  }\n\n  return rval;\n}\n\nfunction ishex(c) {\n  return '0123456789ABCDEFabcdef'.indexOf(c) > -1;\n}\n\nfunction unescape(s) {\n  var i = 0;\n  var t = '';\n\n  while (i < s.length) {\n    if (s[i] != '%' || !ishex(s[i + 1]) || !ishex(s[i + 2])) {\n      t += s[i];\n    } else {\n      ++i;\n      var hexvalue = '';\n\n      if (i < s.length) {\n        hexvalue += s[i];\n        ++i;\n      }\n\n      if (i < s.length) {\n        hexvalue += s[i];\n      }\n\n      if (hexvalue.length > 0) {\n        t += new Buffer(hexvalue, 'hex').toString();\n      } else {\n        t += '%';\n      }\n    }\n\n    ++i;\n  }\n\n  return t;\n}\n\nDeserializer.ALTSVC = function readAltSvc(buffer, frame) {\n  if (buffer.length < 2) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var originLength = buffer.readUInt16BE(0);\n\n  if (buffer.length - 2 < originLength) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.origin = buffer.toString('ascii', 2, 2 + originLength);\n  var fieldValue = buffer.toString('ascii', 2 + originLength);\n  var values = parseHeaderValue(fieldValue, ',', splitHeaderParameters);\n\n  if (values.length > 1) {// TODO - warn that we only use one here\n  }\n\n  if (values.length === 0) {\n    // Well that's a malformed frame. Just ignore it.\n    return;\n  }\n\n  var chosenAltSvc = values[0];\n  frame.maxAge = 86400; // Default\n\n  for (var i = 0; i < chosenAltSvc.length; i++) {\n    if (i === 0) {\n      // This corresponds to the protocolID=\"<host>:<port>\" item\n      frame.protocolID = unescape(chosenAltSvc[i].name);\n      var hostport = rsplit(chosenAltSvc[i].value, ':', 1);\n      frame.host = hostport[0];\n      frame.port = parseInt(hostport[1], 10);\n    } else if (chosenAltSvc[i].name == 'ma') {\n      frame.maxAge = parseInt(chosenAltSvc[i].value, 10);\n    } // Otherwise, we just ignore this\n\n  }\n}; // BLOCKED\n// ------------------------------------------------------------\n//\n// The BLOCKED frame (type=0xB) indicates that the sender is unable to send data\n// due to a closed flow control window.\n//\n// The BLOCKED frame does not define any flags and contains no payload.\n\n\nframeTypes[0xB] = 'BLOCKED';\nframeFlags.BLOCKED = [];\ntypeSpecificAttributes.BLOCKED = [];\n\nSerializer.BLOCKED = function writeBlocked(frame, buffers) {};\n\nDeserializer.BLOCKED = function readBlocked(buffer, frame) {}; // [Error Codes](https://tools.ietf.org/html/rfc7540#section-7)\n// ------------------------------------------------------------\n\n\nvar errorCodes = ['NO_ERROR', 'PROTOCOL_ERROR', 'INTERNAL_ERROR', 'FLOW_CONTROL_ERROR', 'SETTINGS_TIMEOUT', 'STREAM_CLOSED', 'FRAME_SIZE_ERROR', 'REFUSED_STREAM', 'CANCEL', 'COMPRESSION_ERROR', 'CONNECT_ERROR', 'ENHANCE_YOUR_CALM', 'INADEQUATE_SECURITY', 'HTTP_1_1_REQUIRED']; // Logging\n// -------\n// [Bunyan serializers](https://github.com/trentm/node-bunyan#serializers) to improve logging output\n// for debug messages emitted in this component.\n\nexports.serializers = {}; // * `frame` serializer: it transforms data attributes from Buffers to hex strings and filters out\n//   flags that are not present.\n\nvar frameCounter = 0;\n\nexports.serializers.frame = function (frame) {\n  if (!frame) {\n    return null;\n  }\n\n  if ('id' in frame) {\n    return frame.id;\n  }\n\n  frame.id = frameCounter;\n  frameCounter += 1;\n  var logEntry = {\n    id: frame.id\n  };\n  genericAttributes.concat(typeSpecificAttributes[frame.type]).forEach(function (name) {\n    logEntry[name] = frame[name];\n  });\n\n  if (frame.data instanceof Buffer) {\n    if (logEntry.data.length > 50) {\n      logEntry.data = frame.data.slice(0, 47).toString('hex') + '...';\n    } else {\n      logEntry.data = frame.data.toString('hex');\n    }\n\n    if (!('length' in logEntry)) {\n      logEntry.length = frame.data.length;\n    }\n  }\n\n  if (frame.promised_stream instanceof Object) {\n    logEntry.promised_stream = 'stream-' + frame.promised_stream.id;\n  }\n\n  logEntry.flags = Object.keys(frame.flags || {}).filter(function (name) {\n    return frame.flags[name] === true;\n  });\n  return logEntry;\n}; // * `data` serializer: it simply transforms a buffer to a hex string.\n\n\nexports.serializers.data = function (data) {\n  return data.toString('hex');\n};","map":{"version":3,"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/http2/lib/protocol/framer.js"],"names":["assert","require","Transform","exports","Serializer","Deserializer","logData","Boolean","process","env","HTTP2_LOG_DATA","MAX_PAYLOAD_SIZE","WINDOW_UPDATE_PAYLOAD_SIZE","log","_log","child","component","call","objectMode","prototype","Object","create","constructor","value","_transform","frame","encoding","done","trace","type","buffers","length","commonHeader","i","data","push","role","_role","_next","COMMON_HEADER_SIZE","size","_cursor","_buffer","Buffer","_waitingForHeader","_frame","chunk","cursor","toCopy","Math","min","copy","payloadSize","emit","error","frameTypes","frameFlags","genericAttributes","typeSpecificAttributes","writeCommonHeader","headerBuffer","writeUInt8","writeUInt16BE","typeId","indexOf","flagByte","flag","flags","position","stream","writeUInt32BE","unshift","readCommonHeader","buffer","totallyWastedByte","readUInt8","readUInt16BE","definedFlags","readUInt32BE","DATA","writeData","readData","dataOffset","paddingLength","PADDED","slice","HEADERS","writeHeadersPriority","PRIORITY","priorityDependency","exclusiveDependency","priorityWeight","readHeadersPriority","minFrameLength","dependencyData","writePriority","readPriority","RST_STREAM","writeRstStream","code","errorCodes","readRstStream","SETTINGS","writeSettings","settings","settingsLeft","keys","definedSettings","forEach","setting","id","name","splice","join","readSettings","ACK","PUSH_PROMISE","writePushPromise","promised_stream","readPushPromise","PING","writePing","readPing","GOAWAY","writeGoaway","last_stream","readGoaway","WINDOW_UPDATE","writeWindowUpdate","window_size","readWindowUpdate","CONTINUATION","writeContinuation","readContinuation","ALTSVC","istchar","c","hexencode","s","t","toString","writeAltSvc","origin","fieldValue","protocolID","host","port","maxAge","stripquotes","start","end","substring","splitNameValue","nvpair","eq","inQuotes","trim","splitHeaderParameters","hv","parseHeaderValue","separator","callback","values","newValue","rsplit","delim","count","nsplits","rval","ishex","unescape","hexvalue","readAltSvc","originLength","chosenAltSvc","hostport","parseInt","BLOCKED","writeBlocked","readBlocked","serializers","frameCounter","logEntry","concat","filter"],"mappings":"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","sourcesContent":["// The framer consists of two [Transform Stream][1] subclasses that operate in [object mode][2]:\n// the Serializer and the Deserializer\n// [1]: https://nodejs.org/api/stream.html#stream_class_stream_transform\n// [2]: https://nodejs.org/api/stream.html#stream_new_stream_readable_options\nvar assert = require('assert');\n\nvar Transform = require('stream').Transform;\n\nexports.Serializer = Serializer;\nexports.Deserializer = Deserializer;\n\nvar logData = Boolean(process.env.HTTP2_LOG_DATA);\n\nvar MAX_PAYLOAD_SIZE = 16384;\nvar WINDOW_UPDATE_PAYLOAD_SIZE = 4;\n\n// Serializer\n// ----------\n//\n//     Frame Objects\n//     * * * * * * * --+---------------------------\n//                     |                          |\n//                     v                          v           Buffers\n//      [] -----> Payload Ser. --[buffers]--> Header Ser. --> * * * *\n//     empty      adds payload                adds header\n//     array        buffers                     buffer\n\nfunction Serializer(log) {\n  this._log = log.child({ component: 'serializer' });\n  Transform.call(this, { objectMode: true });\n}\nSerializer.prototype = Object.create(Transform.prototype, { constructor: { value: Serializer } });\n\n// When there's an incoming frame object, it first generates the frame type specific part of the\n// frame (payload), and then then adds the header part which holds fields that are common to all\n// frame types (like the length of the payload).\nSerializer.prototype._transform = function _transform(frame, encoding, done) {\n  this._log.trace({ frame: frame }, 'Outgoing frame');\n\n  assert(frame.type in Serializer, 'Unknown frame type: ' + frame.type);\n\n  var buffers = [];\n  Serializer[frame.type](frame, buffers);\n  var length = Serializer.commonHeader(frame, buffers);\n\n  assert(length <= MAX_PAYLOAD_SIZE, 'Frame too large!');\n\n  for (var i = 0; i < buffers.length; i++) {\n    if (logData) {\n      this._log.trace({ data: buffers[i] }, 'Outgoing data');\n    }\n    this.push(buffers[i]);\n  }\n\n  done();\n};\n\n// Deserializer\n// ------------\n//\n//     Buffers\n//     * * * * --------+-------------------------\n//                     |                        |\n//                     v                        v           Frame Objects\n//      {} -----> Header Des. --{frame}--> Payload Des. --> * * * * * * *\n//     empty      adds parsed              adds parsed\n//     object  header properties        payload properties\n\nfunction Deserializer(log, role) {\n  this._role = role;\n  this._log = log.child({ component: 'deserializer' });\n  Transform.call(this, { objectMode: true });\n  this._next(COMMON_HEADER_SIZE);\n}\nDeserializer.prototype = Object.create(Transform.prototype, { constructor: { value: Deserializer } });\n\n// The Deserializer is stateful, and it's two main alternating states are: *waiting for header* and\n// *waiting for payload*. The state is stored in the boolean property `_waitingForHeader`.\n//\n// When entering a new state, a `_buffer` is created that will hold the accumulated data (header or\n// payload). The `_cursor` is used to track the progress.\nDeserializer.prototype._next = function(size) {\n  this._cursor = 0;\n  this._buffer = new Buffer(size);\n  this._waitingForHeader = !this._waitingForHeader;\n  if (this._waitingForHeader) {\n    this._frame = {};\n  }\n};\n\n// Parsing an incoming buffer is an iterative process because it can hold multiple frames if it's\n// large enough. A `cursor` is used to track the progress in parsing the incoming `chunk`.\nDeserializer.prototype._transform = function _transform(chunk, encoding, done) {\n  var cursor = 0;\n\n  if (logData) {\n    this._log.trace({ data: chunk }, 'Incoming data');\n  }\n\n  while(cursor < chunk.length) {\n    // The content of an incoming buffer is first copied to `_buffer`. If it can't hold the full\n    // chunk, then only a part of it is copied.\n    var toCopy = Math.min(chunk.length - cursor, this._buffer.length - this._cursor);\n    chunk.copy(this._buffer, this._cursor, cursor, cursor + toCopy);\n    this._cursor += toCopy;\n    cursor += toCopy;\n\n    // When `_buffer` is full, it's content gets parsed either as header or payload depending on\n    // the actual state.\n\n    // If it's header then the parsed data is stored in a temporary variable and then the\n    // deserializer waits for the specified length payload.\n    if ((this._cursor === this._buffer.length) && this._waitingForHeader) {\n      var payloadSize = Deserializer.commonHeader(this._buffer, this._frame);\n      if (payloadSize <= MAX_PAYLOAD_SIZE) {\n        this._next(payloadSize);\n      } else {\n        this.emit('error', 'FRAME_SIZE_ERROR');\n        return;\n      }\n    }\n\n    // If it's payload then the the frame object is finalized and then gets pushed out.\n    // Unknown frame types are ignored.\n    //\n    // Note: If we just finished the parsing of a header and the payload length is 0, this branch\n    // will also run.\n    if ((this._cursor === this._buffer.length) && !this._waitingForHeader) {\n      if (this._frame.type) {\n        var error = Deserializer[this._frame.type](this._buffer, this._frame, this._role);\n        if (error) {\n          this._log.error('Incoming frame parsing error: ' + error);\n          this.emit('error', error);\n        } else {\n          this._log.trace({ frame: this._frame }, 'Incoming frame');\n          this.push(this._frame);\n        }\n      } else {\n        this._log.error('Unknown type incoming frame');\n        // Ignore it other than logging\n      }\n      this._next(COMMON_HEADER_SIZE);\n    }\n  }\n\n  done();\n};\n\n// [Frame Header](https://tools.ietf.org/html/rfc7540#section-4.1)\n// --------------------------------------------------------------\n//\n// HTTP/2 frames share a common base format consisting of a 9-byte header followed by 0 to 2^24 - 1\n// bytes of data.\n//\n// Additional size limits can be set by specific application uses. HTTP limits the frame size to\n// 16,384 octets by default, though this can be increased by a receiver.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                 Length (24)                   |\n//     +---------------+---------------+---------------+\n//     |   Type (8)    |   Flags (8)   |\n//     +-+-----------------------------+---------------+---------------+\n//     |R|                 Stream Identifier (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                     Frame Data (0...)                       ...\n//     +---------------------------------------------------------------+\n//\n// The fields of the frame header are defined as:\n//\n// * Length:\n//   The length of the frame data expressed as an unsigned 24-bit integer. The 9 bytes of the frame\n//   header are not included in this value.\n//\n// * Type:\n//   The 8-bit type of the frame. The frame type determines how the remainder of the frame header\n//   and data are interpreted. Implementations MUST ignore unsupported and unrecognized frame types.\n//\n// * Flags:\n//   An 8-bit field reserved for frame-type specific boolean flags.\n//\n//   Flags are assigned semantics specific to the indicated frame type. Flags that have no defined\n//   semantics for a particular frame type MUST be ignored, and MUST be left unset (0) when sending.\n//\n// * R:\n//   A reserved 1-bit field. The semantics of this bit are undefined and the bit MUST remain unset\n//   (0) when sending and MUST be ignored when receiving.\n//\n// * Stream Identifier:\n//   A 31-bit stream identifier. The value 0 is reserved for frames that are associated with the\n//   connection as a whole as opposed to an individual stream.\n//\n// The structure and content of the remaining frame data is dependent entirely on the frame type.\n\nvar COMMON_HEADER_SIZE = 9;\n\nvar frameTypes = [];\n\nvar frameFlags = {};\n\nvar genericAttributes = ['type', 'flags', 'stream'];\n\nvar typeSpecificAttributes = {};\n\nSerializer.commonHeader = function writeCommonHeader(frame, buffers) {\n  var headerBuffer = new Buffer(COMMON_HEADER_SIZE);\n\n  var size = 0;\n  for (var i = 0; i < buffers.length; i++) {\n    size += buffers[i].length;\n  }\n  headerBuffer.writeUInt8(0, 0);\n  headerBuffer.writeUInt16BE(size, 1);\n\n  var typeId = frameTypes.indexOf(frame.type);  // If we are here then the type is valid for sure\n  headerBuffer.writeUInt8(typeId, 3);\n\n  var flagByte = 0;\n  for (var flag in frame.flags) {\n    var position = frameFlags[frame.type].indexOf(flag);\n    assert(position !== -1, 'Unknown flag for frame type ' + frame.type + ': ' + flag);\n    if (frame.flags[flag]) {\n      flagByte |= (1 << position);\n    }\n  }\n  headerBuffer.writeUInt8(flagByte, 4);\n\n  assert((0 <= frame.stream) && (frame.stream < 0x7fffffff), frame.stream);\n  headerBuffer.writeUInt32BE(frame.stream || 0, 5);\n\n  buffers.unshift(headerBuffer);\n\n  return size;\n};\n\nDeserializer.commonHeader = function readCommonHeader(buffer, frame) {\n  if (buffer.length < 9) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var totallyWastedByte = buffer.readUInt8(0);\n  var length = buffer.readUInt16BE(1);\n  // We do this just for sanity checking later on, to make sure no one sent us a\n  // frame that's super large.\n  length += totallyWastedByte << 16;\n\n  frame.type = frameTypes[buffer.readUInt8(3)];\n  if (!frame.type) {\n    // We are required to ignore unknown frame types\n    return length;\n  }\n\n  frame.flags = {};\n  var flagByte = buffer.readUInt8(4);\n  var definedFlags = frameFlags[frame.type];\n  for (var i = 0; i < definedFlags.length; i++) {\n    frame.flags[definedFlags[i]] = Boolean(flagByte & (1 << i));\n  }\n\n  frame.stream = buffer.readUInt32BE(5) & 0x7fffffff;\n\n  return length;\n};\n\n// Frame types\n// ===========\n\n// Every frame type is registered in the following places:\n//\n// * `frameTypes`: a register of frame type codes (used by `commonHeader()`)\n// * `frameFlags`: a register of valid flags for frame types (used by `commonHeader()`)\n// * `typeSpecificAttributes`: a register of frame specific frame object attributes (used by\n//   logging code and also serves as documentation for frame objects)\n\n// [DATA Frames](https://tools.ietf.org/html/rfc7540#section-6.1)\n// ------------------------------------------------------------\n//\n// DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a\n// stream.\n//\n// The DATA frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n\nframeTypes[0x0] = 'DATA';\n\nframeFlags.DATA = ['END_STREAM', 'RESERVED2', 'RESERVED4', 'PADDED'];\n\ntypeSpecificAttributes.DATA = ['data'];\n\nSerializer.DATA = function writeData(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.DATA = function readData(buffer, frame) {\n  var dataOffset = 0;\n  var paddingLength = 0;\n  if (frame.flags.PADDED) {\n    if (buffer.length < 1) {\n      // We must have at least one byte for padding control, but we don't. Bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n    paddingLength = (buffer.readUInt8(dataOffset) & 0xff);\n    dataOffset = 1;\n  }\n\n  if (paddingLength) {\n    if (paddingLength >= (buffer.length - 1)) {\n      // We don't have enough room for the padding advertised - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n};\n\n// [HEADERS](https://tools.ietf.org/html/rfc7540#section-6.2)\n// --------------------------------------------------------------\n//\n// The HEADERS frame (type=0x1) allows the sender to create a stream.\n//\n// The HEADERS frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame contains the entire payload necessary to provide\n//   a complete set of headers.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n// * PRIORITY (0x20):\n//   Bit 6 being set indicates that the Exlusive Flag (E), Stream Dependency, and Weight fields are\n//   present.\n\nframeTypes[0x1] = 'HEADERS';\n\nframeFlags.HEADERS = ['END_STREAM', 'RESERVED2', 'END_HEADERS', 'PADDED', 'RESERVED5', 'PRIORITY'];\n\ntypeSpecificAttributes.HEADERS = ['priorityDependency', 'priorityWeight', 'exclusiveDependency', 'headers', 'data'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+---------------+-------------------------------+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+-----------------------------------------------+\n//     |                   Header Block Fragment (*)                 ...\n//     +---------------------------------------------------------------+\n//     |                           Padding (*)                       ...\n//     +---------------------------------------------------------------+\n//\n// The payload of a HEADERS frame contains a Headers Block\n\nSerializer.HEADERS = function writeHeadersPriority(frame, buffers) {\n  if (frame.flags.PRIORITY) {\n    var buffer = new Buffer(5);\n    assert((0 <= frame.priorityDependency) && (frame.priorityDependency <= 0x7fffffff), frame.priorityDependency);\n    buffer.writeUInt32BE(frame.priorityDependency, 0);\n    if (frame.exclusiveDependency) {\n      buffer[0] |= 0x80;\n    }\n    assert((0 <= frame.priorityWeight) && (frame.priorityWeight <= 0xff), frame.priorityWeight);\n    buffer.writeUInt8(frame.priorityWeight, 4);\n    buffers.push(buffer);\n  }\n  buffers.push(frame.data);\n};\n\nDeserializer.HEADERS = function readHeadersPriority(buffer, frame) {\n  var minFrameLength = 0;\n  if (frame.flags.PADDED) {\n    minFrameLength += 1;\n  }\n  if (frame.flags.PRIORITY) {\n    minFrameLength += 5;\n  }\n  if (buffer.length < minFrameLength) {\n    // Peer didn't send enough data - bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dataOffset = 0;\n  var paddingLength = 0;\n  if (frame.flags.PADDED) {\n    paddingLength = (buffer.readUInt8(dataOffset) & 0xff);\n    dataOffset = 1;\n  }\n\n  if (frame.flags.PRIORITY) {\n    var dependencyData = new Buffer(4);\n    buffer.copy(dependencyData, 0, dataOffset, dataOffset + 4);\n    dataOffset += 4;\n    frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n    dependencyData[0] &= 0x7f;\n    frame.priorityDependency = dependencyData.readUInt32BE(0);\n    frame.priorityWeight = buffer.readUInt8(dataOffset);\n    dataOffset += 1;\n  }\n\n  if (paddingLength) {\n    if ((buffer.length - dataOffset) < paddingLength) {\n      // Not enough data left to satisfy the advertised padding - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n};\n\n// [PRIORITY](https://tools.ietf.org/html/rfc7540#section-6.3)\n// -------------------------------------------------------\n//\n// The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream.\n//\n// The PRIORITY frame does not define any flags.\n\nframeTypes[0x2] = 'PRIORITY';\n\nframeFlags.PRIORITY = [];\n\ntypeSpecificAttributes.PRIORITY = ['priorityDependency', 'priorityWeight', 'exclusiveDependency'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+\n//\n// The payload of a PRIORITY frame contains an exclusive bit, a 31-bit dependency, and an 8-bit weight\n\nSerializer.PRIORITY = function writePriority(frame, buffers) {\n  var buffer = new Buffer(5);\n  assert((0 <= frame.priorityDependency) && (frame.priorityDependency <= 0x7fffffff), frame.priorityDependency);\n  buffer.writeUInt32BE(frame.priorityDependency, 0);\n  if (frame.exclusiveDependency) {\n    buffer[0] |= 0x80;\n  }\n  assert((0 <= frame.priorityWeight) && (frame.priorityWeight <= 0xff), frame.priorityWeight);\n  buffer.writeUInt8(frame.priorityWeight, 4);\n\n  buffers.push(buffer);\n};\n\nDeserializer.PRIORITY = function readPriority(buffer, frame) {\n  if (buffer.length < 5) {\n    // PRIORITY frames are 5 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n  var dependencyData = new Buffer(4);\n  buffer.copy(dependencyData, 0, 0, 4);\n  frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n  dependencyData[0] &= 0x7f;\n  frame.priorityDependency = dependencyData.readUInt32BE(0);\n  frame.priorityWeight = buffer.readUInt8(4);\n};\n\n// [RST_STREAM](https://tools.ietf.org/html/rfc7540#section-6.4)\n// -----------------------------------------------------------\n//\n// The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.\n//\n// No type-flags are defined.\n\nframeTypes[0x3] = 'RST_STREAM';\n\nframeFlags.RST_STREAM = [];\n\ntypeSpecificAttributes.RST_STREAM = ['error'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                         Error Code (32)                       |\n//     +---------------------------------------------------------------+\n//\n// The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error\n// code (see Error Codes). The error code indicates why the stream is being terminated.\n\nSerializer.RST_STREAM = function writeRstStream(frame, buffers) {\n  var buffer = new Buffer(4);\n  var code = errorCodes.indexOf(frame.error);\n  assert((0 <= code) && (code <= 0xffffffff), code);\n  buffer.writeUInt32BE(code, 0);\n  buffers.push(buffer);\n};\n\nDeserializer.RST_STREAM = function readRstStream(buffer, frame) {\n  if (buffer.length < 4) {\n    // RST_STREAM is 4 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.error = errorCodes[buffer.readUInt32BE(0)];\n  if (!frame.error) {\n    // Unknown error codes are considered equivalent to INTERNAL_ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n};\n\n// [SETTINGS](https://tools.ietf.org/html/rfc7540#section-6.5)\n// -------------------------------------------------------\n//\n// The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints\n// communicate.\n//\n// The SETTINGS frame defines the following flag:\n\n// * ACK (0x1):\n//   Bit 1 being set indicates that this frame acknowledges receipt and application of the peer's\n//   SETTINGS frame.\nframeTypes[0x4] = 'SETTINGS';\n\nframeFlags.SETTINGS = ['ACK'];\n\ntypeSpecificAttributes.SETTINGS = ['settings'];\n\n// The payload of a SETTINGS frame consists of zero or more settings. Each setting consists of a\n// 16-bit identifier, and an unsigned 32-bit value.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |         Identifier(16)          |        Value (32)           |\n//     +-----------------+---------------------------------------------+\n//     ...Value                          |\n//     +---------------------------------+\n//\n// Each setting in a SETTINGS frame replaces the existing value for that setting.  Settings are\n// processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to\n// maintain any state other than the current value of settings.  Therefore, the value of a setting\n// is the last value that is seen by a receiver. This permits the inclusion of the same settings\n// multiple times in the same SETTINGS frame, though doing so does nothing other than waste\n// connection capacity.\n\nSerializer.SETTINGS = function writeSettings(frame, buffers) {\n  var settings = [], settingsLeft = Object.keys(frame.settings);\n  definedSettings.forEach(function(setting, id) {\n    if (setting.name in frame.settings) {\n      settingsLeft.splice(settingsLeft.indexOf(setting.name), 1);\n      var value = frame.settings[setting.name];\n      settings.push({ id: id, value: setting.flag ? Boolean(value) : value });\n    }\n  });\n  assert(settingsLeft.length === 0, 'Unknown settings: ' + settingsLeft.join(', '));\n\n  var buffer = new Buffer(settings.length * 6);\n  for (var i = 0; i < settings.length; i++) {\n    buffer.writeUInt16BE(settings[i].id & 0xffff, i*6);\n    buffer.writeUInt32BE(settings[i].value, i*6 + 2);\n  }\n\n  buffers.push(buffer);\n};\n\nDeserializer.SETTINGS = function readSettings(buffer, frame, role) {\n  frame.settings = {};\n\n  // Receipt of a SETTINGS frame with the ACK flag set and a length\n  // field value other than 0 MUST be treated as a connection error\n  // (Section 5.4.1) of type FRAME_SIZE_ERROR.\n  if(frame.flags.ACK && buffer.length != 0) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  if (buffer.length % 6 !== 0) {\n    return 'PROTOCOL_ERROR';\n  }\n  for (var i = 0; i < buffer.length / 6; i++) {\n    var id = buffer.readUInt16BE(i*6) & 0xffff;\n    var setting = definedSettings[id];\n    if (setting) {\n      if (role == 'CLIENT' && setting.name == 'SETTINGS_ENABLE_PUSH') {\n        return 'SETTINGS frame on client got SETTINGS_ENABLE_PUSH';\n      }\n      var value = buffer.readUInt32BE(i*6 + 2);\n      frame.settings[setting.name] = setting.flag ? Boolean(value & 0x1) : value;\n    }\n  }\n};\n\n// The following settings are defined:\nvar definedSettings = [];\n\n// * SETTINGS_HEADER_TABLE_SIZE (1):\n//   Allows the sender to inform the remote endpoint of the size of the header compression table\n//   used to decode header blocks.\ndefinedSettings[1] = { name: 'SETTINGS_HEADER_TABLE_SIZE', flag: false };\n\n// * SETTINGS_ENABLE_PUSH (2):\n//   This setting can be use to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame\n//   if it receives this setting set to a value of 0. The default value is 1, which indicates that\n//   push is permitted.\ndefinedSettings[2] = { name: 'SETTINGS_ENABLE_PUSH', flag: true };\n\n// * SETTINGS_MAX_CONCURRENT_STREAMS (3):\n//   indicates the maximum number of concurrent streams that the sender will allow.\ndefinedSettings[3] = { name: 'SETTINGS_MAX_CONCURRENT_STREAMS', flag: false };\n\n// * SETTINGS_INITIAL_WINDOW_SIZE (4):\n//   indicates the sender's initial stream window size (in bytes) for new streams.\ndefinedSettings[4] = { name: 'SETTINGS_INITIAL_WINDOW_SIZE', flag: false };\n\n// * SETTINGS_MAX_FRAME_SIZE (5):\n//   indicates the maximum size of a frame the receiver will allow.\ndefinedSettings[5] = { name: 'SETTINGS_MAX_FRAME_SIZE', flag: false };\n\n// [PUSH_PROMISE](https://tools.ietf.org/html/rfc7540#section-6.6)\n// ---------------------------------------------------------------\n//\n// The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the\n// sender intends to initiate.\n//\n// The PUSH_PROMISE frame defines the following flags:\n//\n// * END_PUSH_PROMISE (0x4):\n//   The END_PUSH_PROMISE bit indicates that this frame contains the entire payload necessary to\n//   provide a complete set of headers.\n\nframeTypes[0x5] = 'PUSH_PROMISE';\n\nframeFlags.PUSH_PROMISE = ['RESERVED1', 'RESERVED2', 'END_PUSH_PROMISE', 'PADDED'];\n\ntypeSpecificAttributes.PUSH_PROMISE = ['promised_stream', 'headers', 'data'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+-----------------------------------------------+\n//     |X|                Promised-Stream-ID (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                 Header Block Fragment (*)                   ...\n//     +---------------------------------------------------------------+\n//     |                         Padding (*)                         ...\n//     +---------------------------------------------------------------+\n//\n// The PUSH_PROMISE frame includes the unsigned 31-bit identifier of\n// the stream the endpoint plans to create along with a minimal set of headers that provide\n// additional context for the stream.\n\nSerializer.PUSH_PROMISE = function writePushPromise(frame, buffers) {\n  var buffer = new Buffer(4);\n\n  var promised_stream = frame.promised_stream;\n  assert((0 <= promised_stream) && (promised_stream <= 0x7fffffff), promised_stream);\n  buffer.writeUInt32BE(promised_stream, 0);\n\n  buffers.push(buffer);\n  buffers.push(frame.data);\n};\n\nDeserializer.PUSH_PROMISE = function readPushPromise(buffer, frame) {\n  if (buffer.length < 4) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  var dataOffset = 0;\n  var paddingLength = 0;\n  if (frame.flags.PADDED) {\n    if (buffer.length < 5) {\n      return 'FRAME_SIZE_ERROR';\n    }\n    paddingLength = (buffer.readUInt8(dataOffset) & 0xff);\n    dataOffset = 1;\n  }\n  frame.promised_stream = buffer.readUInt32BE(dataOffset) & 0x7fffffff;\n  dataOffset += 4;\n  if (paddingLength) {\n    if ((buffer.length - dataOffset) < paddingLength) {\n      return 'FRAME_SIZE_ERROR';\n    }\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n};\n\n// [PING](https://tools.ietf.org/html/rfc7540#section-6.7)\n// -----------------------------------------------\n//\n// The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the\n// sender, as well as determining whether an idle connection is still functional.\n//\n// The PING frame defines one type-specific flag:\n//\n// * ACK (0x1):\n//   Bit 1 being set indicates that this PING frame is a PING response.\n\nframeTypes[0x6] = 'PING';\n\nframeFlags.PING = ['ACK'];\n\ntypeSpecificAttributes.PING = ['data'];\n\n// In addition to the frame header, PING frames MUST contain 8 additional octets of opaque data.\n\nSerializer.PING = function writePing(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.PING = function readPing(buffer, frame) {\n  if (buffer.length !== 8) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.data = buffer;\n};\n\n// [GOAWAY](https://tools.ietf.org/html/rfc7540#section-6.8)\n// ---------------------------------------------------\n//\n// The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this connection.\n//\n// The GOAWAY frame does not define any flags.\n\nframeTypes[0x7] = 'GOAWAY';\n\nframeFlags.GOAWAY = [];\n\ntypeSpecificAttributes.GOAWAY = ['last_stream', 'error'];\n\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |X|                  Last-Stream-ID (31)                        |\n//     +-+-------------------------------------------------------------+\n//     |                      Error Code (32)                          |\n//     +---------------------------------------------------------------+\n//\n// The last stream identifier in the GOAWAY frame contains the highest numbered stream identifier\n// for which the sender of the GOAWAY frame has received frames on and might have taken some action\n// on.\n//\n// The GOAWAY frame also contains a 32-bit error code (see Error Codes) that contains the reason for\n// closing the connection.\n\nSerializer.GOAWAY = function writeGoaway(frame, buffers) {\n  var buffer = new Buffer(8);\n\n  var last_stream = frame.last_stream;\n  assert((0 <= last_stream) && (last_stream <= 0x7fffffff), last_stream);\n  buffer.writeUInt32BE(last_stream, 0);\n\n  var code = errorCodes.indexOf(frame.error);\n  assert((0 <= code) && (code <= 0xffffffff), code);\n  buffer.writeUInt32BE(code, 4);\n\n  buffers.push(buffer);\n};\n\nDeserializer.GOAWAY = function readGoaway(buffer, frame) {\n  if (buffer.length !== 8) {\n    // GOAWAY must have 8 bytes\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.last_stream = buffer.readUInt32BE(0) & 0x7fffffff;\n  frame.error = errorCodes[buffer.readUInt32BE(4)];\n  if (!frame.error) {\n    // Unknown error types are to be considered equivalent to INTERNAL ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n};\n\n// [WINDOW_UPDATE](https://tools.ietf.org/html/rfc7540#section-6.9)\n// -----------------------------------------------------------------\n//\n// The WINDOW_UPDATE frame (type=0x8) is used to implement flow control.\n//\n// The WINDOW_UPDATE frame does not define any flags.\n\nframeTypes[0x8] = 'WINDOW_UPDATE';\n\nframeFlags.WINDOW_UPDATE = [];\n\ntypeSpecificAttributes.WINDOW_UPDATE = ['window_size'];\n\n// The payload of a WINDOW_UPDATE frame is a 32-bit value indicating the additional number of bytes\n// that the sender can transmit in addition to the existing flow control window. The legal range\n// for this field is 1 to 2^31 - 1 (0x7fffffff) bytes; the most significant bit of this value is\n// reserved.\n\nSerializer.WINDOW_UPDATE = function writeWindowUpdate(frame, buffers) {\n  var buffer = new Buffer(4);\n\n  var window_size = frame.window_size;\n  assert((0 < window_size) && (window_size <= 0x7fffffff), window_size);\n  buffer.writeUInt32BE(window_size, 0);\n\n  buffers.push(buffer);\n};\n\nDeserializer.WINDOW_UPDATE = function readWindowUpdate(buffer, frame) {\n  if (buffer.length !== WINDOW_UPDATE_PAYLOAD_SIZE) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.window_size = buffer.readUInt32BE(0) & 0x7fffffff;\n  if (frame.window_size === 0) {\n    return 'PROTOCOL_ERROR';\n  }\n};\n\n// [CONTINUATION](https://tools.ietf.org/html/rfc7540#section-6.10)\n// ------------------------------------------------------------\n//\n// The CONTINUATION frame (type=0x9) is used to continue a sequence of header block fragments.\n//\n// The CONTINUATION frame defines the following flag:\n//\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame ends the sequence of header block fragments\n//   necessary to provide a complete set of headers.\n\nframeTypes[0x9] = 'CONTINUATION';\n\nframeFlags.CONTINUATION = ['RESERVED1', 'RESERVED2', 'END_HEADERS'];\n\ntypeSpecificAttributes.CONTINUATION = ['headers', 'data'];\n\nSerializer.CONTINUATION = function writeContinuation(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.CONTINUATION = function readContinuation(buffer, frame) {\n  frame.data = buffer;\n};\n\n// [ALTSVC](https://tools.ietf.org/html/rfc7838#section-4)\n// ------------------------------------------------------------\n//\n// The ALTSVC frame (type=0xA) advertises the availability of an alternative service to the client.\n//\n// The ALTSVC frame does not define any flags.\n\nframeTypes[0xA] = 'ALTSVC';\n\nframeFlags.ALTSVC = [];\n\n//     0                   1                   2                   3\n//     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//    |         Origin-Len (16)       | Origin? (*)                 ...\n//    +-------------------------------+----------------+--------------+\n//    |                   Alt-Svc-Field-Value (*)                   ...\n//    +---------------------------------------------------------------+\n//\n// The ALTSVC frame contains the following fields:\n//\n// Origin-Len: An unsigned, 16-bit integer indicating the length, in\n//    octets, of the Origin field.\n//\n// Origin: An OPTIONAL sequence of characters containing ASCII\n//    serialisation of an origin ([RFC6454](https://tools.ietf.org/html/rfc6454),\n//    Section 6.2) that the alternate service is applicable to.\n//\n// Alt-Svc-Field-Value: A sequence of octets (length determined by\n//    subtracting the length of all preceding fields from the frame\n//    length) containing a value identical to the Alt-Svc field value\n//    defined in (Section 3)[https://tools.ietf.org/html/rfc7838#section-3]\n//    (ABNF production \"Alt-Svc\").\n\ntypeSpecificAttributes.ALTSVC = ['maxAge', 'port', 'protocolID', 'host',\n                                 'origin'];\n\nfunction istchar(c) {\n  return ('!#$&\\'*+-.^_`|~1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.indexOf(c) > -1);\n}\n\nfunction hexencode(s) {\n  var t = '';\n  for (var i = 0; i < s.length; i++) {\n    if (!istchar(s[i])) {\n      t += '%';\n      t += new Buffer(s[i]).toString('hex');\n    } else {\n      t += s[i];\n    }\n  }\n  return t;\n}\n\nSerializer.ALTSVC = function writeAltSvc(frame, buffers) {\n  var buffer = new Buffer(2);\n  buffer.writeUInt16BE(frame.origin.length, 0);\n  buffers.push(buffer);\n  buffers.push(new Buffer(frame.origin, 'ascii'));\n\n  var fieldValue = hexencode(frame.protocolID) + '=\"' + frame.host + ':' + frame.port + '\"';\n  if (frame.maxAge !== 86400) { // 86400 is the default\n    fieldValue += \"; ma=\" + frame.maxAge;\n  }\n\n  buffers.push(new Buffer(fieldValue, 'ascii'));\n};\n\nfunction stripquotes(s) {\n  var start = 0;\n  var end = s.length;\n  while ((start < end) && (s[start] === '\"')) {\n    start++;\n  }\n  while ((end > start) && (s[end - 1] === '\"')) {\n    end--;\n  }\n  if (start >= end) {\n    return \"\";\n  }\n  return s.substring(start, end);\n}\n\nfunction splitNameValue(nvpair) {\n  var eq = -1;\n  var inQuotes = false;\n\n  for (var i = 0; i < nvpair.length; i++) {\n    if (nvpair[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n    if (inQuotes) {\n      continue;\n    }\n    if (nvpair[i] === '=') {\n      eq = i;\n      break;\n    }\n  }\n\n  if (eq === -1) {\n    return {'name': nvpair, 'value': null};\n  }\n\n  var name = stripquotes(nvpair.substring(0, eq).trim());\n  var value = stripquotes(nvpair.substring(eq + 1).trim());\n  return {'name': name, 'value': value};\n}\n\nfunction splitHeaderParameters(hv) {\n  return parseHeaderValue(hv, ';', splitNameValue);\n}\n\nfunction parseHeaderValue(hv, separator, callback) {\n  var start = 0;\n  var inQuotes = false;\n  var values = [];\n\n  for (var i = 0; i < hv.length; i++) {\n    if (hv[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n    if (inQuotes) {\n      // Just skip this\n      continue;\n    }\n    if (hv[i] === separator) {\n      var newValue = hv.substring(start, i).trim();\n      if (newValue.length > 0) {\n        newValue = callback(newValue);\n        values.push(newValue);\n      }\n      start = i + 1;\n    }\n  }\n\n  var newValue = hv.substring(start).trim();\n  if (newValue.length > 0) {\n    newValue = callback(newValue);\n    values.push(newValue);\n  }\n\n  return values;\n}\n\nfunction rsplit(s, delim, count) {\n  var nsplits = 0;\n  var end = s.length;\n  var rval = [];\n  for (var i = s.length - 1; i >= 0; i--) {\n    if (s[i] === delim) {\n      var t = s.substring(i + 1, end);\n      end = i;\n      rval.unshift(t);\n      nsplits++;\n      if (nsplits === count) {\n        break;\n      }\n    }\n  }\n  if (end !== 0) {\n    rval.unshift(s.substring(0, end));\n  }\n  return rval;\n}\n\nfunction ishex(c) {\n  return ('0123456789ABCDEFabcdef'.indexOf(c) > -1);\n}\n\nfunction unescape(s) {\n  var i = 0;\n  var t = '';\n  while (i < s.length) {\n    if (s[i] != '%' || !ishex(s[i + 1]) || !ishex(s[i + 2])) {\n      t += s[i];\n    } else {\n      ++i;\n      var hexvalue = '';\n      if (i < s.length) {\n        hexvalue += s[i];\n        ++i;\n      }\n      if (i < s.length) {\n        hexvalue += s[i];\n      }\n      if (hexvalue.length > 0) {\n        t += new Buffer(hexvalue, 'hex').toString();\n      } else {\n        t += '%';\n      }\n    }\n\n    ++i;\n  }\n  return t;\n}\n\nDeserializer.ALTSVC = function readAltSvc(buffer, frame) {\n  if (buffer.length < 2) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  var originLength = buffer.readUInt16BE(0);\n  if ((buffer.length - 2) < originLength) {\n    return 'FRAME_SIZE_ERROR';\n  }\n  frame.origin = buffer.toString('ascii', 2, 2 + originLength);\n  var fieldValue = buffer.toString('ascii', 2 + originLength);\n  var values = parseHeaderValue(fieldValue, ',', splitHeaderParameters);\n  if (values.length > 1) {\n    // TODO - warn that we only use one here\n  }\n  if (values.length === 0) {\n    // Well that's a malformed frame. Just ignore it.\n    return;\n  }\n\n  var chosenAltSvc = values[0];\n  frame.maxAge = 86400; // Default\n  for (var i = 0; i < chosenAltSvc.length; i++) {\n    if (i === 0) {\n      // This corresponds to the protocolID=\"<host>:<port>\" item\n      frame.protocolID = unescape(chosenAltSvc[i].name);\n      var hostport = rsplit(chosenAltSvc[i].value, ':', 1);\n      frame.host = hostport[0];\n      frame.port = parseInt(hostport[1], 10);\n    } else if (chosenAltSvc[i].name == 'ma') {\n      frame.maxAge = parseInt(chosenAltSvc[i].value, 10);\n    }\n    // Otherwise, we just ignore this\n  }\n};\n\n// BLOCKED\n// ------------------------------------------------------------\n//\n// The BLOCKED frame (type=0xB) indicates that the sender is unable to send data\n// due to a closed flow control window.\n//\n// The BLOCKED frame does not define any flags and contains no payload.\n\nframeTypes[0xB] = 'BLOCKED';\n\nframeFlags.BLOCKED = [];\n\ntypeSpecificAttributes.BLOCKED = [];\n\nSerializer.BLOCKED = function writeBlocked(frame, buffers) {\n};\n\nDeserializer.BLOCKED = function readBlocked(buffer, frame) {\n};\n\n// [Error Codes](https://tools.ietf.org/html/rfc7540#section-7)\n// ------------------------------------------------------------\n\nvar errorCodes = [\n  'NO_ERROR',\n  'PROTOCOL_ERROR',\n  'INTERNAL_ERROR',\n  'FLOW_CONTROL_ERROR',\n  'SETTINGS_TIMEOUT',\n  'STREAM_CLOSED',\n  'FRAME_SIZE_ERROR',\n  'REFUSED_STREAM',\n  'CANCEL',\n  'COMPRESSION_ERROR',\n  'CONNECT_ERROR',\n  'ENHANCE_YOUR_CALM',\n  'INADEQUATE_SECURITY',\n  'HTTP_1_1_REQUIRED'\n];\n\n// Logging\n// -------\n\n// [Bunyan serializers](https://github.com/trentm/node-bunyan#serializers) to improve logging output\n// for debug messages emitted in this component.\nexports.serializers = {};\n\n// * `frame` serializer: it transforms data attributes from Buffers to hex strings and filters out\n//   flags that are not present.\nvar frameCounter = 0;\nexports.serializers.frame = function(frame) {\n  if (!frame) {\n    return null;\n  }\n\n  if ('id' in frame) {\n    return frame.id;\n  }\n\n  frame.id = frameCounter;\n  frameCounter += 1;\n\n  var logEntry = { id: frame.id };\n  genericAttributes.concat(typeSpecificAttributes[frame.type]).forEach(function(name) {\n    logEntry[name] = frame[name];\n  });\n\n  if (frame.data instanceof Buffer) {\n    if (logEntry.data.length > 50) {\n      logEntry.data = frame.data.slice(0, 47).toString('hex') + '...';\n    } else {\n      logEntry.data = frame.data.toString('hex');\n    }\n\n    if (!('length' in logEntry)) {\n      logEntry.length = frame.data.length;\n    }\n  }\n\n  if (frame.promised_stream instanceof Object) {\n    logEntry.promised_stream = 'stream-' + frame.promised_stream.id;\n  }\n\n  logEntry.flags = Object.keys(frame.flags || {}).filter(function(name) {\n    return frame.flags[name] === true;\n  });\n\n  return logEntry;\n};\n\n// * `data` serializer: it simply transforms a buffer to a hex string.\nexports.serializers.data = function(data) {\n  return data.toString('hex');\n};\n"]},"metadata":{},"sourceType":"script"}