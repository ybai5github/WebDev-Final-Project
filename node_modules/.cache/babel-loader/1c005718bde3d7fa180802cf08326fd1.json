{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nconst call_1 = require(\"./call\");\n\nconst channel_1 = require(\"./channel\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst client_interceptors_1 = require(\"./client-interceptors\");\n\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\n\n\nclass Client {\n  constructor(address, credentials) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _a, _b;\n\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n    delete options.interceptor_providers;\n\n    if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n      throw new Error('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n    }\n\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      const channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n    } else {\n      this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n    }\n  }\n\n  close() {\n    this[CHANNEL_SYMBOL].close();\n  }\n\n  getChannel() {\n    return this[CHANNEL_SYMBOL];\n  }\n\n  waitForReady(deadline, callback) {\n    const checkState = err => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n\n      let newState;\n\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n\n      if (newState === connectivity_state_1.ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n\n    setImmediate(checkState);\n  }\n\n  checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n    if (isFunction(arg1)) {\n      return {\n        metadata: new metadata_1.Metadata(),\n        options: {},\n        callback: arg1\n      };\n    } else if (isFunction(arg2)) {\n      if (arg1 instanceof metadata_1.Metadata) {\n        return {\n          metadata: arg1,\n          options: {},\n          callback: arg2\n        };\n      } else {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: arg1,\n          callback: arg2\n        };\n      }\n    } else {\n      if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n        throw new Error('Incorrect arguments passed');\n      }\n\n      return {\n        metadata: arg1,\n        options: arg2,\n        callback: arg3\n      };\n    }\n  }\n\n  makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n    var _a, _b;\n\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientUnaryCallImpl(),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    emitter.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let responseMessage = null;\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n        }\n\n        responseMessage = message;\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n\n        if (status.code === constants_1.Status.OK) {\n          callProperties.callback(null, responseMessage);\n        } else {\n          callProperties.callback(call_1.callErrorFromStatus(status));\n        }\n\n        emitter.emit('status', status);\n      }\n\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return emitter;\n  }\n\n  makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n    var _a, _b;\n\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientWritableStreamImpl(serialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    emitter.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let responseMessage = null;\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n        }\n\n        responseMessage = message;\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n\n        if (status.code === constants_1.Status.OK) {\n          callProperties.callback(null, responseMessage);\n        } else {\n          callProperties.callback(call_1.callErrorFromStatus(status));\n        }\n\n        emitter.emit('status', status);\n      }\n\n    });\n    return emitter;\n  }\n\n  checkMetadataAndOptions(arg1, arg2) {\n    let metadata;\n    let options;\n\n    if (arg1 instanceof metadata_1.Metadata) {\n      metadata = arg1;\n\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n\n      metadata = new metadata_1.Metadata();\n    }\n\n    return {\n      metadata,\n      options\n    };\n  }\n\n  makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n    var _a, _b;\n\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientReadableStreamImpl(deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    stream.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message) {\n        stream.push(message);\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n        stream.push(null);\n\n        if (status.code !== constants_1.Status.OK) {\n          stream.emit('error', call_1.callErrorFromStatus(status));\n        }\n\n        stream.emit('status', status);\n      }\n\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return stream;\n  }\n\n  makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n    var _a, _b;\n\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    stream.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n\n      onReceiveMessage(message) {\n        stream.push(message);\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n        stream.push(null);\n\n        if (status.code !== constants_1.Status.OK) {\n          stream.emit('error', call_1.callErrorFromStatus(status));\n        }\n\n        stream.emit('status', status);\n      }\n\n    });\n    return stream;\n  }\n\n}\n\nexports.Client = Client;","map":{"version":3,"mappings":"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","names":["CHANNEL_SYMBOL","Symbol","INTERCEPTOR_SYMBOL","INTERCEPTOR_PROVIDER_SYMBOL","CALL_INVOCATION_TRANSFORMER_SYMBOL","isFunction","arg","Client","constructor","address","credentials","options","Object","assign","interceptors","_a","interceptor_providers","_b","length","Error","callInvocationTransformer","channelOverride","channelFactoryOverride","channel_1","close","getChannel","waitForReady","deadline","callback","checkState","err","newState","getConnectivityState","e","connectivity_state_1","READY","watchConnectivityState","setImmediate","checkOptionalUnaryResponseArguments","arg1","arg2","arg3","metadata","metadata_1","makeUnaryRequest","method","serialize","deserialize","argument","checkedArguments","methodDefinition","path","requestStream","responseStream","requestSerialize","responseDeserialize","callProperties","call","call_1","channel","callOptions","emitter","interceptorArgs","clientInterceptors","clientInterceptorProviders","callInterceptors","callInterceptorProviders","client_interceptors_1","setCredentials","responseMessage","receivedStatus","start","onReceiveMetadata","emit","onReceiveMessage","message","cancelWithStatus","constants_1","INTERNAL","onReceiveStatus","status","code","OK","sendMessage","halfClose","makeClientStreamRequest","checkMetadataAndOptions","makeServerStreamRequest","stream","push","makeBidiStreamRequest","exports"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/client.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ClientDuplexStream,\n  ClientDuplexStreamImpl,\n  ClientReadableStream,\n  ClientReadableStreamImpl,\n  ClientUnaryCall,\n  ClientUnaryCallImpl,\n  ClientWritableStream,\n  ClientWritableStreamImpl,\n  ServiceError,\n  callErrorFromStatus,\n  SurfaceCall,\n} from './call';\nimport { CallCredentials } from './call-credentials';\nimport { Deadline, StatusObject } from './call-stream';\nimport { Channel, ChannelImplementation } from './channel';\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { Status } from './constants';\nimport { Metadata } from './metadata';\nimport { ClientMethodDefinition } from './make-client';\nimport {\n  getInterceptingCall,\n  Interceptor,\n  InterceptorProvider,\n  InterceptorArguments,\n  InterceptingCallInterface,\n} from './client-interceptors';\nimport {\n  ServerUnaryCall,\n  ServerReadableStream,\n  ServerWritableStream,\n  ServerDuplexStream,\n} from './server-call';\n\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\n\nfunction isFunction<ResponseType>(\n  arg: Metadata | CallOptions | UnaryCallback<ResponseType> | undefined\n): arg is UnaryCallback<ResponseType> {\n  return typeof arg === 'function';\n}\n\nexport interface UnaryCallback<ResponseType> {\n  (err: ServiceError | null, value?: ResponseType): void;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport interface CallOptions {\n  deadline?: Deadline;\n  host?: string;\n  parent?:\n    | ServerUnaryCall<any, any>\n    | ServerReadableStream<any, any>\n    | ServerWritableStream<any, any>\n    | ServerDuplexStream<any, any>;\n  propagate_flags?: number;\n  credentials?: CallCredentials;\n  interceptors?: Interceptor[];\n  interceptor_providers?: InterceptorProvider[];\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport interface CallProperties<RequestType, ResponseType> {\n  argument?: RequestType;\n  metadata: Metadata;\n  call: SurfaceCall;\n  channel: Channel;\n  methodDefinition: ClientMethodDefinition<RequestType, ResponseType>;\n  callOptions: CallOptions;\n  callback?: UnaryCallback<ResponseType>;\n}\n\nexport interface CallInvocationTransformer {\n  (callProperties: CallProperties<any, any>): CallProperties<any, any>; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\nexport type ClientOptions = Partial<ChannelOptions> & {\n  channelOverride?: Channel;\n  channelFactoryOverride?: (\n    address: string,\n    credentials: ChannelCredentials,\n    options: ClientOptions\n  ) => Channel;\n  interceptors?: Interceptor[];\n  interceptor_providers?: InterceptorProvider[];\n  callInvocationTransformer?: CallInvocationTransformer;\n};\n\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nexport class Client {\n  private readonly [CHANNEL_SYMBOL]: Channel;\n  private readonly [INTERCEPTOR_SYMBOL]: Interceptor[];\n  private readonly [INTERCEPTOR_PROVIDER_SYMBOL]: InterceptorProvider[];\n  private readonly [CALL_INVOCATION_TRANSFORMER_SYMBOL]?: CallInvocationTransformer;\n  constructor(\n    address: string,\n    credentials: ChannelCredentials,\n    options: ClientOptions = {}\n  ) {\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = options.interceptors ?? [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = options.interceptor_providers ?? [];\n    delete options.interceptor_providers;\n    if (\n      this[INTERCEPTOR_SYMBOL].length > 0 &&\n      this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0\n    ) {\n      throw new Error(\n        'Both interceptors and interceptor_providers were passed as options ' +\n          'to the client constructor. Only one of these is allowed.'\n      );\n    }\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n      options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      const channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(\n        address,\n        credentials,\n        options\n      );\n    } else {\n      this[CHANNEL_SYMBOL] = new ChannelImplementation(\n        address,\n        credentials,\n        options\n      );\n    }\n  }\n\n  close(): void {\n    this[CHANNEL_SYMBOL].close();\n  }\n\n  getChannel(): Channel {\n    return this[CHANNEL_SYMBOL];\n  }\n\n  waitForReady(deadline: Deadline, callback: (error?: Error) => void): void {\n    const checkState = (err?: Error) => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n      let newState;\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n      if (newState === ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(\n            newState,\n            deadline,\n            checkState\n          );\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n    setImmediate(checkState);\n  }\n\n  private checkOptionalUnaryResponseArguments<ResponseType>(\n    arg1: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    arg2?: CallOptions | UnaryCallback<ResponseType>,\n    arg3?: UnaryCallback<ResponseType>\n  ): {\n    metadata: Metadata;\n    options: CallOptions;\n    callback: UnaryCallback<ResponseType>;\n  } {\n    if (isFunction(arg1)) {\n      return { metadata: new Metadata(), options: {}, callback: arg1 };\n    } else if (isFunction(arg2)) {\n      if (arg1 instanceof Metadata) {\n        return { metadata: arg1, options: {}, callback: arg2 };\n      } else {\n        return { metadata: new Metadata(), options: arg1, callback: arg2 };\n      }\n    } else {\n      if (\n        !(\n          arg1 instanceof Metadata &&\n          arg2 instanceof Object &&\n          isFunction(arg3)\n        )\n      ) {\n        throw new Error('Incorrect arguments passed');\n      }\n      return { metadata: arg1, options: arg2, callback: arg3 };\n    }\n  }\n\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    callback: UnaryCallback<ResponseType>\n  ): ClientUnaryCall;\n  makeUnaryRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    options?: CallOptions | UnaryCallback<ResponseType>,\n    callback?: UnaryCallback<ResponseType>\n  ): ClientUnaryCall {\n    const checkedArguments = this.checkOptionalUnaryResponseArguments<ResponseType>(\n      metadata,\n      options,\n      callback\n    );\n    const methodDefinition: ClientMethodDefinition<\n      RequestType,\n      ResponseType\n    > = {\n      path: method,\n      requestStream: false,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize,\n    };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new ClientUnaryCallImpl(),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const emitter: ClientUnaryCall = callProperties.call;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let responseMessage: ResponseType | null = null;\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: (metadata) => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(Status.INTERNAL, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === Status.OK) {\n          callProperties.callback!(null, responseMessage!);\n        } else {\n          callProperties.callback!(callErrorFromStatus(status));\n        }\n        emitter.emit('status', status);\n      },\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return emitter;\n  }\n\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    options: CallOptions,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    callback: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType>;\n  makeClientStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,\n    options?: CallOptions | UnaryCallback<ResponseType>,\n    callback?: UnaryCallback<ResponseType>\n  ): ClientWritableStream<RequestType> {\n    const checkedArguments = this.checkOptionalUnaryResponseArguments<ResponseType>(\n      metadata,\n      options,\n      callback\n    );\n    const methodDefinition: ClientMethodDefinition<\n      RequestType,\n      ResponseType\n    > = {\n      path: method,\n      requestStream: true,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize,\n    };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      metadata: checkedArguments.metadata,\n      call: new ClientWritableStreamImpl<RequestType>(serialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const emitter: ClientWritableStream<RequestType> = callProperties.call as ClientWritableStream<RequestType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    emitter.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let responseMessage: ResponseType | null = null;\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: (metadata) => {\n        emitter.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        if (responseMessage !== null) {\n          call.cancelWithStatus(Status.INTERNAL, 'Too many responses received');\n        }\n        responseMessage = message;\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        if (status.code === Status.OK) {\n          callProperties.callback!(null, responseMessage!);\n        } else {\n          callProperties.callback!(callErrorFromStatus(status));\n        }\n        emitter.emit('status', status);\n      },\n    });\n    return emitter;\n  }\n\n  private checkMetadataAndOptions(\n    arg1?: Metadata | CallOptions,\n    arg2?: CallOptions\n  ): { metadata: Metadata; options: CallOptions } {\n    let metadata: Metadata;\n    let options: CallOptions;\n    if (arg1 instanceof Metadata) {\n      metadata = arg1;\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n      metadata = new Metadata();\n    }\n    return { metadata, options };\n  }\n\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata: Metadata,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType>;\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType>;\n  makeServerStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    argument: RequestType,\n    metadata?: Metadata | CallOptions,\n    options?: CallOptions\n  ): ClientReadableStream<ResponseType> {\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition: ClientMethodDefinition<\n      RequestType,\n      ResponseType\n    > = {\n      path: method,\n      requestStream: false,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize,\n    };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new ClientReadableStreamImpl<ResponseType>(deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const stream: ClientReadableStream<ResponseType> = callProperties.call as ClientReadableStream<ResponseType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata: Metadata) {\n        stream.emit('metadata', metadata);\n      },\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage(message: any) {\n        stream.push(message);\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== Status.OK) {\n          stream.emit('error', callErrorFromStatus(status));\n        }\n        stream.emit('status', status);\n      },\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return stream;\n  }\n\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata: Metadata,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType>;\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType>;\n  makeBidiStreamRequest<RequestType, ResponseType>(\n    method: string,\n    serialize: (value: RequestType) => Buffer,\n    deserialize: (value: Buffer) => ResponseType,\n    metadata?: Metadata | CallOptions,\n    options?: CallOptions\n  ): ClientDuplexStream<RequestType, ResponseType> {\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition: ClientMethodDefinition<\n      RequestType,\n      ResponseType\n    > = {\n      path: method,\n      requestStream: true,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize,\n    };\n    let callProperties: CallProperties<RequestType, ResponseType> = {\n      metadata: checkedArguments.metadata,\n      call: new ClientDuplexStreamImpl<RequestType, ResponseType>(\n        serialize,\n        deserialize\n      ),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n    };\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(\n        callProperties\n      ) as CallProperties<RequestType, ResponseType>;\n    }\n    const stream: ClientDuplexStream<\n      RequestType,\n      ResponseType\n    > = callProperties.call as ClientDuplexStream<RequestType, ResponseType>;\n    const interceptorArgs: InterceptorArguments = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: callProperties.callOptions.interceptors ?? [],\n      callInterceptorProviders:\n        callProperties.callOptions.interceptor_providers ?? [],\n    };\n    const call: InterceptingCallInterface = getInterceptingCall(\n      interceptorArgs,\n      callProperties.methodDefinition,\n      callProperties.callOptions,\n      callProperties.channel\n    );\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n    stream.call = call;\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata: Metadata) {\n        stream.emit('metadata', metadata);\n      },\n      onReceiveMessage(message: Buffer) {\n        stream.push(message);\n      },\n      onReceiveStatus(status: StatusObject) {\n        if (receivedStatus) {\n          return;\n        }\n        receivedStatus = true;\n        stream.push(null);\n        if (status.code !== Status.OK) {\n          stream.emit('error', callErrorFromStatus(status));\n        }\n        stream.emit('status', status);\n      },\n    });\n    return stream;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}