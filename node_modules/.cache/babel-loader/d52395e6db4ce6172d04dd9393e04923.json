{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\n\nconst http2 = require(\"http2\");\n\nconst os = require(\"os\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst TRACER_NAME = 'call_stream';\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\n\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n\n  return 'Unknown system error ' + errno;\n}\n\nfunction getMinDeadline(deadlineList) {\n  let minValue = Infinity;\n\n  for (const deadline of deadlineList) {\n    const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n\n    if (deadlineMsecs < minValue) {\n      minValue = deadlineMsecs;\n    }\n  }\n\n  return minValue;\n}\n\nfunction isInterceptingListener(listener) {\n  return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\n\nexports.isInterceptingListener = isInterceptingListener;\n\nclass InterceptingListenerImpl {\n  constructor(listener, nextListener) {\n    this.listener = listener;\n    this.nextListener = nextListener;\n    this.processingMetadata = false;\n    this.hasPendingMessage = false;\n    this.processingMessage = false;\n    this.pendingStatus = null;\n  }\n\n  processPendingMessage() {\n    if (this.hasPendingMessage) {\n      this.nextListener.onReceiveMessage(this.pendingMessage);\n      this.pendingMessage = null;\n      this.hasPendingMessage = false;\n    }\n  }\n\n  processPendingStatus() {\n    if (this.pendingStatus) {\n      this.nextListener.onReceiveStatus(this.pendingStatus);\n    }\n  }\n\n  onReceiveMetadata(metadata) {\n    this.processingMetadata = true;\n    this.listener.onReceiveMetadata(metadata, metadata => {\n      this.processingMetadata = false;\n      this.nextListener.onReceiveMetadata(metadata);\n      this.processPendingMessage();\n      this.processPendingStatus();\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  onReceiveMessage(message) {\n    /* If this listener processes messages asynchronously, the last message may\n     * be reordered with respect to the status */\n    this.processingMessage = true;\n    this.listener.onReceiveMessage(message, msg => {\n      this.processingMessage = false;\n\n      if (this.processingMetadata) {\n        this.pendingMessage = msg;\n        this.hasPendingMessage = true;\n      } else {\n        this.nextListener.onReceiveMessage(msg);\n        this.processPendingStatus();\n      }\n    });\n  }\n\n  onReceiveStatus(status) {\n    this.listener.onReceiveStatus(status, processedStatus => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingStatus = processedStatus;\n      } else {\n        this.nextListener.onReceiveStatus(processedStatus);\n      }\n    });\n  }\n\n}\n\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\n\nclass Http2CallStream {\n  constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n    this.methodName = methodName;\n    this.channel = channel;\n    this.options = options;\n    this.channelCallCredentials = channelCallCredentials;\n    this.callNumber = callNumber;\n    this.http2Stream = null;\n    this.pendingRead = false;\n    this.isWriteFilterPending = false;\n    this.pendingWrite = null;\n    this.pendingWriteCallback = null;\n    this.writesClosed = false;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    this.unfilteredReadMessages = []; // Status code mapped from :status. To be used if grpc-status is not received\n\n    this.mappedStatusCode = constants_1.Status.UNKNOWN; // This is populated (non-null) if and only if the call has ended\n\n    this.finalStatus = null;\n    this.subchannel = null;\n    this.listener = null;\n    this.internalError = null;\n    this.configDeadline = Infinity;\n    this.statusWatchers = [];\n    this.streamEndWatchers = [];\n    this.callStatsTracker = null;\n    this.filterStack = filterStackFactory.createFilter(this);\n    this.credentials = channelCallCredentials;\n\n    this.disconnectListener = () => {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    };\n\n    if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {\n      this.options.parentCall.on('cancelled', () => {\n        this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n      });\n    }\n  }\n\n  outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (this.listener && !this.statusOutput) {\n      this.statusOutput = true;\n      const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n      this.trace('ended with status: code=' + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n\n      process.nextTick(() => {\n        var _a;\n\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n      });\n\n      if (this.subchannel) {\n        this.subchannel.callUnref();\n        this.subchannel.removeDisconnectListener(this.disconnectListener);\n      }\n    }\n  }\n\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n\n\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n\n    this.destroyHttp2Stream();\n  }\n\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    process.nextTick(() => {\n      var _a;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n\n\n      if (this.statusOutput) {\n        return;\n      }\n\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  handleFilterError(error) {\n    this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n  }\n\n  handleFilteredRead(message) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n\n    this.isReadFilterPending = false;\n\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(message);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + message.length);\n      this.unpushedReadMessages.push(message);\n    }\n\n    if (this.unfilteredReadMessages.length > 0) {\n      /* nextMessage is guaranteed not to be undefined because\n         unfilteredReadMessages is non-empty */\n      const nextMessage = this.unfilteredReadMessages.shift();\n      this.filterReceivedMessage(nextMessage);\n    }\n  }\n\n  filterReceivedMessage(framedMessage) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n\n    this.trace('filterReceivedMessage of length ' + framedMessage.length);\n    this.isReadFilterPending = true;\n    this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n  }\n\n  tryPush(messageBytes) {\n    if (this.isReadFilterPending) {\n      this.trace('unfilteredReadMessages.push message of length ' + (messageBytes && messageBytes.length));\n      this.unfilteredReadMessages.push(messageBytes);\n    } else {\n      this.filterReceivedMessage(messageBytes);\n    }\n  }\n\n  handleTrailers(headers) {\n    this.streamEndWatchers.forEach(watcher => watcher(true));\n    let headersString = '';\n\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n\n    const metadataMap = metadata.getMap();\n    let code = this.mappedStatusCode;\n\n    if (code === constants_1.Status.UNKNOWN && typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n\n      if (receivedStatus in constants_1.Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n\n      metadata.remove('grpc-status');\n    }\n\n    let details = '';\n\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      details = decodeURI(metadataMap['grpc-message']);\n      metadata.remove('grpc-message');\n      this.trace('received status details string \"' + details + '\" from server');\n    }\n\n    const status = {\n      code,\n      details,\n      metadata\n    }; // This is a no-op if the call was already ended when handling headers.\n\n    this.endCall(status);\n  }\n\n  writeMessageToStream(message, callback) {\n    var _a;\n\n    (_a = this.callStatsTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n    this.http2Stream.write(message, callback);\n  }\n\n  attachHttp2Stream(stream, subchannel, extraFilters, callStatsTracker) {\n    this.filterStack.push(extraFilters);\n\n    if (this.finalStatus !== null) {\n      stream.close(NGHTTP2_CANCEL);\n    } else {\n      this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n      this.http2Stream = stream;\n      this.subchannel = subchannel;\n      this.callStatsTracker = callStatsTracker;\n      subchannel.addDisconnectListener(this.disconnectListener);\n      subchannel.callRef();\n      stream.on('response', (headers, flags) => {\n        var _a;\n\n        let headersString = '';\n\n        for (const header of Object.keys(headers)) {\n          headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n\n        this.trace('Received server headers:\\n' + headersString);\n\n        switch (headers[':status']) {\n          // TODO(murgatroid99): handle 100 and 101\n          case 400:\n            this.mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n\n          case 401:\n            this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n\n          case 403:\n            this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n\n          case 404:\n            this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n\n          case 429:\n          case 502:\n          case 503:\n          case 504:\n            this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n\n          default:\n            this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        }\n\n        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n          this.handleTrailers(headers);\n        } else {\n          let metadata;\n\n          try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n            return;\n          }\n\n          try {\n            const finalMetadata = this.filterStack.receiveMetadata(metadata);\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n          }\n        }\n      });\n      stream.on('trailers', this.handleTrailers.bind(this));\n      stream.on('data', data => {\n        this.trace('receive HTTP/2 data frame of length ' + data.length);\n        const messages = this.decoder.write(data);\n\n        for (const message of messages) {\n          this.trace('parsed message of length ' + message.length);\n          this.callStatsTracker.addMessageReceived();\n          this.tryPush(message);\n        }\n      });\n      stream.on('end', () => {\n        this.readsClosed = true;\n        this.maybeOutputStatus();\n      });\n      stream.on('close', () => {\n        /* Use process.next tick to ensure that this code happens after any\n         * \"error\" event that may be emitted at about the same time, so that\n         * we can bubble up the error message from that event. */\n        process.nextTick(() => {\n          var _a;\n\n          this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n          /* If we have a final status with an OK status code, that means that\n           * we have received all of the messages and we have processed the\n           * trailers and the call completed successfully, so it doesn't matter\n           * how the stream ends after that */\n\n          if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n            return;\n          }\n\n          let code;\n          let details = '';\n\n          switch (stream.rstCode) {\n            case http2.constants.NGHTTP2_NO_ERROR:\n              /* If we get a NO_ERROR code and we already have a status, the\n               * stream completed properly and we just haven't fully processed\n               * it yet */\n              if (this.finalStatus !== null) {\n                return;\n              }\n\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n              break;\n\n            case http2.constants.NGHTTP2_REFUSED_STREAM:\n              code = constants_1.Status.UNAVAILABLE;\n              details = 'Stream refused by server';\n              break;\n\n            case http2.constants.NGHTTP2_CANCEL:\n              code = constants_1.Status.CANCELLED;\n              details = 'Call cancelled';\n              break;\n\n            case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n              code = constants_1.Status.RESOURCE_EXHAUSTED;\n              details = 'Bandwidth exhausted or memory limit exceeded';\n              break;\n\n            case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n              code = constants_1.Status.PERMISSION_DENIED;\n              details = 'Protocol not secure enough';\n              break;\n\n            case http2.constants.NGHTTP2_INTERNAL_ERROR:\n              code = constants_1.Status.INTERNAL;\n\n              if (this.internalError === null) {\n                /* This error code was previously handled in the default case, and\n                 * there are several instances of it online, so I wanted to\n                 * preserve the original error message so that people find existing\n                 * information in searches, but also include the more recognizable\n                 * \"Internal server error\" message. */\n                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n              } else {\n                if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                  code = constants_1.Status.UNAVAILABLE;\n                  details = this.internalError.message;\n                } else {\n                  /* The \"Received RST_STREAM with code ...\" error is preserved\n                   * here for continuity with errors reported online, but the\n                   * error message at the end will probably be more relevant in\n                   * most cases. */\n                  details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                }\n              }\n\n              break;\n\n            default:\n              code = constants_1.Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n          } // This is a no-op if trailers were received at all.\n          // This is OK, because status codes emitted here correspond to more\n          // catastrophic issues that prevent us from receiving trailers in the\n          // first place.\n\n\n          this.endCall({\n            code,\n            details,\n            metadata: new metadata_1.Metadata()\n          });\n        });\n      });\n      stream.on('error', err => {\n        /* We need an error handler here to stop \"Uncaught Error\" exceptions\n         * from bubbling up. However, errors here should all correspond to\n         * \"close\" events, where we will handle the error more granularly */\n\n        /* Specifically looking for stream errors that were *not* constructed\n         * from a RST_STREAM response here:\n         * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n         */\n        if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n          this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n          this.internalError = err;\n        }\n\n        this.streamEndWatchers.forEach(watcher => watcher(false));\n      });\n\n      if (!this.pendingRead) {\n        stream.pause();\n      }\n\n      if (this.pendingWrite) {\n        if (!this.pendingWriteCallback) {\n          throw new Error('Invalid state in write handling code');\n        }\n\n        this.trace('sending data chunk of length ' + this.pendingWrite.length + ' (deferred)');\n\n        try {\n          this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Write failed with error ${error.message}`,\n            metadata: new metadata_1.Metadata()\n          });\n        }\n      }\n\n      this.maybeCloseWrites();\n    }\n  }\n\n  start(metadata, listener) {\n    this.trace('Sending metadata');\n    this.listener = listener;\n\n    this.channel._startCallStream(this, metadata);\n\n    this.maybeOutputStatus();\n  }\n\n  destroyHttp2Stream() {\n    var _a; // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n\n\n    if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n\n  getDeadline() {\n    const deadlineList = [this.options.deadline];\n\n    if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n      deadlineList.push(this.options.parentCall.getDeadline());\n    }\n\n    if (this.configDeadline) {\n      deadlineList.push(this.configDeadline);\n    }\n\n    return getMinDeadline(deadlineList);\n  }\n\n  getCredentials() {\n    return this.credentials;\n  }\n\n  setCredentials(credentials) {\n    this.credentials = this.channelCallCredentials.compose(credentials);\n  }\n\n  getStatus() {\n    return this.finalStatus;\n  }\n\n  getPeer() {\n    var _a, _b;\n\n    return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n\n  getMethod() {\n    return this.methodName;\n  }\n\n  getHost() {\n    return this.options.host;\n  }\n\n  setConfigDeadline(configDeadline) {\n    this.configDeadline = configDeadline;\n  }\n\n  addStatusWatcher(watcher) {\n    this.statusWatchers.push(watcher);\n  }\n\n  addStreamEndWatcher(watcher) {\n    this.streamEndWatchers.push(watcher);\n  }\n\n  addFilters(extraFilters) {\n    this.filterStack.push(extraFilters);\n  }\n\n  getCallNumber() {\n    return this.callNumber;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n\n    this.canPush = true;\n\n    if (this.http2Stream === null) {\n      this.pendingRead = true;\n    } else {\n      if (this.unpushedReadMessages.length > 0) {\n        const nextMessage = this.unpushedReadMessages.shift();\n        this.push(nextMessage);\n        return;\n      }\n      /* Only resume reading from the http2Stream if we don't have any pending\n       * messages to emit */\n\n\n      this.http2Stream.resume();\n    }\n  }\n\n  maybeCloseWrites() {\n    if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {\n      this.trace('calling end() on HTTP/2 stream');\n      this.http2Stream.end();\n    }\n  }\n\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj = {\n      message,\n      flags: context.flags\n    };\n\n    const cb = error => {\n      var _a, _b;\n\n      let code = constants_1.Status.UNAVAILABLE;\n\n      if (((_a = error) === null || _a === void 0 ? void 0 : _a.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = constants_1.Status.INTERNAL;\n      }\n\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n\n      (_b = context.callback) === null || _b === void 0 ? void 0 : _b.call(context);\n    };\n\n    this.isWriteFilterPending = true;\n    this.filterStack.sendMessage(Promise.resolve(writeObj)).then(message => {\n      this.isWriteFilterPending = false;\n\n      if (this.http2Stream === null) {\n        this.trace('deferring writing data chunk of length ' + message.message.length);\n        this.pendingWrite = message.message;\n        this.pendingWriteCallback = cb;\n      } else {\n        this.trace('sending data chunk of length ' + message.message.length);\n\n        try {\n          this.writeMessageToStream(message.message, cb);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Write failed with error ${error.message}`,\n            metadata: new metadata_1.Metadata()\n          });\n        }\n\n        this.maybeCloseWrites();\n      }\n    }, this.handleFilterError.bind(this));\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.writesClosed = true;\n    this.maybeCloseWrites();\n  }\n\n}\n\nexports.Http2CallStream = Http2CallStream;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","HTTP2_HEADER_STATUS","HTTP2_HEADER_CONTENT_TYPE","NGHTTP2_CANCEL","http2","constants","getSystemErrorName","errno","name","num","Object","entries","os","getMinDeadline","deadlineList","minValue","Infinity","deadline","deadlineMsecs","Date","getTime","isInterceptingListener","listener","onReceiveMetadata","undefined","length","exports","InterceptingListenerImpl","constructor","nextListener","processPendingMessage","hasPendingMessage","onReceiveMessage","pendingMessage","processPendingStatus","pendingStatus","onReceiveStatus","metadata","processingMetadata","message","processingMessage","msg","status","processedStatus","Http2CallStream","methodName","channel","options","filterStackFactory","channelCallCredentials","callNumber","stream_decoder_1","constants_1","UNKNOWN","filterStack","createFilter","credentials","disconnectListener","endCall","code","UNAVAILABLE","details","metadata_1","parentCall","flags","CANCELLATION","on","cancelWithStatus","CANCELLED","outputStatus","statusOutput","filteredStatus","receiveTrailers","finalStatus","trace","statusWatchers","forEach","watcher","process","nextTick","_a","subchannel","callUnref","removeDisconnectListener","text","logging","constants_2","DEBUG","OK","maybeOutputStatus","destroyHttp2Stream","readsClosed","unpushedReadMessages","unfilteredReadMessages","isReadFilterPending","push","Buffer","canPush","handleFilterError","error","INTERNAL","handleFilteredRead","http2Stream","pause","nextMessage","shift","filterReceivedMessage","framedMessage","receiveMessage","Promise","resolve","then","bind","tryPush","messageBytes","handleTrailers","headers","streamEndWatchers","headersString","header","keys","fromHttp2Headers","e","metadataMap","getMap","mappedStatusCode","receivedStatus","Number","remove","decodeURI","writeMessageToStream","callback","callStatsTracker","addMessageSent","write","attachHttp2Stream","stream","extraFilters","close","getAddress","addDisconnectListener","callRef","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","NGHTTP2_FLAG_END_STREAM","finalMetadata","receiveMetadata","data","messages","decoder","addMessageReceived","rstCode","NGHTTP2_NO_ERROR","NGHTTP2_REFUSED_STREAM","NGHTTP2_ENHANCE_YOUR_CALM","RESOURCE_EXHAUSTED","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","internalError","err","syscall","pendingRead","pendingWrite","pendingWriteCallback","Error","maybeCloseWrites","start","_startCallStream","destroyed","getDeadline","DEADLINE","configDeadline","getCredentials","setCredentials","compose","getStatus","getPeer","_b","getTarget","getMethod","getHost","host","setConfigDeadline","addStatusWatcher","addStreamEndWatcher","addFilters","getCallNumber","startRead","resume","writesClosed","isWriteFilterPending","end","sendMessageWithContext","context","writeObj","cb","sendMessage","halfClose"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/call-stream.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as os from 'os';\n\nimport { CallCredentials } from './call-credentials';\nimport { Propagate, Status } from './constants';\nimport { Filter, FilterFactory } from './filter';\nimport { FilterStackFactory, FilterStack } from './filter-stack';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport { ChannelImplementation } from './channel';\nimport { SubchannelCallStatsTracker, Subchannel } from './subchannel';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { ServerSurfaceCall } from './server-call';\n\nconst TRACER_NAME = 'call_stream';\n\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL,\n} = http2.constants;\n\n/**\n * https://nodejs.org/api/errors.html#errors_class_systemerror\n */\ninterface SystemError extends Error {\n  address?: string;\n  code: string;\n  dest?: string;\n  errno: number;\n  info?: object;\n  message: string;\n  path?: string;\n  port?: number;\n  syscall: string;\n}\n\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno: number): string {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\n\nexport type Deadline = Date | number;\n\nfunction getMinDeadline(deadlineList: Deadline[]): Deadline {\n  let minValue = Infinity;\n  for (const deadline of deadlineList) {\n    const deadlineMsecs =\n      deadline instanceof Date ? deadline.getTime() : deadline;\n    if (deadlineMsecs < minValue) {\n      minValue = deadlineMsecs;\n    }\n  }\n  return minValue;\n}\n\nexport interface CallStreamOptions {\n  deadline: Deadline;\n  flags: number;\n  host: string;\n  parentCall: ServerSurfaceCall | null;\n}\n\nexport type PartialCallStreamOptions = Partial<CallStreamOptions>;\n\nexport interface StatusObject {\n  code: Status;\n  details: string;\n  metadata: Metadata;\n}\n\nexport const enum WriteFlags {\n  BufferHint = 1,\n  NoCompress = 2,\n  WriteThrough = 4,\n}\n\nexport interface WriteObject {\n  message: Buffer;\n  flags?: number;\n}\n\nexport interface MetadataListener {\n  (metadata: Metadata, next: (metadata: Metadata) => void): void;\n}\n\nexport interface MessageListener {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface StatusListener {\n  (status: StatusObject, next: (status: StatusObject) => void): void;\n}\n\nexport interface FullListener {\n  onReceiveMetadata: MetadataListener;\n  onReceiveMessage: MessageListener;\n  onReceiveStatus: StatusListener;\n}\n\nexport type Listener = Partial<FullListener>;\n\n/**\n * An object with methods for handling the responses to a call.\n */\nexport interface InterceptingListener {\n  onReceiveMetadata(metadata: Metadata): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onReceiveMessage(message: any): void;\n  onReceiveStatus(status: StatusObject): void;\n}\n\nexport function isInterceptingListener(\n  listener: Listener | InterceptingListener\n): listener is InterceptingListener {\n  return (\n    listener.onReceiveMetadata !== undefined &&\n    listener.onReceiveMetadata.length === 1\n  );\n}\n\nexport class InterceptingListenerImpl implements InterceptingListener {\n  private processingMetadata = false;\n  private hasPendingMessage = false;\n  private pendingMessage: any;\n  private processingMessage = false;\n  private pendingStatus: StatusObject | null = null;\n  constructor(\n    private listener: FullListener,\n    private nextListener: InterceptingListener\n  ) {}\n\n  private processPendingMessage() {\n    if (this.hasPendingMessage) {\n      this.nextListener.onReceiveMessage(this.pendingMessage);\n      this.pendingMessage = null;\n      this.hasPendingMessage = false;\n    }\n  }\n\n  private processPendingStatus() {\n    if (this.pendingStatus) {\n      this.nextListener.onReceiveStatus(this.pendingStatus);\n    }\n  }\n\n  onReceiveMetadata(metadata: Metadata): void {\n    this.processingMetadata = true;\n    this.listener.onReceiveMetadata(metadata, (metadata) => {\n      this.processingMetadata = false;\n      this.nextListener.onReceiveMetadata(metadata);\n      this.processPendingMessage();\n      this.processPendingStatus();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onReceiveMessage(message: any): void {\n    /* If this listener processes messages asynchronously, the last message may\n     * be reordered with respect to the status */\n    this.processingMessage = true;\n    this.listener.onReceiveMessage(message, (msg) => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessage = msg;\n        this.hasPendingMessage = true;\n      } else {\n        this.nextListener.onReceiveMessage(msg);\n        this.processPendingStatus();\n      }\n    });\n  }\n  onReceiveStatus(status: StatusObject): void {\n    this.listener.onReceiveStatus(status, (processedStatus) => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingStatus = processedStatus;\n      } else {\n        this.nextListener.onReceiveStatus(processedStatus);\n      }\n    });\n  }\n}\n\nexport interface WriteCallback {\n  (error?: Error | null): void;\n}\n\nexport interface MessageContext {\n  callback?: WriteCallback;\n  flags?: number;\n}\n\nexport interface Call {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener: InterceptingListener): void;\n  sendMessageWithContext(context: MessageContext, message: Buffer): void;\n  startRead(): void;\n  halfClose(): void;\n\n  getDeadline(): Deadline;\n  getCredentials(): CallCredentials;\n  setCredentials(credentials: CallCredentials): void;\n  getMethod(): string;\n  getHost(): string;\n}\n\nexport class Http2CallStream implements Call {\n  credentials: CallCredentials;\n  filterStack: FilterStack;\n  private http2Stream: http2.ClientHttp2Stream | null = null;\n  private pendingRead = false;\n  private isWriteFilterPending = false;\n  private pendingWrite: Buffer | null = null;\n  private pendingWriteCallback: WriteCallback | null = null;\n  private writesClosed = false;\n\n  private decoder = new StreamDecoder();\n\n  private isReadFilterPending = false;\n  private canPush = false;\n  /**\n   * Indicates that an 'end' event has come from the http2 stream, so there\n   * will be no more data events.\n   */\n  private readsClosed = false;\n\n  private statusOutput = false;\n\n  private unpushedReadMessages: Buffer[] = [];\n  private unfilteredReadMessages: Buffer[] = [];\n\n  // Status code mapped from :status. To be used if grpc-status is not received\n  private mappedStatusCode: Status = Status.UNKNOWN;\n\n  // This is populated (non-null) if and only if the call has ended\n  private finalStatus: StatusObject | null = null;\n\n  private subchannel: Subchannel | null = null;\n  private disconnectListener: () => void;\n\n  private listener: InterceptingListener | null = null;\n\n  private internalError: SystemError | null = null;\n\n  private configDeadline: Deadline = Infinity;\n\n  private statusWatchers: ((status: StatusObject) => void)[] = [];\n  private streamEndWatchers: ((success: boolean) => void)[] = [];\n\n  private callStatsTracker: SubchannelCallStatsTracker | null = null;\n\n  constructor(\n    private readonly methodName: string,\n    private readonly channel: ChannelImplementation,\n    private readonly options: CallStreamOptions,\n    filterStackFactory: FilterStackFactory,\n    private readonly channelCallCredentials: CallCredentials,\n    private readonly callNumber: number\n  ) {\n    this.filterStack = filterStackFactory.createFilter(this);\n    this.credentials = channelCallCredentials;\n    this.disconnectListener = () => {\n      this.endCall({\n        code: Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new Metadata(),\n      });\n    };\n    if (\n      this.options.parentCall &&\n      this.options.flags & Propagate.CANCELLATION\n    ) {\n      this.options.parentCall.on('cancelled', () => {\n        this.cancelWithStatus(Status.CANCELLED, 'Cancelled by parent call');\n      });\n    }\n  }\n\n  private outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (this.listener && !this.statusOutput) {\n      this.statusOutput = true;\n      const filteredStatus = this.filterStack.receiveTrailers(\n        this.finalStatus!\n      );\n      this.trace(\n        'ended with status: code=' +\n          filteredStatus.code +\n          ' details=\"' +\n          filteredStatus.details +\n          '\"'\n      );\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener?.onReceiveStatus(filteredStatus);\n      });\n      if (this.subchannel) {\n        this.subchannel.callUnref();\n        this.subchannel.removeDisconnectListener(this.disconnectListener);\n      }\n    }\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  private endCall(status: StatusObject): void {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n\n  private maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (\n        this.finalStatus.code !== Status.OK ||\n        (this.readsClosed &&\n          this.unpushedReadMessages.length === 0 &&\n          this.unfilteredReadMessages.length === 0 &&\n          !this.isReadFilterPending)\n      ) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  private push(message: Buffer): void {\n    this.trace(\n      'pushing to reader message of length ' +\n        (message instanceof Buffer ? message.length : null)\n    );\n    this.canPush = false;\n    process.nextTick(() => {\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener?.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  private handleFilterError(error: Error) {\n    this.cancelWithStatus(Status.INTERNAL, error.message);\n  }\n\n  private handleFilteredRead(message: Buffer) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n    this.isReadFilterPending = false;\n    if (this.canPush) {\n      this.http2Stream!.pause();\n      this.push(message);\n    } else {\n      this.trace(\n        'unpushedReadMessages.push message of length ' + message.length\n      );\n      this.unpushedReadMessages.push(message);\n    }\n    if (this.unfilteredReadMessages.length > 0) {\n      /* nextMessage is guaranteed not to be undefined because\n         unfilteredReadMessages is non-empty */\n      const nextMessage = this.unfilteredReadMessages.shift()!;\n      this.filterReceivedMessage(nextMessage);\n    }\n  }\n\n  private filterReceivedMessage(framedMessage: Buffer) {\n    /* If we the call has already ended with an error, we don't want to do\n     * anything with this message. Dropping it on the floor is correct\n     * behavior */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.maybeOutputStatus();\n      return;\n    }\n    this.trace('filterReceivedMessage of length ' + framedMessage.length);\n    this.isReadFilterPending = true;\n    this.filterStack\n      .receiveMessage(Promise.resolve(framedMessage))\n      .then(\n        this.handleFilteredRead.bind(this),\n        this.handleFilterError.bind(this)\n      );\n  }\n\n  private tryPush(messageBytes: Buffer): void {\n    if (this.isReadFilterPending) {\n      this.trace(\n        'unfilteredReadMessages.push message of length ' +\n          (messageBytes && messageBytes.length)\n      );\n      this.unfilteredReadMessages.push(messageBytes);\n    } else {\n      this.filterReceivedMessage(messageBytes);\n    }\n  }\n\n  private handleTrailers(headers: http2.IncomingHttpHeaders) {\n    this.streamEndWatchers.forEach(watcher => watcher(true));\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata: Metadata;\n    try {\n      metadata = Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code: Status = this.mappedStatusCode;\n    if (\n      code === Status.UNKNOWN &&\n      typeof metadataMap['grpc-status'] === 'string'\n    ) {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      details = decodeURI(metadataMap['grpc-message']);\n      metadata.remove('grpc-message');\n      this.trace(\n        'received status details string \"' + details + '\" from server'\n      );\n    }\n    const status: StatusObject = { code, details, metadata };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n\n  private writeMessageToStream(message: Buffer, callback: WriteCallback) {\n    this.callStatsTracker?.addMessageSent();\n    this.http2Stream!.write(message, callback);\n  }\n\n  attachHttp2Stream(\n    stream: http2.ClientHttp2Stream,\n    subchannel: Subchannel,\n    extraFilters: Filter[],\n    callStatsTracker: SubchannelCallStatsTracker\n  ): void {\n    this.filterStack.push(extraFilters);\n    if (this.finalStatus !== null) {\n      stream.close(NGHTTP2_CANCEL);\n    } else {\n      this.trace(\n        'attachHttp2Stream from subchannel ' + subchannel.getAddress()\n      );\n      this.http2Stream = stream;\n      this.subchannel = subchannel;\n      this.callStatsTracker = callStatsTracker;\n      subchannel.addDisconnectListener(this.disconnectListener);\n      subchannel.callRef();\n      stream.on('response', (headers, flags) => {\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n          headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server headers:\\n' + headersString);\n        switch (headers[':status']) {\n          // TODO(murgatroid99): handle 100 and 101\n          case 400:\n            this.mappedStatusCode = Status.INTERNAL;\n            break;\n          case 401:\n            this.mappedStatusCode = Status.UNAUTHENTICATED;\n            break;\n          case 403:\n            this.mappedStatusCode = Status.PERMISSION_DENIED;\n            break;\n          case 404:\n            this.mappedStatusCode = Status.UNIMPLEMENTED;\n            break;\n          case 429:\n          case 502:\n          case 503:\n          case 504:\n            this.mappedStatusCode = Status.UNAVAILABLE;\n            break;\n          default:\n            this.mappedStatusCode = Status.UNKNOWN;\n        }\n\n        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n          this.handleTrailers(headers);\n        } else {\n          let metadata: Metadata;\n          try {\n            metadata = Metadata.fromHttp2Headers(headers);\n          } catch (error) {\n            this.endCall({\n              code: Status.UNKNOWN,\n              details: error.message,\n              metadata: new Metadata(),\n            });\n            return;\n          }\n          try {\n            const finalMetadata = this.filterStack.receiveMetadata(metadata);\n            this.listener?.onReceiveMetadata(finalMetadata);\n          } catch (error) {\n            this.endCall({\n              code: Status.UNKNOWN,\n              details: error.message,\n              metadata: new Metadata(),\n            });\n          }\n        }\n      });\n      stream.on('trailers', this.handleTrailers.bind(this));\n      stream.on('data', (data: Buffer) => {\n        this.trace('receive HTTP/2 data frame of length ' + data.length);\n        const messages = this.decoder.write(data);\n\n        for (const message of messages) {\n          this.trace('parsed message of length ' + message.length);\n          this.callStatsTracker!.addMessageReceived();\n          this.tryPush(message);\n        }\n      });\n      stream.on('end', () => {\n        this.readsClosed = true;\n        this.maybeOutputStatus();\n      });\n      stream.on('close', () => {\n        /* Use process.next tick to ensure that this code happens after any\n         * \"error\" event that may be emitted at about the same time, so that\n         * we can bubble up the error message from that event. */\n        process.nextTick(() => {\n          this.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n          /* If we have a final status with an OK status code, that means that\n           * we have received all of the messages and we have processed the\n           * trailers and the call completed successfully, so it doesn't matter\n           * how the stream ends after that */\n          if (this.finalStatus?.code === Status.OK) {\n            return;\n          }\n          let code: Status;\n          let details = '';\n          switch (stream.rstCode) {\n            case http2.constants.NGHTTP2_NO_ERROR:\n              /* If we get a NO_ERROR code and we already have a status, the\n               * stream completed properly and we just haven't fully processed\n               * it yet */\n              if (this.finalStatus !== null) {\n                return;\n              }\n              code = Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n              break;\n            case http2.constants.NGHTTP2_REFUSED_STREAM:\n              code = Status.UNAVAILABLE;\n              details = 'Stream refused by server';\n              break;\n            case http2.constants.NGHTTP2_CANCEL:\n              code = Status.CANCELLED;\n              details = 'Call cancelled';\n              break;\n            case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n              code = Status.RESOURCE_EXHAUSTED;\n              details = 'Bandwidth exhausted or memory limit exceeded';\n              break;\n            case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n              code = Status.PERMISSION_DENIED;\n              details = 'Protocol not secure enough';\n              break;\n            case http2.constants.NGHTTP2_INTERNAL_ERROR:\n              code = Status.INTERNAL;\n              if (this.internalError === null) {\n                /* This error code was previously handled in the default case, and\n                 * there are several instances of it online, so I wanted to\n                 * preserve the original error message so that people find existing\n                 * information in searches, but also include the more recognizable\n                 * \"Internal server error\" message. */\n                details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n              } else {\n                if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                  code = Status.UNAVAILABLE;\n                  details = this.internalError.message;\n                } else {\n                  /* The \"Received RST_STREAM with code ...\" error is preserved\n                   * here for continuity with errors reported online, but the\n                   * error message at the end will probably be more relevant in\n                   * most cases. */\n                  details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                }\n              }\n              break;\n            default:\n              code = Status.INTERNAL;\n              details = `Received RST_STREAM with code ${stream.rstCode}`;\n          }\n          // This is a no-op if trailers were received at all.\n          // This is OK, because status codes emitted here correspond to more\n          // catastrophic issues that prevent us from receiving trailers in the\n          // first place.\n          this.endCall({ code, details, metadata: new Metadata() });\n        });\n      });\n      stream.on('error', (err: SystemError) => {\n        /* We need an error handler here to stop \"Uncaught Error\" exceptions\n         * from bubbling up. However, errors here should all correspond to\n         * \"close\" events, where we will handle the error more granularly */\n        /* Specifically looking for stream errors that were *not* constructed\n         * from a RST_STREAM response here:\n         * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n         */\n        if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n          this.trace(\n            'Node error event: message=' +\n              err.message +\n              ' code=' +\n              err.code +\n              ' errno=' +\n              getSystemErrorName(err.errno) +\n              ' syscall=' +\n              err.syscall\n          );\n          this.internalError = err;\n        }\n        this.streamEndWatchers.forEach(watcher => watcher(false));\n      });\n      if (!this.pendingRead) {\n        stream.pause();\n      }\n      if (this.pendingWrite) {\n        if (!this.pendingWriteCallback) {\n          throw new Error('Invalid state in write handling code');\n        }\n        this.trace(\n          'sending data chunk of length ' +\n            this.pendingWrite.length +\n            ' (deferred)'\n        );\n        try {\n          this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);\n        } catch (error) {\n          this.endCall({\n            code: Status.UNAVAILABLE,\n            details: `Write failed with error ${error.message}`,\n            metadata: new Metadata()\n          });\n        }\n      }\n      this.maybeCloseWrites();\n    }\n  }\n\n  start(metadata: Metadata, listener: InterceptingListener) {\n    this.trace('Sending metadata');\n    this.listener = listener;\n    this.channel._startCallStream(this, metadata);\n    this.maybeOutputStatus();\n  }\n\n  private destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code: number;\n      if (this.finalStatus?.code === Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.endCall({ code: status, details, metadata: new Metadata() });\n  }\n\n  getDeadline(): Deadline {\n    const deadlineList = [this.options.deadline];\n    if (this.options.parentCall && this.options.flags & Propagate.DEADLINE) {\n      deadlineList.push(this.options.parentCall.getDeadline());\n    }\n    if (this.configDeadline) {\n      deadlineList.push(this.configDeadline);\n    }\n    return getMinDeadline(deadlineList);\n  }\n\n  getCredentials(): CallCredentials {\n    return this.credentials;\n  }\n\n  setCredentials(credentials: CallCredentials): void {\n    this.credentials = this.channelCallCredentials.compose(credentials);\n  }\n\n  getStatus(): StatusObject | null {\n    return this.finalStatus;\n  }\n\n  getPeer(): string {\n    return this.subchannel?.getAddress() ?? this.channel.getTarget();\n  }\n\n  getMethod(): string {\n    return this.methodName;\n  }\n\n  getHost(): string {\n    return this.options.host;\n  }\n\n  setConfigDeadline(configDeadline: Deadline) {\n    this.configDeadline = configDeadline;\n  }\n\n  addStatusWatcher(watcher: (status: StatusObject) => void) {\n    this.statusWatchers.push(watcher);\n  }\n\n  addStreamEndWatcher(watcher: (success: boolean) => void) {\n    this.streamEndWatchers.push(watcher);\n  }\n\n  addFilters(extraFilters: Filter[]) {\n    this.filterStack.push(extraFilters);\n  }\n\n  getCallNumber() {\n    return this.callNumber;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.http2Stream === null) {\n      this.pendingRead = true;\n    } else {\n      if (this.unpushedReadMessages.length > 0) {\n        const nextMessage: Buffer = this.unpushedReadMessages.shift()!;\n        this.push(nextMessage);\n        return;\n      }\n      /* Only resume reading from the http2Stream if we don't have any pending\n       * messages to emit */\n      this.http2Stream.resume();\n    }\n  }\n\n  private maybeCloseWrites() {\n    if (\n      this.writesClosed &&\n      !this.isWriteFilterPending &&\n      this.http2Stream !== null\n    ) {\n      this.trace('calling end() on HTTP/2 stream');\n      this.http2Stream.end();\n    }\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer) {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj: WriteObject = {\n      message,\n      flags: context.flags,\n    };\n    const cb: WriteCallback = (error?: Error | null) => {\n      let code: Status = Status.UNAVAILABLE;\n      if ((error as NodeJS.ErrnoException)?.code === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      context.callback?.();\n    };\n    this.isWriteFilterPending = true;\n    this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message) => {\n      this.isWriteFilterPending = false;\n      if (this.http2Stream === null) {\n        this.trace(\n          'deferring writing data chunk of length ' + message.message.length\n        );\n        this.pendingWrite = message.message;\n        this.pendingWriteCallback = cb;\n      } else {\n        this.trace('sending data chunk of length ' + message.message.length);\n        try {\n        this.writeMessageToStream(message.message, cb);\n        }  catch (error) {\n          this.endCall({\n            code: Status.UNAVAILABLE,\n            details: `Write failed with error ${error.message}`,\n            metadata: new Metadata()\n          });\n        }\n        this.maybeCloseWrites();\n      }\n    }, this.handleFilterError.bind(this));\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.writesClosed = true;\n    this.maybeCloseWrites();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}