{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\n\nconst filter_1 = require(\"./filter\");\n\nconst constants_1 = require(\"./constants\");\n\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n  constructor(options, callStream) {\n    super();\n    this.options = options;\n    this.callStream = callStream;\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n\n  async sendMessage(message) {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxSendMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n\n      if (concreteMessage.message.length > this.maxSendMessageSize) {\n        this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);\n        return Promise.reject('Message too large');\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n\n  async receiveMessage(message) {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxReceiveMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n\n      if (concreteMessage.length > this.maxReceiveMessageSize) {\n        this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);\n        return Promise.reject('Message too large');\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n\n}\n\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\n\nclass MaxMessageSizeFilterFactory {\n  constructor(options) {\n    this.options = options;\n  }\n\n  createFilter(callStream) {\n    return new MaxMessageSizeFilter(this.options, callStream);\n  }\n\n}\n\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;AAiBA;;AAEA;;AAOA,MAAaA,oBAAb,SAA0CC,mBAA1C,CAAoD;AAGlDC,cACmBC,OADnB,EAEmBC,UAFnB,EAEmC;AAEjC;AAHiB;AACA;AAJX,8BAA6BC,2CAA7B;AACA,iCAAgCA,8CAAhC;;AAMN,QAAI,kCAAkCF,OAAtC,EAA+C;AAC7C,WAAKG,kBAAL,GAA0BH,OAAO,CAAC,8BAAD,CAAjC;AACD;;AACD,QAAI,qCAAqCA,OAAzC,EAAkD;AAChD,WAAKI,qBAAL,GAA6BJ,OAAO,CAAC,iCAAD,CAApC;AACD;AACF;;AAEgB,QAAXK,WAAW,CAACC,OAAD,EAA8B;AAC7C;;AAEA,QAAI,KAAKH,kBAAL,KAA4B,CAAC,CAAjC,EAAoC;AAClC,aAAOG,OAAP;AACD,KAFD,MAEO;AACL,YAAMC,eAAe,GAAG,MAAMD,OAA9B;;AACA,UAAIC,eAAe,CAACD,OAAhB,CAAwBE,MAAxB,GAAiC,KAAKL,kBAA1C,EAA8D;AAC5D,aAAKF,UAAL,CAAgBQ,gBAAhB,CACEP,mBAAOQ,kBADT,EAEE,iCAAiCH,eAAe,CAACD,OAAhB,CAAwBE,MAAM,QAAQ,KAAKL,kBAAkB,GAFhG;AAIA,eAAOQ,OAAO,CAACC,MAAR,CAA4B,mBAA5B,CAAP;AACD,OAND,MAMO;AACL,eAAOL,eAAP;AACD;AACF;AACF;;AAEmB,QAAdM,cAAc,CAACP,OAAD,EAAyB;AAC3C;;AAEA,QAAI,KAAKF,qBAAL,KAA+B,CAAC,CAApC,EAAuC;AACrC,aAAOE,OAAP;AACD,KAFD,MAEO;AACL,YAAMC,eAAe,GAAG,MAAMD,OAA9B;;AACA,UAAIC,eAAe,CAACC,MAAhB,GAAyB,KAAKJ,qBAAlC,EAAyD;AACvD,aAAKH,UAAL,CAAgBQ,gBAAhB,CACEP,mBAAOQ,kBADT,EAEE,qCAAqCH,eAAe,CAACC,MAAM,QAAQ,KAAKJ,qBAAqB,GAF/F;AAIA,eAAOO,OAAO,CAACC,MAAR,CAAuB,mBAAvB,CAAP;AACD,OAND,MAMO;AACL,eAAOL,eAAP;AACD;AACF;AACF;;AApDiD;;AAApDO;;AAuDA,MAAaC,2BAAb,CAAwC;AAEtChB,cAA6BC,OAA7B,EAAoD;AAAvB;AAA2B;;AAExDgB,cAAY,CAACf,UAAD,EAAiB;AAC3B,WAAO,IAAIJ,oBAAJ,CAAyB,KAAKG,OAA9B,EAAuCC,UAAvC,CAAP;AACD;;AANqC;;AAAxCa","names":["MaxMessageSizeFilter","filter_1","constructor","options","callStream","constants_1","maxSendMessageSize","maxReceiveMessageSize","sendMessage","message","concreteMessage","length","cancelWithStatus","RESOURCE_EXHAUSTED","Promise","reject","receiveMessage","exports","MaxMessageSizeFilterFactory","createFilter"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/max-message-size-filter.ts"],"sourcesContent":["/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport { Call, WriteObject } from './call-stream';\nimport {\n  Status,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n} from './constants';\nimport { ChannelOptions } from './channel-options';\n\nexport class MaxMessageSizeFilter extends BaseFilter implements Filter {\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n  constructor(\n    private readonly options: ChannelOptions,\n    private readonly callStream: Call\n  ) {\n    super();\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n  }\n\n  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxSendMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n      if (concreteMessage.message.length > this.maxSendMessageSize) {\n        this.callStream.cancelWithStatus(\n          Status.RESOURCE_EXHAUSTED,\n          `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`\n        );\n        return Promise.reject<WriteObject>('Message too large');\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n\n  async receiveMessage(message: Promise<Buffer>): Promise<Buffer> {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxReceiveMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n      if (concreteMessage.length > this.maxReceiveMessageSize) {\n        this.callStream.cancelWithStatus(\n          Status.RESOURCE_EXHAUSTED,\n          `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`\n        );\n        return Promise.reject<Buffer>('Message too large');\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n}\n\nexport class MaxMessageSizeFilterFactory\n  implements FilterFactory<MaxMessageSizeFilter> {\n  constructor(private readonly options: ChannelOptions) {}\n\n  createFilter(callStream: Call): MaxMessageSizeFilter {\n    return new MaxMessageSizeFilter(this.options, callStream);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}