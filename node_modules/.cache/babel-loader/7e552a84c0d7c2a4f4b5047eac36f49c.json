{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProxiedConnection = exports.mapProxyName = void 0;\n\nconst logging_1 = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst http = require(\"http\");\n\nconst tls = require(\"tls\");\n\nconst logging = require(\"./logging\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst url_1 = require(\"url\");\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n\n  let proxyUrl;\n\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n\n  if (proxyUrl.protocol !== 'http:') {\n    logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n\n  let userCred = null;\n\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n\n  if (port === '') {\n    port = '80';\n  }\n\n  const result = {\n    address: `${hostname}:${port}`\n  };\n\n  if (userCred) {\n    result.creds = userCred;\n  }\n\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\n\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nfunction mapProxyName(target, options) {\n  var _a;\n\n  const noProxyResult = {\n    target: target,\n    extraOptions: {}\n  };\n\n  if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n    return noProxyResult;\n  }\n\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n\n  const proxyInfo = getProxyInfo();\n\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n\n  const hostPort = uri_parser_1.splitHostPort(target.path);\n\n  if (!hostPort) {\n    return noProxyResult;\n  }\n\n  const serverHost = hostPort.host;\n\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));\n      return noProxyResult;\n    }\n  }\n\n  const extraOptions = {\n    'grpc.http_connect_target': uri_parser_1.uriToString(target)\n  };\n\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address\n    },\n    extraOptions: extraOptions\n  };\n}\n\nexports.mapProxyName = mapProxyName;\n\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve({});\n  }\n\n  const realTarget = channelOptions['grpc.http_connect_target'];\n  const parsedTarget = uri_parser_1.parseUri(realTarget);\n\n  if (parsedTarget === null) {\n    return Promise.resolve({});\n  }\n\n  const options = {\n    method: 'CONNECT',\n    path: parsedTarget.path\n  };\n  const headers = {\n    Host: parsedTarget.path\n  }; // Connect to the subchannel address as a proxy\n\n  if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n  }\n\n  options.headers = headers;\n  const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      var _a;\n\n      request.removeAllListeners();\n      socket.removeAllListeners();\n\n      if (res.statusCode === 200) {\n        trace('Successfully connected to ' + options.path + ' through proxy ' + proxyAddressString);\n\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n          const cts = tls.connect(Object.assign({\n            host: remoteHost,\n            servername: remoteHost,\n            socket: socket\n          }, connectionOptions), () => {\n            trace('Successfully established a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString);\n            resolve({\n              socket: cts,\n              realTarget: parsedTarget\n            });\n          });\n          cts.on('error', error => {\n            trace('Failed to establish a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString + ' with error ' + error.message);\n            reject();\n          });\n        } else {\n          trace('Successfully established a plaintext connection to ' + options.path + ' through proxy ' + proxyAddressString);\n          resolve({\n            socket,\n            realTarget: parsedTarget\n          });\n        }\n      } else {\n        logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' + options.path + ' through proxy ' + proxyAddressString + ' with status ' + res.statusCode);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' + proxyAddressString + ' with error ' + err.message);\n      reject();\n    });\n    request.end();\n  });\n}\n\nexports.getProxiedConnection = getProxiedConnection;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","trace","text","logging","constants_1","DEBUG","getProxyInfo","proxyEnv","envVar","process","env","grpc_proxy","https_proxy","http_proxy","proxyUrl","url_1","e","logging_1","ERROR","protocol","userCred","username","password","INFO","hostname","port","result","address","creds","getNoProxyHostList","noProxyStr","no_grpc_proxy","no_proxy","split","mapProxyName","target","options","noProxyResult","extraOptions","_a","scheme","proxyInfo","hostPort","uri_parser_1","path","serverHost","host","exports","getProxiedConnection","channelOptions","connectionOptions","Promise","resolve","realTarget","parsedTarget","method","headers","Host","subchannel_address_1","socketPath","Buffer","from","toString","proxyAddressString","reject","request","http","once","res","socket","head","removeAllListeners","statusCode","targetPath","resolver_1","remoteHost","cts","tls","connect","Object","servername","on","error","message","err","end"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/http_proxy.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nimport { getDefaultAuthority } from './resolver';\nimport { Socket } from 'net';\nimport * as http from 'http';\nimport * as tls from 'tls';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { URL } from 'url';\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface ProxyInfo {\n  address?: string;\n  creds?: string;\n}\n\nfunction getProxyInfo(): ProxyInfo {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl: URL;\n  try {\n    proxyUrl = new URL(proxyEnv);\n  } catch (e) {\n    log(LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    log(\n      LogVerbosity.ERROR,\n      `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`\n    );\n    return {};\n  }\n  let userCred: string | null = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      log(LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result: ProxyInfo = {\n    address: `${hostname}:${port}`,\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace(\n    'Proxy server ' + result.address + ' set by environment variable ' + envVar\n  );\n  return result;\n}\n\nfunction getNoProxyHostList(): string[] {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr: string | undefined = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nexport interface ProxyMapResult {\n  target: GrpcUri;\n  extraOptions: ChannelOptions;\n}\n\nexport function mapProxyName(\n  target: GrpcUri,\n  options: ChannelOptions\n): ProxyMapResult {\n  const noProxyResult: ProxyMapResult = {\n    target: target,\n    extraOptions: {},\n  };\n  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = splitHostPort(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace(\n        'Not using proxy for target in no_proxy list: ' + uriToString(target)\n      );\n      return noProxyResult;\n    }\n  }\n  const extraOptions: ChannelOptions = {\n    'grpc.http_connect_target': uriToString(target),\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address,\n    },\n    extraOptions: extraOptions,\n  };\n}\n\nexport interface ProxyConnectionResult {\n  socket?: Socket;\n  realTarget?: GrpcUri;\n}\n\nexport function getProxiedConnection(\n  address: SubchannelAddress,\n  channelOptions: ChannelOptions,\n  connectionOptions: tls.ConnectionOptions\n): Promise<ProxyConnectionResult> {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'] as string;\n  const parsedTarget = parseUri(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const options: http.RequestOptions = {\n    method: 'CONNECT',\n    path: parsedTarget.path,\n  };\n  const headers: http.OutgoingHttpHeaders = {\n    Host: parsedTarget.path,\n  };\n  // Connect to the subchannel address as a proxy\n  if (isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] =\n      'Basic ' +\n      Buffer.from(\n        channelOptions['grpc.http_connect_creds'] as string\n      ).toString('base64');\n  }\n  options.headers = headers\n  const proxyAddressString = subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise<ProxyConnectionResult>((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace(\n          'Successfully connected to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString\n        );\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = getDefaultAuthority(parsedTarget);\n          const hostPort = splitHostPort(targetPath);\n          const remoteHost = hostPort?.host ?? targetPath;\n\n          const cts = tls.connect(\n            {\n              host: remoteHost,\n              servername: remoteHost,\n              socket: socket,\n              ...connectionOptions,\n            },\n            () => {\n              trace(\n                'Successfully established a TLS connection to ' +\n                  options.path +\n                  ' through proxy ' +\n                  proxyAddressString\n              );\n              resolve({ socket: cts, realTarget: parsedTarget });\n            }\n          );\n          cts.on('error', (error: Error) => {\n            trace('Failed to establish a TLS connection to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with error ' +\n                    error.message);\n            reject();\n          });\n        } else {\n          trace(\n            'Successfully established a plaintext connection to ' +\n              options.path +\n              ' through proxy ' +\n              proxyAddressString\n          );\n          resolve({\n            socket,\n            realTarget: parsedTarget,\n          });\n        }\n      } else {\n        log(\n          LogVerbosity.ERROR,\n          'Failed to connect to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString +\n            ' with status ' +\n            res.statusCode\n        );\n        reject();\n      }\n    });\n    request.once('error', (err) => {\n      request.removeAllListeners();\n      log(\n        LogVerbosity.ERROR,\n        'Failed to connect to proxy ' +\n          proxyAddressString +\n          ' with error ' +\n          err.message\n      );\n      reject();\n    });\n    request.end();\n  });\n}\n"]},"metadata":{},"sourceType":"script"}