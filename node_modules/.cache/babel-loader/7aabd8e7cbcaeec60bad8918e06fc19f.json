{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResolvingLoadBalancer = void 0;\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst service_config_1 = require(\"./service-config\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst picker_1 = require(\"./picker\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst logging = require(\"./logging\");\n\nconst constants_2 = require(\"./constants\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\n\nconst TRACER_NAME = 'resolving_load_balancer';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\n\nfunction getDefaultConfigSelector(serviceConfig) {\n  return function defaultConfigSelector(methodName, metadata) {\n    var _a, _b;\n\n    const splitName = methodName.split('/').filter(x => x.length > 0);\n    const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n    const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n\n    if (serviceConfig && serviceConfig.methodConfig) {\n      for (const methodConfig of serviceConfig.methodConfig) {\n        for (const name of methodConfig.name) {\n          if (name.service === service && (name.method === undefined || name.method === method)) {\n            return {\n              methodConfig: methodConfig,\n              pickInformation: {},\n              status: constants_1.Status.OK,\n              dynamicFilterFactories: []\n            };\n          }\n        }\n      }\n    }\n\n    return {\n      methodConfig: {\n        name: []\n      },\n      pickInformation: {},\n      status: constants_1.Status.OK,\n      dynamicFilterFactories: []\n    };\n  };\n}\n\nclass ResolvingLoadBalancer {\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n    this.target = target;\n    this.channelControlHelper = channelControlHelper;\n    this.channelOptions = channelOptions;\n    this.onSuccessfulResolution = onSuccessfulResolution;\n    this.onFailedResolution = onFailedResolution;\n    this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n    this.latestChildPicker = new picker_1.QueuePicker(this);\n    /**\n     * This resolving load balancer's current connectivity state.\n     */\n\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The service config object from the last successful resolution, if\n     * available. A value of null indicates that we have not yet received a valid\n     * service config from the resolver.\n     */\n\n    this.previousServiceConfig = null;\n    /**\n     * Indicates whether we should attempt to resolve again after the backoff\n     * timer runs out.\n     */\n\n    this.continueResolving = false;\n\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions['grpc.service_config']));\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: []\n      };\n    }\n\n    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n      createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState, picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      },\n      addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n      removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n    });\n    this.innerResolver = resolver_1.createResolver(target, {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n        var _a;\n\n        let workingServiceConfig = null;\n        /* This first group of conditionals implements the algorithm described\n         * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n         * in the section called \"Behavior on receiving a new gRPC Config\".\n         */\n\n        if (serviceConfig === null) {\n          // Step 4 and 5\n          if (serviceConfigError === null) {\n            // Step 5\n            this.previousServiceConfig = null;\n            workingServiceConfig = this.defaultServiceConfig;\n          } else {\n            // Step 4\n            if (this.previousServiceConfig === null) {\n              // Step 4.ii\n              this.handleResolutionFailure(serviceConfigError);\n            } else {\n              // Step 4.i\n              workingServiceConfig = this.previousServiceConfig;\n            }\n          }\n        } else {\n          // Step 3\n          workingServiceConfig = serviceConfig;\n          this.previousServiceConfig = serviceConfig;\n        }\n\n        const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n        const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n\n        if (loadBalancingConfig === null) {\n          // There were load balancing configs but none are supported. This counts as a resolution failure\n          this.handleResolutionFailure({\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'All load balancer options in service config are not compatible',\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n\n        this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n        const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n        this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n      },\n      onError: error => {\n        this.handleResolutionFailure(error);\n      }\n    }, channelOptions);\n    const backoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n  }\n\n  updateResolution() {\n    this.innerResolver.updateResolution();\n\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateState(connectivityState, picker) {\n    trace(uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[connectivityState]); // Ensure that this.exitIdle() is called by the picker\n\n    if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n      picker = new picker_1.QueuePicker(this);\n    }\n\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n\n  handleResolutionFailure(error) {\n    if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n      this.onFailedResolution(error);\n    }\n\n    this.backoffTimeout.runOnce();\n  }\n\n  exitIdle() {\n    this.childLoadBalancer.exitIdle();\n\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateAddressList(addressList, lbConfig) {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n  }\n\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n\n}\n\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","trace","text","logging","constants_2","DEBUG","DEFAULT_LOAD_BALANCER_NAME","getDefaultConfigSelector","serviceConfig","defaultConfigSelector","methodName","metadata","splitName","split","filter","x","length","service","_a","method","_b","methodConfig","name","undefined","pickInformation","status","constants_1","OK","dynamicFilterFactories","ResolvingLoadBalancer","constructor","target","channelControlHelper","channelOptions","onSuccessfulResolution","onFailedResolution","connectivity_state_1","IDLE","picker_1","defaultServiceConfig","service_config_1","JSON","parse","loadBalancingConfig","updateState","childLoadBalancer","load_balancer_child_handler_1","createSubchannel","bind","requestReresolution","backoffTimeout","isRunning","continueResolving","updateResolution","newState","picker","latestChildState","latestChildPicker","addChannelzChild","removeChannelzChild","innerResolver","resolver_1","addressList","serviceConfigError","configSelector","attributes","workingServiceConfig","previousServiceConfig","handleResolutionFailure","workingConfigList","load_balancer_1","code","UNAVAILABLE","details","metadata_1","updateAddressList","finalServiceConfig","onError","error","backoffOptions","initialDelay","maxDelay","backoff_timeout_1","unref","currentState","CONNECTING","connectivityState","uri_parser_1","TRANSIENT_FAILURE","runOnce","exitIdle","lbConfig","Error","resetBackoff","reset","destroy","SHUTDOWN","getTypeName","exports"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/resolving-load-balancer.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ChannelControlHelper,\n  LoadBalancer,\n  LoadBalancingConfig,\n  getFirstUsableConfig,\n} from './load-balancer';\nimport { ServiceConfig, validateServiceConfig } from './service-config';\nimport { ConnectivityState } from './connectivity-state';\nimport { ConfigSelector, createResolver, Resolver } from './resolver';\nimport { ServiceError } from './call';\nimport { Picker, UnavailablePicker, QueuePicker } from './picker';\nimport { BackoffOptions, BackoffTimeout } from './backoff-timeout';\nimport { Status } from './constants';\nimport { StatusObject } from './call-stream';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChildLoadBalancerHandler } from './load-balancer-child-handler';\nimport { ChannelOptions } from './channel-options';\nimport { PickFirstLoadBalancingConfig } from './load-balancer-pick-first';\n\nconst TRACER_NAME = 'resolving_load_balancer';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\n\nfunction getDefaultConfigSelector(\n  serviceConfig: ServiceConfig | null\n): ConfigSelector {\n  return function defaultConfigSelector(\n    methodName: string,\n    metadata: Metadata\n  ) {\n    const splitName = methodName.split('/').filter((x) => x.length > 0);\n    const service = splitName[0] ?? '';\n    const method = splitName[1] ?? '';\n    if (serviceConfig && serviceConfig.methodConfig) {\n      for (const methodConfig of serviceConfig.methodConfig) {\n        for (const name of methodConfig.name) {\n          if (\n            name.service === service &&\n            (name.method === undefined || name.method === method)\n          ) {\n            return {\n              methodConfig: methodConfig,\n              pickInformation: {},\n              status: Status.OK,\n              dynamicFilterFactories: []\n            };\n          }\n        }\n      }\n    }\n    return {\n      methodConfig: { name: [] },\n      pickInformation: {},\n      status: Status.OK,\n      dynamicFilterFactories: []\n    };\n  };\n}\n\nexport interface ResolutionCallback {\n  (configSelector: ConfigSelector): void;\n}\n\nexport interface ResolutionFailureCallback {\n  (status: StatusObject): void;\n}\n\nexport class ResolvingLoadBalancer implements LoadBalancer {\n  /**\n   * The resolver class constructed for the target address.\n   */\n  private innerResolver: Resolver;\n\n  private childLoadBalancer: ChildLoadBalancerHandler;\n  private latestChildState: ConnectivityState = ConnectivityState.IDLE;\n  private latestChildPicker: Picker = new QueuePicker(this);\n  /**\n   * This resolving load balancer's current connectivity state.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  private readonly defaultServiceConfig: ServiceConfig;\n  /**\n   * The service config object from the last successful resolution, if\n   * available. A value of null indicates that we have not yet received a valid\n   * service config from the resolver.\n   */\n  private previousServiceConfig: ServiceConfig | null = null;\n\n  /**\n   * The backoff timer for handling name resolution failures.\n   */\n  private readonly backoffTimeout: BackoffTimeout;\n\n  /**\n   * Indicates whether we should attempt to resolve again after the backoff\n   * timer runs out.\n   */\n  private continueResolving = false;\n\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(\n    private readonly target: GrpcUri,\n    private readonly channelControlHelper: ChannelControlHelper,\n    private readonly channelOptions: ChannelOptions,\n    private readonly onSuccessfulResolution: ResolutionCallback,\n    private readonly onFailedResolution: ResolutionFailureCallback\n  ) {\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = validateServiceConfig(\n        JSON.parse(channelOptions['grpc.service_config']!)\n      );\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n      };\n    }\n    this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    this.childLoadBalancer = new ChildLoadBalancerHandler({\n      createSubchannel: channelControlHelper.createSubchannel.bind(\n        channelControlHelper\n      ),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState: ConnectivityState, picker: Picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      },\n      addChannelzChild: channelControlHelper.addChannelzChild.bind(\n        channelControlHelper\n      ),\n      removeChannelzChild: channelControlHelper.removeChannelzChild.bind(\n        channelControlHelper\n      )\n    });\n    this.innerResolver = createResolver(\n      target,\n      {\n        onSuccessfulResolution: (\n          addressList: SubchannelAddress[],\n          serviceConfig: ServiceConfig | null,\n          serviceConfigError: ServiceError | null,\n          configSelector: ConfigSelector | null,\n          attributes: { [key: string]: unknown }\n        ) => {\n          let workingServiceConfig: ServiceConfig | null = null;\n          /* This first group of conditionals implements the algorithm described\n           * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n           * in the section called \"Behavior on receiving a new gRPC Config\".\n           */\n          if (serviceConfig === null) {\n            // Step 4 and 5\n            if (serviceConfigError === null) {\n              // Step 5\n              this.previousServiceConfig = null;\n              workingServiceConfig = this.defaultServiceConfig;\n            } else {\n              // Step 4\n              if (this.previousServiceConfig === null) {\n                // Step 4.ii\n                this.handleResolutionFailure(serviceConfigError);\n              } else {\n                // Step 4.i\n                workingServiceConfig = this.previousServiceConfig;\n              }\n            }\n          } else {\n            // Step 3\n            workingServiceConfig = serviceConfig;\n            this.previousServiceConfig = serviceConfig;\n          }\n          const workingConfigList =\n            workingServiceConfig?.loadBalancingConfig ?? [];\n          const loadBalancingConfig = getFirstUsableConfig(\n            workingConfigList,\n            true\n          );\n          if (loadBalancingConfig === null) {\n            // There were load balancing configs but none are supported. This counts as a resolution failure\n            this.handleResolutionFailure({\n              code: Status.UNAVAILABLE,\n              details:\n                'All load balancer options in service config are not compatible',\n              metadata: new Metadata(),\n            });\n            return;\n          }\n          this.childLoadBalancer.updateAddressList(\n            addressList,\n            loadBalancingConfig,\n            attributes\n          );\n          const finalServiceConfig =\n            workingServiceConfig ?? this.defaultServiceConfig;\n          this.onSuccessfulResolution(\n            configSelector ?? getDefaultConfigSelector(finalServiceConfig)\n          );\n        },\n        onError: (error: StatusObject) => {\n          this.handleResolutionFailure(error);\n        },\n      },\n      channelOptions\n    );\n    const backoffOptions: BackoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n  }\n\n  private updateResolution() {\n    this.innerResolver.updateResolution();\n    if (this.currentState === ConnectivityState.IDLE) {\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    }\n  }\n\n  private updateState(connectivityState: ConnectivityState, picker: Picker) {\n    trace(\n      uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[connectivityState]\n    );\n    // Ensure that this.exitIdle() is called by the picker\n    if (connectivityState === ConnectivityState.IDLE) {\n      picker = new QueuePicker(this);\n    }\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n\n  private handleResolutionFailure(error: StatusObject) {\n    if (this.latestChildState === ConnectivityState.IDLE) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker(error)\n      );\n      this.onFailedResolution(error);\n    }\n    this.backoffTimeout.runOnce();\n  }\n\n  exitIdle() {\n    this.childLoadBalancer.exitIdle();\n    if (this.currentState === ConnectivityState.IDLE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    }\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig | null\n  ): never {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN, new UnavailablePicker());\n  }\n\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n}\n"]},"metadata":{},"sourceType":"script"}