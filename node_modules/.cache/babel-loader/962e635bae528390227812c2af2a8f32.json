{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst camelCase = require(\"lodash.camelcase\");\n\nconst Protobuf = require(\"protobufjs\");\n\nconst descriptor = require(\"protobufjs/ext/descriptor\");\n\nconst util_1 = require(\"./util\");\n\nfunction isAnyExtension(obj) {\n  return '@type' in obj && typeof obj['@type'] === 'string';\n}\n\nexports.isAnyExtension = isAnyExtension;\nconst descriptorOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  defaults: true,\n  oneofs: true,\n  json: true\n};\n\nfunction joinName(baseName, name) {\n  if (baseName === '') {\n    return name;\n  } else {\n    return baseName + '.' + name;\n  }\n}\n\nfunction isHandledReflectionObject(obj) {\n  return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\n\nfunction isNamespaceBase(obj) {\n  return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\n\nfunction getAllHandledReflectionObjects(obj, parentName) {\n  const objName = joinName(parentName, obj.name);\n\n  if (isHandledReflectionObject(obj)) {\n    return [[objName, obj]];\n  } else {\n    if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n      return Object.keys(obj.nested).map(name => {\n        return getAllHandledReflectionObjects(obj.nested[name], objName);\n      }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n    }\n  }\n\n  return [];\n}\n\nfunction createDeserializer(cls, options) {\n  return function deserialize(argBuf) {\n    return cls.toObject(cls.decode(argBuf), options);\n  };\n}\n\nfunction createSerializer(cls) {\n  return function serialize(arg) {\n    if (Array.isArray(arg)) {\n      throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n    }\n\n    const message = cls.fromObject(arg);\n    return cls.encode(message).finish();\n  };\n}\n\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n  /* This is only ever called after the corresponding root.resolveAll(), so we\n   * can assume that the resolved request and response types are non-null */\n  const requestType = method.resolvedRequestType;\n  const responseType = method.resolvedResponseType;\n  return {\n    path: '/' + serviceName + '/' + method.name,\n    requestStream: !!method.requestStream,\n    responseStream: !!method.responseStream,\n    requestSerialize: createSerializer(requestType),\n    requestDeserialize: createDeserializer(requestType, options),\n    responseSerialize: createSerializer(responseType),\n    responseDeserialize: createDeserializer(responseType, options),\n    // TODO(murgatroid99): Find a better way to handle this\n    originalName: camelCase(method.name),\n    requestType: createMessageDefinition(requestType, fileDescriptors),\n    responseType: createMessageDefinition(responseType, fileDescriptors)\n  };\n}\n\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n  const def = {};\n\n  for (const method of service.methodsArray) {\n    def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n  }\n\n  return def;\n}\n\nfunction createMessageDefinition(message, fileDescriptors) {\n  const messageDescriptor = message.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 DescriptorProto',\n    type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\n\nfunction createEnumDefinition(enumType, fileDescriptors) {\n  const enumDescriptor = enumType.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 EnumDescriptorProto',\n    type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\n\n\nfunction createDefinition(obj, name, options, fileDescriptors) {\n  if (obj instanceof Protobuf.Service) {\n    return createServiceDefinition(obj, name, options, fileDescriptors);\n  } else if (obj instanceof Protobuf.Type) {\n    return createMessageDefinition(obj, fileDescriptors);\n  } else if (obj instanceof Protobuf.Enum) {\n    return createEnumDefinition(obj, fileDescriptors);\n  } else {\n    throw new Error('Type mismatch in reflection object handling');\n  }\n}\n\nfunction createPackageDefinition(root, options) {\n  const def = {};\n  root.resolveAll();\n  const descriptorList = root.toDescriptor('proto3').file;\n  const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n\n  for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n    def[name] = createDefinition(obj, name, options, bufferList);\n  }\n\n  return def;\n}\n\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n  options = options || {};\n  const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n  root.resolveAll();\n  return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\n\n\nfunction load(filename, options) {\n  return util_1.loadProtosWithOptions(filename, options).then(loadedRoot => {\n    return createPackageDefinition(loadedRoot, options);\n  });\n}\n\nexports.load = load;\n\nfunction loadSync(filename, options) {\n  const loadedRoot = util_1.loadProtosWithOptionsSync(filename, options);\n  return createPackageDefinition(loadedRoot, options);\n}\n\nexports.loadSync = loadSync;\n\nfunction fromJSON(json, options) {\n  options = options || {};\n  const loadedRoot = Protobuf.Root.fromJSON(json);\n  loadedRoot.resolveAll();\n  return createPackageDefinition(loadedRoot, options);\n}\n\nexports.fromJSON = fromJSON;\n\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\n\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\n\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\n\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\nutil_1.addCommonProtos();","map":{"version":3,"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js"],"names":["Object","defineProperty","exports","value","camelCase","require","Protobuf","descriptor","util_1","isAnyExtension","obj","descriptorOptions","longs","String","enums","bytes","defaults","oneofs","json","joinName","baseName","name","isHandledReflectionObject","Service","Type","Enum","isNamespaceBase","Namespace","Root","getAllHandledReflectionObjects","parentName","objName","nested","keys","map","reduce","accumulator","currentValue","concat","createDeserializer","cls","options","deserialize","argBuf","toObject","decode","createSerializer","serialize","arg","Array","isArray","Error","message","fromObject","encode","finish","createMethodDefinition","method","serviceName","fileDescriptors","requestType","resolvedRequestType","responseType","resolvedResponseType","path","requestStream","responseStream","requestSerialize","requestDeserialize","responseSerialize","responseDeserialize","originalName","createMessageDefinition","createServiceDefinition","service","def","methodsArray","messageDescriptor","toDescriptor","format","type","$type","fileDescriptorProtos","createEnumDefinition","enumType","enumDescriptor","createDefinition","createPackageDefinition","root","resolveAll","descriptorList","file","bufferList","Buffer","from","FileDescriptorProto","createPackageDefinitionFromDescriptorSet","decodedDescriptorSet","fromDescriptor","load","filename","loadProtosWithOptions","then","loadedRoot","loadSync","loadProtosWithOptionsSync","fromJSON","loadFileDescriptorSetFromBuffer","descriptorSet","FileDescriptorSet","loadFileDescriptorSetFromObject","addCommonProtos"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst camelCase = require(\"lodash.camelcase\");\nconst Protobuf = require(\"protobufjs\");\nconst descriptor = require(\"protobufjs/ext/descriptor\");\nconst util_1 = require(\"./util\");\nfunction isAnyExtension(obj) {\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\n}\nexports.isAnyExtension = isAnyExtension;\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    return util_1.loadProtosWithOptions(filename, options).then(loadedRoot => {\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = util_1.loadProtosWithOptionsSync(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\nutil_1.addCommonProtos();\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}