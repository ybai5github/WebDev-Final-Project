{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst constants_1 = require(\"./constants\");\n\nconst duration_1 = require(\"./duration\");\n\nconst experimental_1 = require(\"./experimental\");\n\nconst filter_1 = require(\"./filter\");\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\n\nconst picker_1 = require(\"./picker\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst subchannel_interface_1 = require(\"./subchannel-interface\");\n\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION === 'true';\nconst defaultSuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n  threshold: 85,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 50\n};\n\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n  }\n}\n\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n\n  if (fieldName in obj) {\n    if (!duration_1.isDuration(obj[fieldName])) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n    }\n\n    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n    }\n  }\n}\n\nfunction validatePercentage(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n  }\n}\n\nclass OutlierDetectionLoadBalancingConfig {\n  constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n    this.childPolicy = childPolicy;\n    this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n    this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n    this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n    this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n  }\n\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n\n  toJsonObject() {\n    return {\n      interval: duration_1.msToDuration(this.intervalMs),\n      base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),\n      max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n    };\n  }\n\n  getIntervalMs() {\n    return this.intervalMs;\n  }\n\n  getBaseEjectionTimeMs() {\n    return this.baseEjectionTimeMs;\n  }\n\n  getMaxEjectionTimeMs() {\n    return this.maxEjectionTimeMs;\n  }\n\n  getMaxEjectionPercent() {\n    return this.maxEjectionPercent;\n  }\n\n  getSuccessRateEjectionConfig() {\n    return this.successRateEjection;\n  }\n\n  getFailurePercentageEjectionConfig() {\n    return this.failurePercentageEjection;\n  }\n\n  getChildPolicy() {\n    return this.childPolicy;\n  }\n\n  copyWithChildPolicy(childPolicy) {\n    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n  }\n\n  static createFromJson(obj) {\n    var _a;\n\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error('outlier detection config success_rate_ejection must be an object');\n      }\n\n      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n    }\n\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error('outlier detection config failure_percentage_ejection must be an object');\n      }\n\n      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n    }\n\n    return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n  }\n\n}\n\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\n\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n  constructor(childSubchannel, mapEntry) {\n    super(childSubchannel);\n    this.mapEntry = mapEntry;\n    this.childSubchannelState = connectivity_state_1.ConnectivityState.IDLE;\n    this.stateListeners = [];\n    this.ejected = false;\n    this.refCount = 0;\n    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {\n      this.childSubchannelState = newState;\n\n      if (!this.ejected) {\n        for (const listener of this.stateListeners) {\n          listener(this, previousState, newState);\n        }\n      }\n    });\n  }\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n\n\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n\n\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n\n  eject() {\n    this.ejected = true;\n\n    for (const listener of this.stateListeners) {\n      listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n\n  uneject() {\n    this.ejected = false;\n\n    for (const listener of this.stateListeners) {\n      listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n    }\n  }\n\n  getMapEntry() {\n    return this.mapEntry;\n  }\n\n  getWrappedSubchannel() {\n    return this.child;\n  }\n\n}\n\nfunction createEmptyBucket() {\n  return {\n    success: 0,\n    failure: 0\n  };\n}\n\nclass CallCounter {\n  constructor() {\n    this.activeBucket = createEmptyBucket();\n    this.inactiveBucket = createEmptyBucket();\n  }\n\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n\n}\n\nclass OutlierDetectionCounterFilter extends filter_1.BaseFilter {\n  constructor(callCounter) {\n    super();\n    this.callCounter = callCounter;\n  }\n\n  receiveTrailers(status) {\n    if (status.code === constants_1.Status.OK) {\n      this.callCounter.addSuccess();\n    } else {\n      this.callCounter.addFailure();\n    }\n\n    return status;\n  }\n\n}\n\nclass OutlierDetectionCounterFilterFactory {\n  constructor(callCounter) {\n    this.callCounter = callCounter;\n  }\n\n  createFilter(callStream) {\n    return new OutlierDetectionCounterFilter(this.callCounter);\n  }\n\n}\n\nclass OutlierDetectionPicker {\n  constructor(wrappedPicker) {\n    this.wrappedPicker = wrappedPicker;\n  }\n\n  pick(pickArgs) {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n\n    if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n      const subchannelWrapper = wrappedPick.subchannel;\n      const mapEntry = subchannelWrapper.getMapEntry();\n\n      if (mapEntry) {\n        return Object.assign(Object.assign({}, wrappedPick), {\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          extraFilterFactories: [...wrappedPick.extraFilterFactories, new OutlierDetectionCounterFilterFactory(mapEntry.counter)]\n        });\n      } else {\n        return wrappedPick;\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n\n}\n\nclass OutlierDetectionLoadBalancer {\n  constructor(channelControlHelper) {\n    this.addressMap = new Map();\n    this.latestConfig = null;\n    this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n        const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));\n        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n        mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n        return subchannelWrapper;\n      },\n      updateState: (connectivityState, picker) => {\n        if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker));\n        } else {\n          channelControlHelper.updateState(connectivityState, picker);\n        }\n      }\n    }));\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n\n  getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n\n    return ejectionCount * 100 / this.addressMap.size;\n  }\n\n  runSuccessRateCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n\n    if (!successRateConfig) {\n      return;\n    } // Step 1\n\n\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates = [];\n\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes / (successes + failures));\n      }\n    }\n\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    } // Step 2\n\n\n    const successRateMean = successRates.reduce((a, b) => a + b);\n    let successRateVariance = 0;\n\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateVariance += deviation * deviation;\n    }\n\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000); // Step 3\n\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 3.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      } // Step 3.ii\n\n\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      } // Step 3.iii\n\n\n      const successRate = successes / (successes + failures);\n\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  runFailurePercentageCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n\n    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n\n    if (!failurePercentageConfig) {\n      return;\n    } // Step 1\n\n\n    if (this.addressMap.size < failurePercentageConfig.minimum_hosts) {\n      return;\n    } // Step 2\n\n\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 2.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      } // Step 2.ii\n\n\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      } // Step 2.iii\n\n\n      const failurePercentage = failures * 100 / (failures + successes);\n\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  eject(mapEntry, ejectionTimestamp) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n\n  uneject(mapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n\n  runChecks() {\n    const ejectionTimestamp = new Date();\n\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n\n    if (!this.latestConfig) {\n      return;\n    }\n\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n\n        if (returnTime < new Date()) {\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n\n  updateAddressList(addressList, lbConfig, attributes) {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n\n    const subchannelAddresses = new Set();\n\n    for (const address of addressList) {\n      subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));\n    }\n\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: []\n        });\n      }\n    }\n\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        this.addressMap.delete(key);\n      }\n    }\n\n    const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n\n    if (this.latestConfig === null || this.latestConfig.getIntervalMs() !== lbConfig.getIntervalMs()) {\n      clearInterval(this.ejectionTimer);\n      this.ejectionTimer = setInterval(() => this.runChecks(), lbConfig.getIntervalMs());\n    }\n\n    this.latestConfig = lbConfig;\n  }\n\n  exitIdle() {\n    this.childBalancer.exitIdle();\n  }\n\n  resetBackoff() {\n    this.childBalancer.resetBackoff();\n  }\n\n  destroy() {\n    this.childBalancer.destroy();\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n}\n\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\n\nfunction setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n  }\n}\n\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["TYPE_NAME","OUTLIER_DETECTION_ENABLED","process","env","GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION","defaultSuccessRateEjectionConfig","stdev_factor","enforcement_percentage","minimum_hosts","request_volume","defaultFailurePercentageEjectionConfig","threshold","validateFieldType","obj","fieldName","expectedType","objectName","fullFieldName","Error","validatePositiveDuration","duration_1","seconds","nanos","validatePercentage","OutlierDetectionLoadBalancingConfig","constructor","intervalMs","baseEjectionTimeMs","maxEjectionTimeMs","maxEjectionPercent","successRateEjection","failurePercentageEjection","childPolicy","Object","getLoadBalancerName","toJsonObject","interval","base_ejection_time","max_ejection_time","max_ejection_percent","success_rate_ejection","failure_percentage_ejection","child_policy","map","policy","getIntervalMs","getBaseEjectionTimeMs","getMaxEjectionTimeMs","getMaxEjectionPercent","getSuccessRateEjectionConfig","getFailurePercentageEjectionConfig","getChildPolicy","copyWithChildPolicy","createFromJson","_a","load_balancer_1","exports","OutlierDetectionSubchannelWrapper","subchannel_interface_1","childSubchannel","mapEntry","connectivity_state_1","IDLE","addConnectivityStateListener","subchannel","previousState","newState","childSubchannelState","ejected","listener","stateListeners","push","removeConnectivityStateListener","listenerIndex","indexOf","splice","ref","child","refCount","unref","index","subchannelWrappers","eject","TRANSIENT_FAILURE","uneject","getMapEntry","getWrappedSubchannel","createEmptyBucket","success","failure","CallCounter","addSuccess","activeBucket","addFailure","switchBuckets","inactiveBucket","getLastSuccesses","getLastFailures","OutlierDetectionCounterFilter","filter_1","callCounter","receiveTrailers","status","code","constants_1","OK","OutlierDetectionCounterFilterFactory","createFilter","callStream","OutlierDetectionPicker","wrappedPicker","pick","pickArgs","wrappedPick","pickResultType","picker_1","COMPLETE","subchannelWrapper","extraFilterFactories","counter","OutlierDetectionLoadBalancer","channelControlHelper","Map","childBalancer","load_balancer_child_handler_1","experimental_1","createSubchannel","subchannelAddress","subchannelArgs","originalSubchannel","addressMap","get","subchannel_address_1","updateState","connectivityState","picker","READY","ejectionTimer","setInterval","clearInterval","getCurrentEjectionPercent","ejectionCount","values","currentEjectionTimestamp","size","runSuccessRateCheck","ejectionTimestamp","latestConfig","successRateConfig","targetRequestVolume","addresesWithTargetVolume","successRates","successes","failures","successRateMean","reduce","a","b","successRateVariance","rate","deviation","successRateStdev","Math","sqrt","ejectionThreshold","successRate","randomNumber","random","runFailurePercentageCheck","failurePercentageConfig","failurePercentage","Date","ejectionTimeMultiplier","runChecks","returnTime","getTime","setMilliseconds","getMilliseconds","min","max","updateAddressList","addressList","lbConfig","attributes","subchannelAddresses","Set","address","add","has","set","key","keys","delete","exitIdle","resetBackoff","destroy","getTypeName","setup"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/load-balancer-outlier-detection.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions, connectivityState, StatusObject } from \".\";\nimport { Call } from \"./call-stream\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { Status } from \"./constants\";\nimport { durationToMs, isDuration, msToDuration } from \"./duration\";\nimport { ChannelControlHelper, createChildChannelControlHelper, registerLoadBalancerType } from \"./experimental\";\nimport { BaseFilter, Filter, FilterFactory } from \"./filter\";\nimport { getFirstUsableConfig, LoadBalancer, LoadBalancingConfig, validateLoadBalancingConfig } from \"./load-balancer\";\nimport { ChildLoadBalancerHandler } from \"./load-balancer-child-handler\";\nimport { PickArgs, Picker, PickResult, PickResultType, QueuePicker, UnavailablePicker } from \"./picker\";\nimport { Subchannel } from \"./subchannel\";\nimport { SubchannelAddress, subchannelAddressToString } from \"./subchannel-address\";\nimport { BaseSubchannelWrapper, ConnectivityStateListener, SubchannelInterface } from \"./subchannel-interface\";\n\n\nconst TYPE_NAME = 'outlier_detection';\n\nconst OUTLIER_DETECTION_ENABLED = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION === 'true';\n\nexport interface SuccessRateEjectionConfig {\n  readonly stdev_factor: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nexport interface FailurePercentageEjectionConfig {\n  readonly threshold: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nconst defaultSuccessRateEjectionConfig: SuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100\n};\n\nconst defaultFailurePercentageEjectionConfig: FailurePercentageEjectionConfig = {\n  threshold: 85,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 50\n}\n\ntype TypeofValues = 'object' | 'boolean' | 'function' | 'number' | 'string' | 'undefined';\n\nfunction validateFieldType(obj: any, fieldName: string, expectedType: TypeofValues, objectName?: string) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n  }\n}\n\nfunction validatePositiveDuration(obj: any, fieldName: string, objectName?: string) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  if (fieldName in obj) {\n    if (!isDuration(obj[fieldName])) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n    }\n    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315_576_000_000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999_999_999)) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n    }\n  }\n}\n\nfunction validatePercentage(obj: any, fieldName: string, objectName?: string) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n  }\n}\n\nexport class OutlierDetectionLoadBalancingConfig implements LoadBalancingConfig {\n  private readonly intervalMs: number;\n  private readonly baseEjectionTimeMs: number;\n  private readonly maxEjectionTimeMs: number;\n  private readonly maxEjectionPercent: number;\n  private readonly successRateEjection: SuccessRateEjectionConfig | null;\n  private readonly failurePercentageEjection: FailurePercentageEjectionConfig | null;\n\n  constructor(\n    intervalMs: number | null,\n    baseEjectionTimeMs: number | null,\n    maxEjectionTimeMs: number | null,\n    maxEjectionPercent: number | null,\n    successRateEjection: Partial<SuccessRateEjectionConfig> | null,\n    failurePercentageEjection: Partial<FailurePercentageEjectionConfig> | null,\n    private readonly childPolicy: LoadBalancingConfig[]\n  ) {\n    this.intervalMs = intervalMs ?? 10_000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs ?? 30_000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs ?? 300_000;\n    this.maxEjectionPercent = maxEjectionPercent ?? 10;\n    this.successRateEjection = successRateEjection ? {...defaultSuccessRateEjectionConfig, ...successRateEjection} : null;\n    this.failurePercentageEjection = failurePercentageEjection ? {...defaultFailurePercentageEjectionConfig, ...failurePercentageEjection}: null;\n  }\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n  toJsonObject(): object {\n    return {\n      interval: msToDuration(this.intervalMs),\n      base_ejection_time: msToDuration(this.baseEjectionTimeMs),\n      max_ejection_time: msToDuration(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n    };\n  }\n\n  getIntervalMs(): number {\n    return this.intervalMs;\n  }\n  getBaseEjectionTimeMs(): number {\n    return this.baseEjectionTimeMs;\n  }\n  getMaxEjectionTimeMs(): number {\n    return this.maxEjectionTimeMs;\n  }\n  getMaxEjectionPercent(): number {\n    return this.maxEjectionPercent;\n  }\n  getSuccessRateEjectionConfig(): SuccessRateEjectionConfig | null {\n    return this.successRateEjection;\n  }\n  getFailurePercentageEjectionConfig(): FailurePercentageEjectionConfig | null {\n    return this.failurePercentageEjection;\n  }\n  getChildPolicy(): LoadBalancingConfig[] {\n    return this.childPolicy;\n  }\n\n  copyWithChildPolicy(childPolicy: LoadBalancingConfig[]): OutlierDetectionLoadBalancingConfig {\n    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n  }\n\n  static createFromJson(obj: any): OutlierDetectionLoadBalancingConfig {\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error('outlier detection config success_rate_ejection must be an object');\n      }\n      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n    }\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error('outlier detection config failure_percentage_ejection must be an object');\n      }\n      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n    }\n\n    return new OutlierDetectionLoadBalancingConfig(\n      obj.interval ? durationToMs(obj.interval) : null,\n      obj.base_ejection_time ? durationToMs(obj.base_ejection_time) : null,\n      obj.max_ejection_time ? durationToMs(obj.max_ejection_time) : null,\n      obj.max_ejection_percent ?? null,\n      obj.success_rate_ejection,\n      obj.failure_percentage_ejection,\n      obj.child_policy.map(validateLoadBalancingConfig)\n    );\n  }\n}\n\nclass OutlierDetectionSubchannelWrapper extends BaseSubchannelWrapper implements SubchannelInterface {\n  private childSubchannelState: ConnectivityState = ConnectivityState.IDLE;\n  private stateListeners: ConnectivityStateListener[] = [];\n  private ejected: boolean = false;\n  private refCount: number = 0;\n  constructor(childSubchannel: SubchannelInterface, private mapEntry?: MapEntry) {\n    super(childSubchannel);\n    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {\n      this.childSubchannelState = newState;\n      if (!this.ejected) {\n        for (const listener of this.stateListeners) {\n          listener(this, previousState, newState);\n        }\n      }\n    });\n  }\n\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n\n  eject() {\n    this.ejected = true;\n    for (const listener of this.stateListeners) {\n      listener(this, this.childSubchannelState, ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n\n  uneject() {\n    this.ejected = false;\n    for (const listener of this.stateListeners) {\n      listener(this, ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n    }\n  }\n\n  getMapEntry(): MapEntry | undefined {\n    return this.mapEntry;\n  }\n\n  getWrappedSubchannel(): SubchannelInterface {\n    return this.child;\n  }\n}\n\ninterface CallCountBucket {\n  success: number;\n  failure: number;\n}\n\nfunction createEmptyBucket(): CallCountBucket {\n  return {\n    success: 0,\n    failure: 0\n  }\n}\n\nclass CallCounter {\n  private activeBucket: CallCountBucket = createEmptyBucket();\n  private inactiveBucket: CallCountBucket = createEmptyBucket();\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n}\n\ninterface MapEntry {\n  counter: CallCounter;\n  currentEjectionTimestamp: Date | null;\n  ejectionTimeMultiplier: number;\n  subchannelWrappers: OutlierDetectionSubchannelWrapper[];\n}\n\nclass OutlierDetectionCounterFilter extends BaseFilter implements Filter {\n  constructor(private callCounter: CallCounter) {\n    super();\n  }\n  receiveTrailers(status: StatusObject): StatusObject {\n    if (status.code === Status.OK) {\n      this.callCounter.addSuccess();\n    } else {\n      this.callCounter.addFailure();\n    }\n    return status;\n  }\n}\n\nclass OutlierDetectionCounterFilterFactory implements FilterFactory<OutlierDetectionCounterFilter> {\n  constructor(private callCounter: CallCounter) {}\n  createFilter(callStream: Call): OutlierDetectionCounterFilter {\n    return new OutlierDetectionCounterFilter(this.callCounter);\n  }\n\n}\n\nclass OutlierDetectionPicker implements Picker {\n  constructor(private wrappedPicker: Picker) {}\n  pick(pickArgs: PickArgs): PickResult {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n    if (wrappedPick.pickResultType === PickResultType.COMPLETE) {\n      const subchannelWrapper = wrappedPick.subchannel as OutlierDetectionSubchannelWrapper;\n      const mapEntry = subchannelWrapper.getMapEntry();\n      if (mapEntry) {\n        return {\n          ...wrappedPick,\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          extraFilterFactories: [...wrappedPick.extraFilterFactories, new OutlierDetectionCounterFilterFactory(mapEntry.counter)]\n        };\n      } else {\n        return wrappedPick;\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n\n}\n\nexport class OutlierDetectionLoadBalancer implements LoadBalancer {\n  private childBalancer: ChildLoadBalancerHandler;\n  private addressMap: Map<string, MapEntry> = new Map<string, MapEntry>();\n  private latestConfig: OutlierDetectionLoadBalancingConfig | null = null;\n  private ejectionTimer: NodeJS.Timer;\n\n  constructor(channelControlHelper: ChannelControlHelper) {\n    this.childBalancer = new ChildLoadBalancerHandler(createChildChannelControlHelper(channelControlHelper, {\n      createSubchannel: (subchannelAddress: SubchannelAddress, subchannelArgs: ChannelOptions) => {\n        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n        const mapEntry = this.addressMap.get(subchannelAddressToString(subchannelAddress));\n        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n        mapEntry?.subchannelWrappers.push(subchannelWrapper);\n        return subchannelWrapper;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        if (connectivityState === ConnectivityState.READY) {\n          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker));\n        } else {\n          channelControlHelper.updateState(connectivityState, picker);\n        }\n      }\n    }));\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n\n  private getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n    return (ejectionCount * 100) / this.addressMap.size;\n  }\n\n  private runSuccessRateCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n    if (!successRateConfig) {\n      return;\n    }\n    // Step 1\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates: number[] = []\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes/(successes + failures));\n      }\n    }\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    }\n\n    // Step 2\n    const successRateMean = successRates.reduce((a, b) => a + b);\n    let successRateVariance = 0;\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateVariance += deviation * deviation;\n    }\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n\n    // Step 3\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 3.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 3.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      }\n      // Step 3.iii\n      const successRate = successes / (successes + failures);\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private runFailurePercentageCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig()\n    if (!failurePercentageConfig) {\n      return;\n    }\n    // Step 1\n    if (this.addressMap.size < failurePercentageConfig.minimum_hosts) {\n      return;\n    }\n    \n    // Step 2\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 2.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 2.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      }\n      // Step 2.iii\n      const failurePercentage = (failures * 100) / (failures + successes);\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private eject(mapEntry: MapEntry, ejectionTimestamp: Date) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n\n  private uneject(mapEntry: MapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n\n  private runChecks() {\n    const ejectionTimestamp = new Date();\n\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n\n    if (!this.latestConfig) {\n      return;\n    }\n\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n        if (returnTime < new Date()) {\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n\n  updateAddressList(addressList: SubchannelAddress[], lbConfig: LoadBalancingConfig, attributes: { [key: string]: unknown; }): void {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n    const subchannelAddresses = new Set<string>();\n    for (const address of addressList) {\n      subchannelAddresses.add(subchannelAddressToString(address));\n    }\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: []\n        });\n      }\n    }\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        this.addressMap.delete(key);\n      }\n    }\n    const childPolicy: LoadBalancingConfig = getFirstUsableConfig(\n      lbConfig.getChildPolicy(),\n      true\n    );\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n\n    if (this.latestConfig === null || this.latestConfig.getIntervalMs() !== lbConfig.getIntervalMs()) {\n      clearInterval(this.ejectionTimer);\n      this.ejectionTimer = setInterval(() => this.runChecks(), lbConfig.getIntervalMs());\n    }\n    this.latestConfig = lbConfig;\n  }\n  exitIdle(): void {\n    this.childBalancer.exitIdle();\n  }\n  resetBackoff(): void {\n    this.childBalancer.resetBackoff();\n  }\n  destroy(): void {\n    this.childBalancer.destroy();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n  }\n}"]},"metadata":{},"sourceType":"script"}