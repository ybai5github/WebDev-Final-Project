{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst picker_1 = require(\"./picker\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst TRACER_NAME = 'round_robin';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'round_robin';\n\nclass RoundRobinLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  static createFromJson(obj) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n\n}\n\nclass RoundRobinPicker {\n  constructor(subchannelList) {\n    let nextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.subchannelList = subchannelList;\n    this.nextIndex = nextIndex;\n  }\n\n  pick(pickArgs) {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null\n    };\n  }\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n\n\n  peekNextSubchannel() {\n    return this.subchannelList[this.nextIndex];\n  }\n\n}\n\nclass RoundRobinLoadBalancer {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.subchannels = [];\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentReadyPicker = null;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      this.calculateAndUpdateState();\n\n      if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n        this.channelControlHelper.requestReresolution();\n        subchannel.startConnecting();\n      }\n    };\n  }\n\n  calculateAndUpdateState() {\n    if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n      const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n      let index = 0;\n\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n\n        if (index < 0) {\n          index = 0;\n        }\n      }\n\n      this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    } else {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    }\n  }\n\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n\n    if (newState === connectivity_state_1.ConnectivityState.READY) {\n      this.currentReadyPicker = picker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n  }\n\n  updateAddressList(addressList, lbConfig) {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + addressList.map(address => subchannel_address_1.subchannelAddressToString(address)));\n    this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n      const subchannelState = subchannel.getConnectivityState();\n      this.subchannelStateCounts[subchannelState] += 1;\n\n      if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        subchannel.startConnecting();\n      }\n    }\n\n    this.calculateAndUpdateState();\n  }\n\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n}\n\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\n\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\n\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","trace","text","logging","constants_1","DEBUG","TYPE_NAME","RoundRobinLoadBalancingConfig","getLoadBalancerName","constructor","toJsonObject","createFromJson","obj","RoundRobinPicker","subchannelList","nextIndex","pick","pickArgs","pickedSubchannel","length","pickResultType","picker_1","COMPLETE","subchannel","status","extraFilterFactories","onCallStarted","peekNextSubchannel","RoundRobinLoadBalancer","channelControlHelper","connectivity_state_1","IDLE","subchannelStateCounts","CONNECTING","READY","SHUTDOWN","TRANSIENT_FAILURE","subchannelStateListener","previousState","newState","calculateAndUpdateState","requestReresolution","startConnecting","readySubchannels","subchannels","filter","getConnectivityState","index","currentReadyPicker","indexOf","updateState","picker","currentState","resetSubchannelList","removeConnectivityStateListener","unref","removeChannelzChild","getChannelzRef","updateAddressList","addressList","lbConfig","map","address","subchannel_address_1","createSubchannel","ref","addConnectivityStateListener","addChannelzChild","subchannelState","exitIdle","resetBackoff","destroy","getTypeName","exports","setup","load_balancer_1"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/load-balancer-round-robin.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  registerLoadBalancerType,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { ConnectivityStateListener, SubchannelInterface } from './subchannel-interface';\n\nconst TRACER_NAME = 'round_robin';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'round_robin';\n\nclass RoundRobinLoadBalancingConfig implements LoadBalancingConfig {\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {},\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\n\nclass RoundRobinPicker implements Picker {\n  constructor(\n    private readonly subchannelList: SubchannelInterface[],\n    private nextIndex = 0\n  ) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null,\n    };\n  }\n\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextSubchannel(): SubchannelInterface {\n    return this.subchannelList[this.nextIndex];\n  }\n}\n\ninterface ConnectivityStateCounts {\n  [ConnectivityState.CONNECTING]: number;\n  [ConnectivityState.IDLE]: number;\n  [ConnectivityState.READY]: number;\n  [ConnectivityState.SHUTDOWN]: number;\n  [ConnectivityState.TRANSIENT_FAILURE]: number;\n}\n\nexport class RoundRobinLoadBalancer implements LoadBalancer {\n  private subchannels: SubchannelInterface[] = [];\n\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n\n  private subchannelStateListener: ConnectivityStateListener;\n\n  private subchannelStateCounts: ConnectivityStateCounts;\n\n  private currentReadyPicker: RoundRobinPicker | null = null;\n\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannelStateListener = (\n      subchannel: SubchannelInterface,\n      previousState: ConnectivityState,\n      newState: ConnectivityState\n    ) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      this.calculateAndUpdateState();\n\n      if (\n        newState === ConnectivityState.TRANSIENT_FAILURE ||\n        newState === ConnectivityState.IDLE\n      ) {\n        this.channelControlHelper.requestReresolution();\n        subchannel.startConnecting();\n      }\n    };\n  }\n\n  private calculateAndUpdateState() {\n    if (this.subchannelStateCounts[ConnectivityState.READY] > 0) {\n      const readySubchannels = this.subchannels.filter(\n        (subchannel) =>\n          subchannel.getConnectivityState() === ConnectivityState.READY\n      );\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(\n          this.currentReadyPicker.peekNextSubchannel()\n        );\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(\n        ConnectivityState.READY,\n        new RoundRobinPicker(readySubchannels, index)\n      );\n    } else if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) {\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    } else if (\n      this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] > 0\n    ) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker()\n      );\n    } else {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    }\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (newState === ConnectivityState.READY) {\n      this.currentReadyPicker = picker as RoundRobinPicker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannels = [];\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig\n  ): void {\n    this.resetSubchannelList();\n    trace(\n      'Connect to address list ' +\n        addressList.map((address) => subchannelAddressToString(address))\n    );\n    this.subchannels = addressList.map((address) =>\n      this.channelControlHelper.createSubchannel(address, {})\n    );\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n      const subchannelState = subchannel.getConnectivityState();\n      this.subchannelStateCounts[subchannelState] += 1;\n      if (\n        subchannelState === ConnectivityState.IDLE ||\n        subchannelState === ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        subchannel.startConnecting();\n      }\n    }\n    this.calculateAndUpdateState();\n  }\n\n  exitIdle(): void {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n  resetBackoff(): void {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy(): void {\n    this.resetSubchannelList();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    RoundRobinLoadBalancer,\n    RoundRobinLoadBalancingConfig\n  );\n}\n"]},"metadata":{},"sourceType":"script"}