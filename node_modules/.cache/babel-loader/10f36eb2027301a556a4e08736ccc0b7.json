{"ast":null,"code":"// Public API\n// ==========\n// The main governing power behind the http2 API design is that it should look very similar to the\n// existing node.js [HTTPS API][1] (which is, in turn, almost identical to the [HTTP API][2]). The\n// additional features of HTTP/2 are exposed as extensions to this API. Furthermore, node-http2\n// should fall back to using HTTP/1.1 if needed. Compatibility with undocumented or deprecated\n// elements of the node.js HTTP/HTTPS API is a non-goal.\n//\n// Additional and modified API elements\n// ------------------------------------\n//\n// - **Class: http2.Endpoint**: an API for using the raw HTTP/2 framing layer. For documentation\n//   see [protocol/endpoint.js](protocol/endpoint.html).\n//\n// - **Class: http2.Server**\n//   - **Event: 'connection' (socket, [endpoint])**: there's a second argument if the negotiation of\n//     HTTP/2 was successful: the reference to the [Endpoint](protocol/endpoint.html) object tied to the\n//     socket.\n//\n// - **http2.createServer(options, [requestListener])**: additional option:\n//   - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//\n// - **Class: http2.ServerResponse**\n//   - **response.push(options)**: initiates a server push. `options` describes the 'imaginary'\n//     request to which the push stream is a response; the possible options are identical to the\n//     ones accepted by `http2.request`. Returns a ServerResponse object that can be used to send\n//     the response headers and content.\n//\n// - **Class: http2.Agent**\n//   - **new Agent(options)**: additional option:\n//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.\n//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.\n//\n// - **http2.request(options, [callback])**:\n//   - similar to http.request\n//\n// - **http2.get(options, [callback])**:\n//   - similar to http.get\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'socket' (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference\n//     to the associated [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **request.setPriority(priority)**: assign a priority to this request. `priority` is a number\n//     between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// - **Class: http2.IncomingMessage**\n//   - has two subclasses for easier interface description: **IncomingRequest** and\n//     **IncomingResponse**\n//   - **message.socket**: in case of an HTTP/2 incoming message, it's a reference to the associated\n//     [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//\n// - **Class: http2.IncomingRequest (IncomingMessage)**\n//   - **message.url**: in case of an HTTP/2 incoming request, the `url` field always contains the\n//     path, and never a full url (it contains the path in most cases in the HTTPS api as well).\n//   - **message.scheme**: additional field. Mandatory HTTP/2 request metadata.\n//   - **message.host**: additional field. Mandatory HTTP/2 request metadata. Note that this\n//     replaces the old Host header field, but node-http2 will add Host to the `message.headers` for\n//     backwards compatibility.\n//\n// - **Class: http2.IncomingPromise (IncomingRequest)**\n//   - contains the metadata of the 'imaginary' request to which the server push is an answer.\n//   - **Event: 'response' (response)**: signals the arrival of the actual push stream. `response`\n//     is an IncomingResponse.\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **promise.cancel()**: cancels the promised server push.\n//   - **promise.setPriority(priority)**: assign a priority to this push stream. `priority` is a\n//     number between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// API elements not yet implemented\n// --------------------------------\n//\n// - **Class: http2.Server**\n//   - **server.maxHeadersCount**\n//\n// API elements that are not applicable to HTTP/2\n// ----------------------------------------------\n//\n// The reason may be deprecation of certain HTTP/1.1 features, or that some API elements simply\n// don't make sense when using HTTP/2. These will not be present when a request is done with HTTP/2,\n// but will function normally when falling back to using HTTP/1.1.\n//\n// - **Class: http2.Server**\n//   - **Event: 'checkContinue'**: not in the spec\n//   - **Event: 'upgrade'**: upgrade is deprecated in HTTP/2\n//   - **Event: 'timeout'**: HTTP/2 sockets won't timeout because of application level keepalive\n//     (PING frames)\n//   - **Event: 'connect'**: not yet supported\n//   - **server.setTimeout(msecs, [callback])**\n//   - **server.timeout**\n//\n// - **Class: http2.ServerResponse**\n//   - **Event: 'close'**\n//   - **Event: 'timeout'**\n//   - **response.writeContinue()**\n//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be\n//     ignored since [it's not supported in HTTP/2][3]\n//   - **response.setTimeout(timeout, [callback])**\n//\n// - **Class: http2.Agent**\n//   - **agent.maxSockets**: only affects HTTP/1 connection pool. When using HTTP/2, there's always\n//     one connection per host.\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'upgrade'**\n//   - **Event: 'connect'**\n//   - **Event: 'continue'**\n//   - **request.setTimeout(timeout, [callback])**\n//   - **request.setNoDelay([noDelay])**\n//   - **request.setSocketKeepAlive([enable], [initialDelay])**\n//\n// - **Class: http2.IncomingMessage**\n//   - **Event: 'close'**\n//   - **message.setTimeout(timeout, [callback])**\n//\n// [1]: https://nodejs.org/api/https.html\n// [2]: https://nodejs.org/api/http.html\n// [3]: https://tools.ietf.org/html/rfc7540#section-8.1.2.4\n// Common server and client side code\n// ==================================\nvar net = require('net');\n\nvar url = require('url');\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar PassThrough = require('stream').PassThrough;\n\nvar Readable = require('stream').Readable;\n\nvar Writable = require('stream').Writable;\n\nvar protocol = require('./protocol');\n\nvar Endpoint = protocol.Endpoint;\n\nvar http = require('http');\n\nvar https = require('https');\n\nexports.STATUS_CODES = http.STATUS_CODES;\nexports.IncomingMessage = IncomingMessage;\nexports.OutgoingMessage = OutgoingMessage;\nexports.protocol = protocol;\nvar deprecatedHeaders = ['connection', 'host', 'keep-alive', 'proxy-connection', 'transfer-encoding', 'upgrade']; // When doing NPN/ALPN negotiation, HTTP/1.1 is used as fallback\n\nvar supportedProtocols = [protocol.VERSION, 'http/1.1', 'http/1.0']; // Ciphersuite list based on the recommendations of https://wiki.mozilla.org/Security/Server_Side_TLS\n// The only modification is that kEDH+AESGCM were placed after DHE and ECDHE suites\n\nvar cipherSuites = ['ECDHE-RSA-AES128-GCM-SHA256', 'ECDHE-ECDSA-AES128-GCM-SHA256', 'ECDHE-RSA-AES256-GCM-SHA384', 'ECDHE-ECDSA-AES256-GCM-SHA384', 'DHE-RSA-AES128-GCM-SHA256', 'DHE-DSS-AES128-GCM-SHA256', 'ECDHE-RSA-AES128-SHA256', 'ECDHE-ECDSA-AES128-SHA256', 'ECDHE-RSA-AES128-SHA', 'ECDHE-ECDSA-AES128-SHA', 'ECDHE-RSA-AES256-SHA384', 'ECDHE-ECDSA-AES256-SHA384', 'ECDHE-RSA-AES256-SHA', 'ECDHE-ECDSA-AES256-SHA', 'DHE-RSA-AES128-SHA256', 'DHE-RSA-AES128-SHA', 'DHE-DSS-AES128-SHA256', 'DHE-RSA-AES256-SHA256', 'DHE-DSS-AES256-SHA', 'DHE-RSA-AES256-SHA', 'kEDH+AESGCM', 'AES128-GCM-SHA256', 'AES256-GCM-SHA384', 'ECDHE-RSA-RC4-SHA', 'ECDHE-ECDSA-RC4-SHA', 'AES128', 'AES256', 'RC4-SHA', 'HIGH', '!aNULL', '!eNULL', '!EXPORT', '!DES', '!3DES', '!MD5', '!PSK'].join(':'); // Logging\n// -------\n// Logger shim, used when no logger is provided by the user.\n\nfunction noop() {}\n\nvar defaultLogger = {\n  fatal: noop,\n  error: noop,\n  warn: noop,\n  info: noop,\n  debug: noop,\n  trace: noop,\n  child: function () {\n    return this;\n  }\n}; // Bunyan serializers exported by submodules that are worth adding when creating a logger.\n\nexports.serializers = protocol.serializers; // IncomingMessage class\n// ---------------------\n\nfunction IncomingMessage(stream) {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  PassThrough.call(this);\n  stream.pipe(this);\n  this.socket = this.stream = stream;\n  this._log = stream._log.child({\n    component: 'http'\n  }); // * HTTP/2.0 does not define a way to carry the version identifier that is included in the\n  //   HTTP/1.1 request/status line. Version is always 2.0.\n\n  this.httpVersion = '2.0';\n  this.httpVersionMajor = 2;\n  this.httpVersionMinor = 0; // * `this.headers` will store the regular headers (and none of the special colon headers)\n\n  this.headers = {};\n  this.trailers = undefined;\n  this._lastHeadersSeen = undefined; // * Other metadata is filled in when the headers arrive.\n\n  stream.once('headers', this._onHeaders.bind(this));\n  stream.once('end', this._onEnd.bind(this));\n}\n\nIncomingMessage.prototype = Object.create(PassThrough.prototype, {\n  constructor: {\n    value: IncomingMessage\n  }\n}); // [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\n\nIncomingMessage.prototype._onHeaders = function _onHeaders(headers) {\n  // * Detects malformed headers\n  this._validateHeaders(headers); // * Store the _regular_ headers in `this.headers`\n\n\n  for (var name in headers) {\n    if (name[0] !== ':') {\n      if (name === 'set-cookie' && !Array.isArray(headers[name])) {\n        this.headers[name] = [headers[name]];\n      } else {\n        this.headers[name] = headers[name];\n      }\n    }\n  } // * The last header block, if it's not the first, will represent the trailers\n\n\n  var self = this;\n  this.stream.on('headers', function (headers) {\n    self._lastHeadersSeen = headers;\n  });\n};\n\nIncomingMessage.prototype._onEnd = function _onEnd() {\n  this.trailers = this._lastHeadersSeen;\n};\n\nIncomingMessage.prototype.setTimeout = noop;\n\nIncomingMessage.prototype._checkSpecialHeader = function _checkSpecialHeader(key, value) {\n  if (typeof value !== 'string' || value.length === 0) {\n    this._log.error({\n      key: key,\n      value: value\n    }, 'Invalid or missing special header field');\n\n    this.stream.reset('PROTOCOL_ERROR');\n  }\n\n  return value;\n};\n\nIncomingMessage.prototype._validateHeaders = function _validateHeaders(headers) {\n  // * An HTTP/2.0 request or response MUST NOT include any of the following header fields:\n  //   Connection, Host, Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade. A server\n  //   MUST treat the presence of any of these header fields as a stream error of type\n  //   PROTOCOL_ERROR.\n  //  If the TE header is present, it's only valid value is 'trailers'\n  for (var i = 0; i < deprecatedHeaders.length; i++) {\n    var key = deprecatedHeaders[i];\n\n    if (key in headers || key === 'te' && headers[key] !== 'trailers') {\n      this._log.error({\n        key: key,\n        value: headers[key]\n      }, 'Deprecated header found');\n\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n\n  for (var headerName in headers) {\n    // * Empty header name field is malformed\n    if (headerName.length <= 1) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    } // * A request or response containing uppercase header name field names MUST be\n    //   treated as malformed (Section 8.1.3.5). Implementations that detect malformed\n    //   requests or responses need to ensure that the stream ends.\n\n\n    if (/[A-Z]/.test(headerName)) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n}; // OutgoingMessage class\n// ---------------------\n\n\nfunction OutgoingMessage() {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  Writable.call(this);\n  this._headers = {};\n  this._trailers = undefined;\n  this.headersSent = false;\n  this.finished = false;\n  this.on('finish', this._finish);\n}\n\nOutgoingMessage.prototype = Object.create(Writable.prototype, {\n  constructor: {\n    value: OutgoingMessage\n  }\n});\n\nOutgoingMessage.prototype._write = function _write(chunk, encoding, callback) {\n  if (this.stream) {\n    this.stream.write(chunk, encoding, callback);\n  } else {\n    this.once('socket', this._write.bind(this, chunk, encoding, callback));\n  }\n};\n\nOutgoingMessage.prototype._finish = function _finish() {\n  if (this.stream) {\n    if (this._trailers) {\n      if (this.request) {\n        this.request.addTrailers(this._trailers);\n      } else {\n        this.stream.headers(this._trailers);\n      }\n    }\n\n    this.finished = true;\n    this.stream.end();\n  } else {\n    this.once('socket', this._finish.bind(this));\n  }\n};\n\nOutgoingMessage.prototype.setHeader = function setHeader(name, value) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t set headers after they are sent.'));\n  } else {\n    name = name.toLowerCase();\n\n    if (deprecatedHeaders.indexOf(name) !== -1) {\n      return this.emit('error', new Error('Cannot set deprecated header: ' + name));\n    }\n\n    this._headers[name] = value;\n  }\n};\n\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t remove headers after they are sent.'));\n  } else {\n    delete this._headers[name.toLowerCase()];\n  }\n};\n\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  return this._headers[name.toLowerCase()];\n};\n\nOutgoingMessage.prototype.addTrailers = function addTrailers(trailers) {\n  this._trailers = trailers;\n};\n\nOutgoingMessage.prototype.setTimeout = noop;\nOutgoingMessage.prototype._checkSpecialHeader = IncomingMessage.prototype._checkSpecialHeader; // Server side\n// ===========\n\nexports.Server = Server;\nexports.IncomingRequest = IncomingRequest;\nexports.OutgoingResponse = OutgoingResponse;\nexports.ServerResponse = OutgoingResponse; // for API compatibility\n// Forward events `event` on `source` to all listeners on `target`.\n//\n// Note: The calling context is `source`.\n\nfunction forwardEvent(event, source, target) {\n  function forward() {\n    var listeners = target.listeners(event);\n    var n = listeners.length; // Special case for `error` event with no listeners.\n\n    if (n === 0 && event === 'error') {\n      var args = [event];\n      args.push.apply(args, arguments);\n      target.emit.apply(target, args);\n      return;\n    }\n\n    for (var i = 0; i < n; ++i) {\n      listeners[i].apply(source, arguments);\n    }\n  }\n\n  source.on(event, forward); // A reference to the function is necessary to be able to stop\n  // forwarding.\n\n  return forward;\n} // Server class\n// ------------\n\n\nfunction Server(options) {\n  options = util._extend({}, options);\n  this._log = (options.log || defaultLogger).child({\n    component: 'http'\n  });\n  this._settings = options.settings;\n\n  var start = this._start.bind(this);\n\n  var fallback = this._fallback.bind(this); // HTTP2 over TLS (using NPN or ALPN)\n\n\n  if (options.key && options.cert || options.pfx) {\n    this._log.info('Creating HTTP/2 server over TLS');\n\n    this._mode = 'tls';\n    options.ALPNProtocols = supportedProtocols;\n    options.NPNProtocols = supportedProtocols;\n    options.ciphers = options.ciphers || cipherSuites;\n    options.honorCipherOrder = options.honorCipherOrder != false;\n    this._server = https.createServer(options);\n    this._originalSocketListeners = this._server.listeners('secureConnection');\n\n    this._server.removeAllListeners('secureConnection');\n\n    this._server.on('secureConnection', function (socket) {\n      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol; // It's true that the client MUST use SNI, but if it doesn't, we don't care, don't fall back to HTTP/1,\n      // since if the ALPN negotiation is otherwise successful, the client thinks we speak HTTP/2 but we don't.\n\n      if (negotiatedProtocol === protocol.VERSION) {\n        start(socket);\n      } else {\n        fallback(socket);\n      }\n    });\n\n    this._server.on('request', this.emit.bind(this, 'request'));\n\n    forwardEvent('error', this._server, this);\n    forwardEvent('listening', this._server, this);\n  } // HTTP2 over plain TCP\n  else if (options.plain) {\n    this._log.info('Creating HTTP/2 server over plain TCP');\n\n    this._mode = 'plain';\n    this._server = net.createServer(start);\n  } // HTTP/2 with HTTP/1.1 upgrade\n  else {\n    this._log.error('Trying to create HTTP/2 server with Upgrade from HTTP/1.1');\n\n    throw new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported. Please provide TLS keys.');\n  }\n\n  this._server.on('close', this.emit.bind(this, 'close'));\n}\n\nServer.prototype = Object.create(EventEmitter.prototype, {\n  constructor: {\n    value: Server\n  }\n}); // Starting HTTP/2\n\nServer.prototype._start = function _start(socket) {\n  var endpoint = new Endpoint(this._log, 'SERVER', this._settings);\n\n  this._log.info({\n    e: endpoint,\n    client: socket.remoteAddress + ':' + socket.remotePort,\n    SNI: socket.servername\n  }, 'New incoming HTTP/2 connection');\n\n  endpoint.pipe(socket).pipe(endpoint);\n  var self = this;\n  endpoint.on('stream', function _onStream(stream) {\n    var response = new OutgoingResponse(stream);\n    var request = new IncomingRequest(stream); // Some conformance to Node.js Https specs allows to distinguish clients:\n\n    request.remoteAddress = socket.remoteAddress;\n    request.remotePort = socket.remotePort;\n    request.connection = request.socket = response.socket = socket;\n    request.once('ready', self.emit.bind(self, 'request', request, response));\n  });\n  endpoint.on('error', this.emit.bind(this, 'clientError'));\n  socket.on('error', this.emit.bind(this, 'clientError'));\n  this.emit('connection', socket, endpoint);\n};\n\nServer.prototype._fallback = function _fallback(socket) {\n  var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n\n  this._log.info({\n    client: socket.remoteAddress + ':' + socket.remotePort,\n    protocol: negotiatedProtocol,\n    SNI: socket.servername\n  }, 'Falling back to simple HTTPS');\n\n  for (var i = 0; i < this._originalSocketListeners.length; i++) {\n    this._originalSocketListeners[i].call(this._server, socket);\n  }\n\n  this.emit('connection', socket);\n}; // There are [3 possible signatures][1] of the `listen` function. Every arguments is forwarded to\n// the backing TCP or HTTPS server.\n// [1]: https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback\n\n\nServer.prototype.listen = function listen(port, hostname) {\n  this._log.info({\n    on: typeof hostname === 'string' ? hostname + ':' + port : port\n  }, 'Listening for incoming connections');\n\n  this._server.listen.apply(this._server, arguments);\n\n  return this._server;\n};\n\nServer.prototype.close = function close(callback) {\n  this._log.info('Closing server');\n\n  this._server.close(callback);\n};\n\nServer.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this._mode === 'tls') {\n    this._server.setTimeout(timeout, callback);\n  }\n};\n\nObject.defineProperty(Server.prototype, 'timeout', {\n  get: function getTimeout() {\n    if (this._mode === 'tls') {\n      return this._server.timeout;\n    } else {\n      return undefined;\n    }\n  },\n  set: function setTimeout(timeout) {\n    if (this._mode === 'tls') {\n      this._server.timeout = timeout;\n    }\n  }\n}); // Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `server`.There are events on the `http.Server` class where it makes difference whether someone is\n// listening on the event or not. In these cases, we can not simply forward the events from the\n// `server` to `this` since that means a listener. Instead, we forward the subscriptions.\n\nServer.prototype.on = function on(event, listener) {\n  if (event === 'upgrade' || event === 'timeout') {\n    return this._server.on(event, listener && listener.bind(this));\n  } else {\n    return EventEmitter.prototype.on.call(this, event, listener);\n  }\n}; // `addContext` is used to add Server Name Indication contexts\n\n\nServer.prototype.addContext = function addContext(hostname, credentials) {\n  if (this._mode === 'tls') {\n    this._server.addContext(hostname, credentials);\n  }\n};\n\nServer.prototype.address = function address() {\n  return this._server.address();\n};\n\nfunction createServerRaw(options, requestListener) {\n  if (typeof options === 'function') {\n    requestListener = options;\n    options = {};\n  }\n\n  if (options.pfx || options.key && options.cert) {\n    throw new Error('options.pfx, options.key, and options.cert are nonsensical!');\n  }\n\n  options.plain = true;\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n}\n\nfunction createServerTLS(options, requestListener) {\n  if (typeof options === 'function') {\n    throw new Error('options are required!');\n  }\n\n  if (!options.pfx && !(options.key && options.cert)) {\n    throw new Error('options.pfx or options.key and options.cert are required!');\n  }\n\n  options.plain = false;\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n} // Exposed main interfaces for HTTPS connections (the default)\n\n\nexports.https = {};\nexports.createServer = exports.https.createServer = createServerTLS;\nexports.request = exports.https.request = requestTLS;\nexports.get = exports.https.get = getTLS; // Exposed main interfaces for raw TCP connections (not recommended)\n\nexports.raw = {};\nexports.raw.createServer = createServerRaw;\nexports.raw.request = requestRaw;\nexports.raw.get = getRaw; // Exposed main interfaces for HTTP plaintext upgrade connections (not implemented)\n\nfunction notImplemented() {\n  throw new Error('HTTP UPGRADE is not implemented!');\n}\n\nexports.http = {};\nexports.http.createServer = exports.http.request = exports.http.get = notImplemented; // IncomingRequest class\n// ---------------------\n\nfunction IncomingRequest(stream) {\n  IncomingMessage.call(this, stream);\n}\n\nIncomingRequest.prototype = Object.create(IncomingMessage.prototype, {\n  constructor: {\n    value: IncomingRequest\n  }\n}); // [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\n\nIncomingRequest.prototype._onHeaders = function _onHeaders(headers) {\n  // * The \":method\" header field includes the HTTP method\n  // * The \":scheme\" header field includes the scheme portion of the target URI\n  // * The \":authority\" header field includes the authority portion of the target URI\n  // * The \":path\" header field includes the path and query parts of the target URI.\n  //   This field MUST NOT be empty; URIs that do not contain a path component MUST include a value\n  //   of '/', unless the request is an OPTIONS request for '*', in which case the \":path\" header\n  //   field MUST include '*'.\n  // * All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A\n  //   server MUST treat the absence of any of these header fields, presence of multiple values, or\n  //   an invalid value as a stream error of type PROTOCOL_ERROR.\n  this.method = this._checkSpecialHeader(':method', headers[':method']);\n  this.scheme = this._checkSpecialHeader(':scheme', headers[':scheme']);\n  this.host = this._checkSpecialHeader(':authority', headers[':authority']);\n  this.url = this._checkSpecialHeader(':path', headers[':path']);\n\n  if (!this.method || !this.scheme || !this.host || !this.url) {\n    // This is invalid, and we've sent a RST_STREAM, so don't continue processing\n    return;\n  } // * Host header is included in the headers object for backwards compatibility.\n\n\n  this.headers.host = this.host; // * Handling regular headers.\n\n  IncomingMessage.prototype._onHeaders.call(this, headers); // * Signaling that the headers arrived.\n\n\n  this._log.info({\n    method: this.method,\n    scheme: this.scheme,\n    host: this.host,\n    path: this.url,\n    headers: this.headers\n  }, 'Incoming request');\n\n  this.emit('ready');\n}; // OutgoingResponse class\n// ----------------------\n\n\nfunction OutgoingResponse(stream) {\n  OutgoingMessage.call(this);\n  this._log = stream._log.child({\n    component: 'http'\n  });\n  this.stream = stream;\n  this.statusCode = 200;\n  this.sendDate = true;\n  this.stream.once('headers', this._onRequestHeaders.bind(this));\n}\n\nOutgoingResponse.prototype = Object.create(OutgoingMessage.prototype, {\n  constructor: {\n    value: OutgoingResponse\n  }\n});\n\nOutgoingResponse.prototype.writeHead = function writeHead(statusCode, reasonPhrase, headers) {\n  if (this.headersSent) {\n    return;\n  }\n\n  if (typeof reasonPhrase === 'string') {\n    this._log.warn('Reason phrase argument was present but ignored by the writeHead method');\n  } else {\n    headers = reasonPhrase;\n  }\n\n  for (var name in headers) {\n    this.setHeader(name, headers[name]);\n  }\n\n  headers = this._headers;\n\n  if (this.sendDate && !('date' in this._headers)) {\n    headers.date = new Date().toUTCString();\n  }\n\n  this._log.info({\n    status: statusCode,\n    headers: this._headers\n  }, 'Sending server response');\n\n  headers[':status'] = this.statusCode = statusCode;\n  this.stream.headers(headers);\n  this.headersSent = true;\n};\n\nOutgoingResponse.prototype._implicitHeaders = function _implicitHeaders() {\n  if (!this.headersSent) {\n    this.writeHead(this.statusCode);\n  }\n};\n\nOutgoingResponse.prototype._implicitHeader = function () {\n  this._implicitHeaders();\n};\n\nOutgoingResponse.prototype.write = function write() {\n  this._implicitHeaders();\n\n  return OutgoingMessage.prototype.write.apply(this, arguments);\n};\n\nOutgoingResponse.prototype.end = function end() {\n  this.finshed = true;\n\n  this._implicitHeaders();\n\n  return OutgoingMessage.prototype.end.apply(this, arguments);\n};\n\nOutgoingResponse.prototype._onRequestHeaders = function _onRequestHeaders(headers) {\n  this._requestHeaders = headers;\n};\n\nOutgoingResponse.prototype.push = function push(options) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  }\n\n  if (!options.path) {\n    throw new Error('`path` option is mandatory.');\n  }\n\n  var promise = util._extend({\n    ':method': (options.method || 'GET').toUpperCase(),\n    ':scheme': options.protocol && options.protocol.slice(0, -1) || this._requestHeaders[':scheme'],\n    ':authority': options.hostname || options.host || this._requestHeaders[':authority'],\n    ':path': options.path\n  }, options.headers);\n\n  this._log.info({\n    method: promise[':method'],\n    scheme: promise[':scheme'],\n    authority: promise[':authority'],\n    path: promise[':path'],\n    headers: options.headers\n  }, 'Promising push stream');\n\n  var pushStream = this.stream.promise(promise);\n  return new OutgoingResponse(pushStream);\n};\n\nOutgoingResponse.prototype.altsvc = function altsvc(host, port, protocolID, maxAge, origin) {\n  if (origin === undefined) {\n    origin = \"\";\n  }\n\n  this.stream.altsvc(host, port, protocolID, maxAge, origin);\n}; // Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\n\n\nOutgoingResponse.prototype.on = function on(event, listener) {\n  if (this.request && event === 'timeout') {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n}; // Client side\n// ===========\n\n\nexports.ClientRequest = OutgoingRequest; // for API compatibility\n\nexports.OutgoingRequest = OutgoingRequest;\nexports.IncomingResponse = IncomingResponse;\nexports.Agent = Agent;\nexports.globalAgent = undefined;\n\nfunction requestRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = true;\n\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.request === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction requestTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = false;\n\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.request === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction getRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = true;\n\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.get === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n\n  return exports.globalAgent.get(options, callback);\n}\n\nfunction getTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = false;\n\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.get === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n\n  return exports.globalAgent.get(options, callback);\n} // Agent class\n// -----------\n\n\nfunction Agent(options) {\n  EventEmitter.call(this);\n  this.setMaxListeners(0);\n  options = util._extend({}, options);\n  this._settings = options.settings;\n  this._log = (options.log || defaultLogger).child({\n    component: 'http'\n  });\n  this.endpoints = {}; // * Using an own HTTPS agent, because the global agent does not look at `NPN/ALPNProtocols` when\n  //   generating the key identifying the connection, so we may get useless non-negotiated TLS\n  //   channels even if we ask for a negotiated one. This agent will contain only negotiated\n  //   channels.\n\n  options.ALPNProtocols = supportedProtocols;\n  options.NPNProtocols = supportedProtocols;\n  this._httpsAgent = new https.Agent(options);\n  this.sockets = this._httpsAgent.sockets;\n  this.requests = this._httpsAgent.requests;\n}\n\nAgent.prototype = Object.create(EventEmitter.prototype, {\n  constructor: {\n    value: Agent\n  }\n});\n\nAgent.prototype.request = function request(options, callback) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  } else {\n    options = util._extend({}, options);\n  }\n\n  options.method = (options.method || 'GET').toUpperCase();\n  options.protocol = options.protocol || 'https:';\n  options.host = options.hostname || options.host || 'localhost';\n  options.port = options.port || 443;\n  options.path = options.path || '/';\n\n  if (!options.plain && options.protocol === 'http:') {\n    this._log.error('Trying to negotiate client request with Upgrade from HTTP/1.1');\n\n    this.emit('error', new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported.'));\n  }\n\n  var request = new OutgoingRequest(this._log);\n\n  if (callback) {\n    request.on('response', callback);\n  }\n\n  var key = [!!options.plain, options.host, options.port].join(':');\n  var self = this; // * There's an existing HTTP/2 connection to this host\n\n  if (key in this.endpoints) {\n    var endpoint = this.endpoints[key];\n\n    request._start(endpoint.createStream(), options);\n  } // * HTTP/2 over plain TCP\n  else if (options.plain) {\n    endpoint = new Endpoint(this._log, 'CLIENT', this._settings);\n    endpoint.socket = net.connect({\n      host: options.host,\n      port: options.port,\n      localAddress: options.localAddress\n    });\n    endpoint.socket.on('error', function (error) {\n      self._log.error('Socket error: ' + error.toString());\n\n      request.emit('error', error);\n    });\n    endpoint.on('error', function (error) {\n      self._log.error('Connection error: ' + error.toString());\n\n      request.emit('error', error);\n    });\n    this.endpoints[key] = endpoint;\n    endpoint.pipe(endpoint.socket).pipe(endpoint);\n\n    request._start(endpoint.createStream(), options);\n  } // * HTTP/2 over TLS negotiated using NPN or ALPN, or fallback to HTTPS1\n  else {\n    var started = false;\n    var createAgent = hasAgentOptions(options);\n    options.ALPNProtocols = supportedProtocols;\n    options.NPNProtocols = supportedProtocols;\n    options.servername = options.host; // Server Name Indication\n\n    options.ciphers = options.ciphers || cipherSuites;\n\n    if (createAgent) {\n      options.agent = new https.Agent(options);\n    } else if (options.agent == null) {\n      options.agent = this._httpsAgent;\n    }\n\n    var httpsRequest = https.request(options);\n    httpsRequest.on('error', function (error) {\n      self._log.error('Socket error: ' + error.toString());\n\n      self.removeAllListeners(key);\n      request.emit('error', error);\n    });\n    httpsRequest.on('socket', function (socket) {\n      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n\n      if (negotiatedProtocol != null) {\n        // null in >=0.11.0, undefined in <0.11.0\n        negotiated();\n      } else {\n        socket.on('secureConnect', negotiated);\n      }\n    });\n\n    function negotiated() {\n      var endpoint;\n      var negotiatedProtocol = httpsRequest.socket.alpnProtocol || httpsRequest.socket.npnProtocol;\n\n      if (negotiatedProtocol === protocol.VERSION) {\n        httpsRequest.socket.emit('agentRemove');\n        unbundleSocket(httpsRequest.socket);\n        endpoint = new Endpoint(self._log, 'CLIENT', self._settings);\n        endpoint.socket = httpsRequest.socket;\n        endpoint.pipe(endpoint.socket).pipe(endpoint);\n      }\n\n      if (started) {\n        // ** In the meantime, an other connection was made to the same host...\n        if (endpoint) {\n          // *** and it turned out to be HTTP2 and the request was multiplexed on that one, so we should close this one\n          endpoint.close();\n        } // *** otherwise, the fallback to HTTPS1 is already done.\n\n      } else {\n        if (endpoint) {\n          self._log.info({\n            e: endpoint,\n            server: options.host + ':' + options.port\n          }, 'New outgoing HTTP/2 connection');\n\n          self.endpoints[key] = endpoint;\n          self.emit(key, endpoint);\n        } else {\n          self.emit(key, undefined);\n        }\n      }\n    }\n\n    this.once(key, function (endpoint) {\n      started = true;\n\n      if (endpoint) {\n        request._start(endpoint.createStream(), options);\n      } else {\n        request._fallback(httpsRequest);\n      }\n    });\n  }\n\n  return request;\n};\n\nAgent.prototype.get = function get(options, callback) {\n  var request = this.request(options, callback);\n  request.end();\n  return request;\n};\n\nAgent.prototype.destroy = function (error) {\n  if (this._httpsAgent) {\n    this._httpsAgent.destroy();\n  }\n\n  for (var key in this.endpoints) {\n    this.endpoints[key].close(error);\n  }\n};\n\nfunction unbundleSocket(socket) {\n  socket.removeAllListeners('data');\n  socket.removeAllListeners('end');\n  socket.removeAllListeners('readable');\n  socket.removeAllListeners('close');\n  socket.removeAllListeners('error');\n  socket.unpipe();\n  delete socket.ondata;\n  delete socket.onend;\n}\n\nfunction hasAgentOptions(options) {\n  return options.pfx != null || options.key != null || options.passphrase != null || options.cert != null || options.ca != null || options.ciphers != null || options.rejectUnauthorized != null || options.secureProtocol != null;\n}\n\nObject.defineProperty(Agent.prototype, 'maxSockets', {\n  get: function getMaxSockets() {\n    return this._httpsAgent.maxSockets;\n  },\n  set: function setMaxSockets(value) {\n    this._httpsAgent.maxSockets = value;\n  }\n});\nexports.globalAgent = new Agent(); // OutgoingRequest class\n// ---------------------\n\nfunction OutgoingRequest() {\n  OutgoingMessage.call(this);\n  this._log = undefined;\n  this.stream = undefined;\n}\n\nOutgoingRequest.prototype = Object.create(OutgoingMessage.prototype, {\n  constructor: {\n    value: OutgoingRequest\n  }\n});\n\nOutgoingRequest.prototype._start = function _start(stream, options) {\n  this.stream = stream;\n  this.options = options;\n  this._log = stream._log.child({\n    component: 'http'\n  });\n\n  for (var key in options.headers) {\n    this.setHeader(key, options.headers[key]);\n  }\n\n  var headers = this._headers;\n  delete headers.host;\n\n  if (options.auth) {\n    headers.authorization = 'Basic ' + new Buffer(options.auth).toString('base64');\n  }\n\n  headers[':scheme'] = options.protocol.slice(0, -1);\n  headers[':method'] = options.method;\n  headers[':authority'] = options.host;\n  headers[':path'] = options.path;\n\n  this._log.info({\n    scheme: headers[':scheme'],\n    method: headers[':method'],\n    authority: headers[':authority'],\n    path: headers[':path'],\n    headers: options.headers || {}\n  }, 'Sending request');\n\n  this.stream.headers(headers);\n  this.headersSent = true;\n  this.emit('socket', this.stream);\n  var response = new IncomingResponse(this.stream);\n  response.req = this;\n  response.once('ready', this.emit.bind(this, 'response', response));\n  this.stream.on('promise', this._onPromise.bind(this));\n};\n\nOutgoingRequest.prototype._fallback = function _fallback(request) {\n  request.on('response', this.emit.bind(this, 'response'));\n  this.stream = this.request = request;\n  this.emit('socket', this.socket);\n};\n\nOutgoingRequest.prototype.setPriority = function setPriority(priority) {\n  if (this.stream) {\n    this.stream.priority(priority);\n  } else {\n    this.once('socket', this.setPriority.bind(this, priority));\n  }\n}; // Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\n\n\nOutgoingRequest.prototype.on = function on(event, listener) {\n  if (this.request && event === 'upgrade') {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n}; // Methods only in fallback mode\n\n\nOutgoingRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  if (this.request) {\n    this.request.setNoDelay(noDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setNoDelay.bind(this, noDelay));\n  }\n};\n\nOutgoingRequest.prototype.setSocketKeepAlive = function setSocketKeepAlive(enable, initialDelay) {\n  if (this.request) {\n    this.request.setSocketKeepAlive(enable, initialDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setSocketKeepAlive.bind(this, enable, initialDelay));\n  }\n};\n\nOutgoingRequest.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this.request) {\n    this.request.setTimeout(timeout, callback);\n  } else if (!this.stream) {\n    this.on('socket', this.setTimeout.bind(this, timeout, callback));\n  }\n}; // Aborting the request\n\n\nOutgoingRequest.prototype.abort = function abort() {\n  if (this.request) {\n    this.request.abort();\n  } else if (this.stream) {\n    this.stream.reset('CANCEL');\n  } else {\n    this.on('socket', this.abort.bind(this));\n  }\n}; // Receiving push promises\n\n\nOutgoingRequest.prototype._onPromise = function _onPromise(stream, headers) {\n  this._log.info({\n    push_stream: stream.id\n  }, 'Receiving push promise');\n\n  var promise = new IncomingPromise(stream, headers);\n\n  if (this.listeners('push').length > 0) {\n    this.emit('push', promise);\n  } else {\n    promise.cancel();\n  }\n}; // IncomingResponse class\n// ----------------------\n\n\nfunction IncomingResponse(stream) {\n  IncomingMessage.call(this, stream);\n}\n\nIncomingResponse.prototype = Object.create(IncomingMessage.prototype, {\n  constructor: {\n    value: IncomingResponse\n  }\n}); // [Response Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.4)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\n\nIncomingResponse.prototype._onHeaders = function _onHeaders(headers) {\n  // * A single \":status\" header field is defined that carries the HTTP status code field. This\n  //   header field MUST be included in all responses.\n  // * A client MUST treat the absence of the \":status\" header field, the presence of multiple\n  //   values, or an invalid value as a stream error of type PROTOCOL_ERROR.\n  //   Note: currently, we do not enforce it strictly: we accept any format, and parse it as int\n  // * HTTP/2.0 does not define a way to carry the reason phrase that is included in an HTTP/1.1\n  //   status line.\n  this.statusCode = parseInt(this._checkSpecialHeader(':status', headers[':status'])); // * Handling regular headers.\n\n  IncomingMessage.prototype._onHeaders.call(this, headers); // * Signaling that the headers arrived.\n\n\n  this._log.info({\n    status: this.statusCode,\n    headers: this.headers\n  }, 'Incoming response');\n\n  this.emit('ready');\n}; // IncomingPromise class\n// -------------------------\n\n\nfunction IncomingPromise(responseStream, promiseHeaders) {\n  var stream = new Readable();\n  stream._read = noop;\n  stream.push(null);\n  stream._log = responseStream._log;\n  IncomingRequest.call(this, stream);\n\n  this._onHeaders(promiseHeaders);\n\n  this._responseStream = responseStream;\n  var response = new IncomingResponse(this._responseStream);\n  response.once('ready', this.emit.bind(this, 'response', response));\n  this.stream.on('promise', this._onPromise.bind(this));\n}\n\nIncomingPromise.prototype = Object.create(IncomingRequest.prototype, {\n  constructor: {\n    value: IncomingPromise\n  }\n});\n\nIncomingPromise.prototype.cancel = function cancel() {\n  this._responseStream.reset('CANCEL');\n};\n\nIncomingPromise.prototype.setPriority = function setPriority(priority) {\n  this._responseStream.priority(priority);\n};\n\nIncomingPromise.prototype._onPromise = OutgoingRequest.prototype._onPromise;","map":{"version":3,"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/http2/lib/http.js"],"names":["net","require","url","util","EventEmitter","PassThrough","Readable","Writable","protocol","Endpoint","http","https","exports","STATUS_CODES","IncomingMessage","OutgoingMessage","deprecatedHeaders","supportedProtocols","VERSION","cipherSuites","join","noop","defaultLogger","fatal","error","warn","info","debug","trace","child","serializers","stream","call","pipe","socket","_log","component","httpVersion","httpVersionMajor","httpVersionMinor","headers","trailers","undefined","_lastHeadersSeen","once","_onHeaders","bind","_onEnd","prototype","Object","create","constructor","value","_validateHeaders","name","Array","isArray","self","on","setTimeout","_checkSpecialHeader","key","length","reset","i","headerName","test","_headers","_trailers","headersSent","finished","_finish","_write","chunk","encoding","callback","write","request","addTrailers","end","setHeader","emit","Error","toLowerCase","indexOf","removeHeader","getHeader","Server","IncomingRequest","OutgoingResponse","ServerResponse","forwardEvent","event","source","target","forward","listeners","n","args","push","apply","arguments","options","_extend","log","_settings","settings","start","_start","fallback","_fallback","cert","pfx","_mode","ALPNProtocols","NPNProtocols","ciphers","honorCipherOrder","_server","createServer","_originalSocketListeners","removeAllListeners","negotiatedProtocol","alpnProtocol","npnProtocol","plain","endpoint","e","client","remoteAddress","remotePort","SNI","servername","_onStream","response","connection","listen","port","hostname","close","timeout","defineProperty","get","getTimeout","set","listener","addContext","credentials","address","createServerRaw","requestListener","server","createServerTLS","requestTLS","getTLS","raw","requestRaw","getRaw","notImplemented","method","scheme","host","path","statusCode","sendDate","_onRequestHeaders","writeHead","reasonPhrase","date","Date","toUTCString","status","_implicitHeaders","_implicitHeader","finshed","_requestHeaders","parse","promise","toUpperCase","slice","authority","pushStream","altsvc","protocolID","maxAge","origin","ClientRequest","OutgoingRequest","IncomingResponse","Agent","globalAgent","agent","agentOptions","setMaxListeners","endpoints","_httpsAgent","sockets","requests","createStream","connect","localAddress","toString","started","createAgent","hasAgentOptions","httpsRequest","negotiated","unbundleSocket","destroy","unpipe","ondata","onend","passphrase","ca","rejectUnauthorized","secureProtocol","getMaxSockets","maxSockets","setMaxSockets","auth","authorization","Buffer","req","_onPromise","setPriority","priority","setNoDelay","noDelay","setSocketKeepAlive","enable","initialDelay","abort","push_stream","id","IncomingPromise","cancel","parseInt","responseStream","promiseHeaders","_read","_responseStream"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIG,YAAY,GAAGH,OAAO,CAAC,QAAD,CAAP,CAAkBG,YAArC;;AACA,IAAIC,WAAW,GAAGJ,OAAO,CAAC,QAAD,CAAP,CAAkBI,WAApC;;AACA,IAAIC,QAAQ,GAAGL,OAAO,CAAC,QAAD,CAAP,CAAkBK,QAAjC;;AACA,IAAIC,QAAQ,GAAGN,OAAO,CAAC,QAAD,CAAP,CAAkBM,QAAjC;;AACA,IAAIC,QAAQ,GAAGP,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIQ,QAAQ,GAAGD,QAAQ,CAACC,QAAxB;;AACA,IAAIC,IAAI,GAAGT,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIU,KAAK,GAAGV,OAAO,CAAC,OAAD,CAAnB;;AAEAW,OAAO,CAACC,YAAR,GAAuBH,IAAI,CAACG,YAA5B;A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","sourcesContent":["// Public API\n// ==========\n\n// The main governing power behind the http2 API design is that it should look very similar to the\n// existing node.js [HTTPS API][1] (which is, in turn, almost identical to the [HTTP API][2]). The\n// additional features of HTTP/2 are exposed as extensions to this API. Furthermore, node-http2\n// should fall back to using HTTP/1.1 if needed. Compatibility with undocumented or deprecated\n// elements of the node.js HTTP/HTTPS API is a non-goal.\n//\n// Additional and modified API elements\n// ------------------------------------\n//\n// - **Class: http2.Endpoint**: an API for using the raw HTTP/2 framing layer. For documentation\n//   see [protocol/endpoint.js](protocol/endpoint.html).\n//\n// - **Class: http2.Server**\n//   - **Event: 'connection' (socket, [endpoint])**: there's a second argument if the negotiation of\n//     HTTP/2 was successful: the reference to the [Endpoint](protocol/endpoint.html) object tied to the\n//     socket.\n//\n// - **http2.createServer(options, [requestListener])**: additional option:\n//   - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//\n// - **Class: http2.ServerResponse**\n//   - **response.push(options)**: initiates a server push. `options` describes the 'imaginary'\n//     request to which the push stream is a response; the possible options are identical to the\n//     ones accepted by `http2.request`. Returns a ServerResponse object that can be used to send\n//     the response headers and content.\n//\n// - **Class: http2.Agent**\n//   - **new Agent(options)**: additional option:\n//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.\n//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.\n//\n// - **http2.request(options, [callback])**:\n//   - similar to http.request\n//\n// - **http2.get(options, [callback])**:\n//   - similar to http.get\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'socket' (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference\n//     to the associated [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **request.setPriority(priority)**: assign a priority to this request. `priority` is a number\n//     between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// - **Class: http2.IncomingMessage**\n//   - has two subclasses for easier interface description: **IncomingRequest** and\n//     **IncomingResponse**\n//   - **message.socket**: in case of an HTTP/2 incoming message, it's a reference to the associated\n//     [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//\n// - **Class: http2.IncomingRequest (IncomingMessage)**\n//   - **message.url**: in case of an HTTP/2 incoming request, the `url` field always contains the\n//     path, and never a full url (it contains the path in most cases in the HTTPS api as well).\n//   - **message.scheme**: additional field. Mandatory HTTP/2 request metadata.\n//   - **message.host**: additional field. Mandatory HTTP/2 request metadata. Note that this\n//     replaces the old Host header field, but node-http2 will add Host to the `message.headers` for\n//     backwards compatibility.\n//\n// - **Class: http2.IncomingPromise (IncomingRequest)**\n//   - contains the metadata of the 'imaginary' request to which the server push is an answer.\n//   - **Event: 'response' (response)**: signals the arrival of the actual push stream. `response`\n//     is an IncomingResponse.\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **promise.cancel()**: cancels the promised server push.\n//   - **promise.setPriority(priority)**: assign a priority to this push stream. `priority` is a\n//     number between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// API elements not yet implemented\n// --------------------------------\n//\n// - **Class: http2.Server**\n//   - **server.maxHeadersCount**\n//\n// API elements that are not applicable to HTTP/2\n// ----------------------------------------------\n//\n// The reason may be deprecation of certain HTTP/1.1 features, or that some API elements simply\n// don't make sense when using HTTP/2. These will not be present when a request is done with HTTP/2,\n// but will function normally when falling back to using HTTP/1.1.\n//\n// - **Class: http2.Server**\n//   - **Event: 'checkContinue'**: not in the spec\n//   - **Event: 'upgrade'**: upgrade is deprecated in HTTP/2\n//   - **Event: 'timeout'**: HTTP/2 sockets won't timeout because of application level keepalive\n//     (PING frames)\n//   - **Event: 'connect'**: not yet supported\n//   - **server.setTimeout(msecs, [callback])**\n//   - **server.timeout**\n//\n// - **Class: http2.ServerResponse**\n//   - **Event: 'close'**\n//   - **Event: 'timeout'**\n//   - **response.writeContinue()**\n//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be\n//     ignored since [it's not supported in HTTP/2][3]\n//   - **response.setTimeout(timeout, [callback])**\n//\n// - **Class: http2.Agent**\n//   - **agent.maxSockets**: only affects HTTP/1 connection pool. When using HTTP/2, there's always\n//     one connection per host.\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'upgrade'**\n//   - **Event: 'connect'**\n//   - **Event: 'continue'**\n//   - **request.setTimeout(timeout, [callback])**\n//   - **request.setNoDelay([noDelay])**\n//   - **request.setSocketKeepAlive([enable], [initialDelay])**\n//\n// - **Class: http2.IncomingMessage**\n//   - **Event: 'close'**\n//   - **message.setTimeout(timeout, [callback])**\n//\n// [1]: https://nodejs.org/api/https.html\n// [2]: https://nodejs.org/api/http.html\n// [3]: https://tools.ietf.org/html/rfc7540#section-8.1.2.4\n\n// Common server and client side code\n// ==================================\n\nvar net = require('net');\nvar url = require('url');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar PassThrough = require('stream').PassThrough;\nvar Readable = require('stream').Readable;\nvar Writable = require('stream').Writable;\nvar protocol = require('./protocol');\nvar Endpoint = protocol.Endpoint;\nvar http = require('http');\nvar https = require('https');\n\nexports.STATUS_CODES = http.STATUS_CODES;\nexports.IncomingMessage = IncomingMessage;\nexports.OutgoingMessage = OutgoingMessage;\nexports.protocol = protocol;\n\nvar deprecatedHeaders = [\n  'connection',\n  'host',\n  'keep-alive',\n  'proxy-connection',\n  'transfer-encoding',\n  'upgrade'\n];\n\n// When doing NPN/ALPN negotiation, HTTP/1.1 is used as fallback\nvar supportedProtocols = [protocol.VERSION, 'http/1.1', 'http/1.0'];\n\n// Ciphersuite list based on the recommendations of https://wiki.mozilla.org/Security/Server_Side_TLS\n// The only modification is that kEDH+AESGCM were placed after DHE and ECDHE suites\nvar cipherSuites = [\n  'ECDHE-RSA-AES128-GCM-SHA256',\n  'ECDHE-ECDSA-AES128-GCM-SHA256',\n  'ECDHE-RSA-AES256-GCM-SHA384',\n  'ECDHE-ECDSA-AES256-GCM-SHA384',\n  'DHE-RSA-AES128-GCM-SHA256',\n  'DHE-DSS-AES128-GCM-SHA256',\n  'ECDHE-RSA-AES128-SHA256',\n  'ECDHE-ECDSA-AES128-SHA256',\n  'ECDHE-RSA-AES128-SHA',\n  'ECDHE-ECDSA-AES128-SHA',\n  'ECDHE-RSA-AES256-SHA384',\n  'ECDHE-ECDSA-AES256-SHA384',\n  'ECDHE-RSA-AES256-SHA',\n  'ECDHE-ECDSA-AES256-SHA',\n  'DHE-RSA-AES128-SHA256',\n  'DHE-RSA-AES128-SHA',\n  'DHE-DSS-AES128-SHA256',\n  'DHE-RSA-AES256-SHA256',\n  'DHE-DSS-AES256-SHA',\n  'DHE-RSA-AES256-SHA',\n  'kEDH+AESGCM',\n  'AES128-GCM-SHA256',\n  'AES256-GCM-SHA384',\n  'ECDHE-RSA-RC4-SHA',\n  'ECDHE-ECDSA-RC4-SHA',\n  'AES128',\n  'AES256',\n  'RC4-SHA',\n  'HIGH',\n  '!aNULL',\n  '!eNULL',\n  '!EXPORT',\n  '!DES',\n  '!3DES',\n  '!MD5',\n  '!PSK'\n].join(':');\n\n// Logging\n// -------\n\n// Logger shim, used when no logger is provided by the user.\nfunction noop() {}\nvar defaultLogger = {\n  fatal: noop,\n  error: noop,\n  warn : noop,\n  info : noop,\n  debug: noop,\n  trace: noop,\n\n  child: function() { return this; }\n};\n\n// Bunyan serializers exported by submodules that are worth adding when creating a logger.\nexports.serializers = protocol.serializers;\n\n// IncomingMessage class\n// ---------------------\n\nfunction IncomingMessage(stream) {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  PassThrough.call(this);\n  stream.pipe(this);\n  this.socket = this.stream = stream;\n\n  this._log = stream._log.child({ component: 'http' });\n\n  // * HTTP/2.0 does not define a way to carry the version identifier that is included in the\n  //   HTTP/1.1 request/status line. Version is always 2.0.\n  this.httpVersion = '2.0';\n  this.httpVersionMajor = 2;\n  this.httpVersionMinor = 0;\n\n  // * `this.headers` will store the regular headers (and none of the special colon headers)\n  this.headers = {};\n  this.trailers = undefined;\n  this._lastHeadersSeen = undefined;\n\n  // * Other metadata is filled in when the headers arrive.\n  stream.once('headers', this._onHeaders.bind(this));\n  stream.once('end', this._onEnd.bind(this));\n}\nIncomingMessage.prototype = Object.create(PassThrough.prototype, { constructor: { value: IncomingMessage } });\n\n// [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\nIncomingMessage.prototype._onHeaders = function _onHeaders(headers) {\n  // * Detects malformed headers\n  this._validateHeaders(headers);\n\n  // * Store the _regular_ headers in `this.headers`\n  for (var name in headers) {\n    if (name[0] !== ':') {\n      if (name === 'set-cookie' && !Array.isArray(headers[name])) {\n        this.headers[name] = [headers[name]];\n      } else {\n        this.headers[name] = headers[name];\n      }\n    }\n  }\n\n  // * The last header block, if it's not the first, will represent the trailers\n  var self = this;\n  this.stream.on('headers', function(headers) {\n    self._lastHeadersSeen = headers;\n  });\n};\n\nIncomingMessage.prototype._onEnd = function _onEnd() {\n  this.trailers = this._lastHeadersSeen;\n};\n\nIncomingMessage.prototype.setTimeout = noop;\n\nIncomingMessage.prototype._checkSpecialHeader = function _checkSpecialHeader(key, value) {\n  if ((typeof value !== 'string') || (value.length === 0)) {\n    this._log.error({ key: key, value: value }, 'Invalid or missing special header field');\n    this.stream.reset('PROTOCOL_ERROR');\n  }\n\n  return value;\n};\n\nIncomingMessage.prototype._validateHeaders = function _validateHeaders(headers) {\n  // * An HTTP/2.0 request or response MUST NOT include any of the following header fields:\n  //   Connection, Host, Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade. A server\n  //   MUST treat the presence of any of these header fields as a stream error of type\n  //   PROTOCOL_ERROR.\n  //  If the TE header is present, it's only valid value is 'trailers'\n  for (var i = 0; i < deprecatedHeaders.length; i++) {\n    var key = deprecatedHeaders[i];\n    if (key in headers || (key === 'te' && headers[key] !== 'trailers')) {\n      this._log.error({ key: key, value: headers[key] }, 'Deprecated header found');\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n\n  for (var headerName in headers) {\n    // * Empty header name field is malformed\n    if (headerName.length <= 1) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n    // * A request or response containing uppercase header name field names MUST be\n    //   treated as malformed (Section 8.1.3.5). Implementations that detect malformed\n    //   requests or responses need to ensure that the stream ends.\n    if(/[A-Z]/.test(headerName)) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n};\n\n// OutgoingMessage class\n// ---------------------\n\nfunction OutgoingMessage() {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  Writable.call(this);\n\n  this._headers = {};\n  this._trailers = undefined;\n  this.headersSent = false;\n  this.finished = false;\n\n  this.on('finish', this._finish);\n}\nOutgoingMessage.prototype = Object.create(Writable.prototype, { constructor: { value: OutgoingMessage } });\n\nOutgoingMessage.prototype._write = function _write(chunk, encoding, callback) {\n  if (this.stream) {\n    this.stream.write(chunk, encoding, callback);\n  } else {\n    this.once('socket', this._write.bind(this, chunk, encoding, callback));\n  }\n};\n\nOutgoingMessage.prototype._finish = function _finish() {\n  if (this.stream) {\n    if (this._trailers) {\n      if (this.request) {\n        this.request.addTrailers(this._trailers);\n      } else {\n        this.stream.headers(this._trailers);\n      }\n    }\n    this.finished = true;\n    this.stream.end();\n  } else {\n    this.once('socket', this._finish.bind(this));\n  }\n};\n\nOutgoingMessage.prototype.setHeader = function setHeader(name, value) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t set headers after they are sent.'));\n  } else {\n    name = name.toLowerCase();\n    if (deprecatedHeaders.indexOf(name) !== -1) {\n      return this.emit('error', new Error('Cannot set deprecated header: ' + name));\n    }\n    this._headers[name] = value;\n  }\n};\n\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t remove headers after they are sent.'));\n  } else {\n    delete this._headers[name.toLowerCase()];\n  }\n};\n\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  return this._headers[name.toLowerCase()];\n};\n\nOutgoingMessage.prototype.addTrailers = function addTrailers(trailers) {\n  this._trailers = trailers;\n};\n\nOutgoingMessage.prototype.setTimeout = noop;\n\nOutgoingMessage.prototype._checkSpecialHeader = IncomingMessage.prototype._checkSpecialHeader;\n\n// Server side\n// ===========\n\nexports.Server = Server;\nexports.IncomingRequest = IncomingRequest;\nexports.OutgoingResponse = OutgoingResponse;\nexports.ServerResponse = OutgoingResponse; // for API compatibility\n\n// Forward events `event` on `source` to all listeners on `target`.\n//\n// Note: The calling context is `source`.\nfunction forwardEvent(event, source, target) {\n  function forward() {\n    var listeners = target.listeners(event);\n\n    var n = listeners.length;\n\n    // Special case for `error` event with no listeners.\n    if (n === 0 && event === 'error') {\n      var args = [event];\n      args.push.apply(args, arguments);\n\n      target.emit.apply(target, args);\n      return;\n    }\n\n    for (var i = 0; i < n; ++i) {\n      listeners[i].apply(source, arguments);\n    }\n  }\n\n  source.on(event, forward);\n\n  // A reference to the function is necessary to be able to stop\n  // forwarding.\n  return forward;\n}\n\n// Server class\n// ------------\n\nfunction Server(options) {\n  options = util._extend({}, options);\n\n  this._log = (options.log || defaultLogger).child({ component: 'http' });\n  this._settings = options.settings;\n\n  var start = this._start.bind(this);\n  var fallback = this._fallback.bind(this);\n\n  // HTTP2 over TLS (using NPN or ALPN)\n  if ((options.key && options.cert) || options.pfx) {\n    this._log.info('Creating HTTP/2 server over TLS');\n    this._mode = 'tls';\n    options.ALPNProtocols = supportedProtocols;\n    options.NPNProtocols = supportedProtocols;\n    options.ciphers = options.ciphers || cipherSuites;\n    options.honorCipherOrder = (options.honorCipherOrder != false);\n    this._server = https.createServer(options);\n    this._originalSocketListeners = this._server.listeners('secureConnection');\n    this._server.removeAllListeners('secureConnection');\n    this._server.on('secureConnection', function(socket) {\n      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n      // It's true that the client MUST use SNI, but if it doesn't, we don't care, don't fall back to HTTP/1,\n      // since if the ALPN negotiation is otherwise successful, the client thinks we speak HTTP/2 but we don't.\n      if (negotiatedProtocol === protocol.VERSION) {\n        start(socket);\n      } else {\n        fallback(socket);\n      }\n    });\n    this._server.on('request', this.emit.bind(this, 'request'));\n\n    forwardEvent('error', this._server, this);\n    forwardEvent('listening', this._server, this);\n  }\n\n  // HTTP2 over plain TCP\n  else if (options.plain) {\n    this._log.info('Creating HTTP/2 server over plain TCP');\n    this._mode = 'plain';\n    this._server = net.createServer(start);\n  }\n\n  // HTTP/2 with HTTP/1.1 upgrade\n  else {\n    this._log.error('Trying to create HTTP/2 server with Upgrade from HTTP/1.1');\n    throw new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported. Please provide TLS keys.');\n  }\n\n  this._server.on('close', this.emit.bind(this, 'close'));\n}\nServer.prototype = Object.create(EventEmitter.prototype, { constructor: { value: Server } });\n\n// Starting HTTP/2\nServer.prototype._start = function _start(socket) {\n  var endpoint = new Endpoint(this._log, 'SERVER', this._settings);\n\n  this._log.info({ e: endpoint,\n                   client: socket.remoteAddress + ':' + socket.remotePort,\n                   SNI: socket.servername\n                 }, 'New incoming HTTP/2 connection');\n\n  endpoint.pipe(socket).pipe(endpoint);\n\n  var self = this;\n  endpoint.on('stream', function _onStream(stream) {\n    var response = new OutgoingResponse(stream);\n    var request = new IncomingRequest(stream);\n\n    // Some conformance to Node.js Https specs allows to distinguish clients:\n    request.remoteAddress = socket.remoteAddress;\n    request.remotePort = socket.remotePort;\n    request.connection = request.socket = response.socket = socket;\n\n    request.once('ready', self.emit.bind(self, 'request', request, response));\n  });\n\n  endpoint.on('error', this.emit.bind(this, 'clientError'));\n  socket.on('error', this.emit.bind(this, 'clientError'));\n\n  this.emit('connection', socket, endpoint);\n};\n\nServer.prototype._fallback = function _fallback(socket) {\n  var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n\n  this._log.info({ client: socket.remoteAddress + ':' + socket.remotePort,\n                   protocol: negotiatedProtocol,\n                   SNI: socket.servername\n                 }, 'Falling back to simple HTTPS');\n\n  for (var i = 0; i < this._originalSocketListeners.length; i++) {\n    this._originalSocketListeners[i].call(this._server, socket);\n  }\n\n  this.emit('connection', socket);\n};\n\n// There are [3 possible signatures][1] of the `listen` function. Every arguments is forwarded to\n// the backing TCP or HTTPS server.\n// [1]: https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback\nServer.prototype.listen = function listen(port, hostname) {\n  this._log.info({ on: ((typeof hostname === 'string') ? (hostname + ':' + port) : port) },\n                 'Listening for incoming connections');\n  this._server.listen.apply(this._server, arguments);\n\n  return this._server;\n};\n\nServer.prototype.close = function close(callback) {\n  this._log.info('Closing server');\n  this._server.close(callback);\n};\n\nServer.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this._mode === 'tls') {\n    this._server.setTimeout(timeout, callback);\n  }\n};\n\nObject.defineProperty(Server.prototype, 'timeout', {\n  get: function getTimeout() {\n    if (this._mode === 'tls') {\n      return this._server.timeout;\n    } else {\n      return undefined;\n    }\n  },\n  set: function setTimeout(timeout) {\n    if (this._mode === 'tls') {\n      this._server.timeout = timeout;\n    }\n  }\n});\n\n// Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `server`.There are events on the `http.Server` class where it makes difference whether someone is\n// listening on the event or not. In these cases, we can not simply forward the events from the\n// `server` to `this` since that means a listener. Instead, we forward the subscriptions.\nServer.prototype.on = function on(event, listener) {\n  if ((event === 'upgrade') || (event === 'timeout')) {\n    return this._server.on(event, listener && listener.bind(this));\n  } else {\n    return EventEmitter.prototype.on.call(this, event, listener);\n  }\n};\n\n// `addContext` is used to add Server Name Indication contexts\nServer.prototype.addContext = function addContext(hostname, credentials) {\n  if (this._mode === 'tls') {\n    this._server.addContext(hostname, credentials);\n  }\n};\n\nServer.prototype.address = function address() {\n  return this._server.address()\n};\n\nfunction createServerRaw(options, requestListener) {\n  if (typeof options === 'function') {\n    requestListener = options;\n    options = {};\n  }\n\n  if (options.pfx || (options.key && options.cert)) {\n    throw new Error('options.pfx, options.key, and options.cert are nonsensical!');\n  }\n\n  options.plain = true;\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n}\n\nfunction createServerTLS(options, requestListener) {\n  if (typeof options === 'function') {\n    throw new Error('options are required!');\n  }\n  if (!options.pfx && !(options.key && options.cert)) {\n    throw new Error('options.pfx or options.key and options.cert are required!');\n  }\n  options.plain = false;\n\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n}\n\n// Exposed main interfaces for HTTPS connections (the default)\nexports.https = {};\nexports.createServer = exports.https.createServer = createServerTLS;\nexports.request = exports.https.request = requestTLS;\nexports.get = exports.https.get = getTLS;\n\n// Exposed main interfaces for raw TCP connections (not recommended)\nexports.raw = {};\nexports.raw.createServer = createServerRaw;\nexports.raw.request = requestRaw;\nexports.raw.get = getRaw;\n\n// Exposed main interfaces for HTTP plaintext upgrade connections (not implemented)\nfunction notImplemented() {\n    throw new Error('HTTP UPGRADE is not implemented!');\n}\n\nexports.http = {};\nexports.http.createServer = exports.http.request = exports.http.get = notImplemented;\n\n// IncomingRequest class\n// ---------------------\n\nfunction IncomingRequest(stream) {\n  IncomingMessage.call(this, stream);\n}\nIncomingRequest.prototype = Object.create(IncomingMessage.prototype, { constructor: { value: IncomingRequest } });\n\n// [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\nIncomingRequest.prototype._onHeaders = function _onHeaders(headers) {\n  // * The \":method\" header field includes the HTTP method\n  // * The \":scheme\" header field includes the scheme portion of the target URI\n  // * The \":authority\" header field includes the authority portion of the target URI\n  // * The \":path\" header field includes the path and query parts of the target URI.\n  //   This field MUST NOT be empty; URIs that do not contain a path component MUST include a value\n  //   of '/', unless the request is an OPTIONS request for '*', in which case the \":path\" header\n  //   field MUST include '*'.\n  // * All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A\n  //   server MUST treat the absence of any of these header fields, presence of multiple values, or\n  //   an invalid value as a stream error of type PROTOCOL_ERROR.\n  this.method = this._checkSpecialHeader(':method'   , headers[':method']);\n  this.scheme = this._checkSpecialHeader(':scheme'   , headers[':scheme']);\n  this.host   = this._checkSpecialHeader(':authority', headers[':authority']  );\n  this.url    = this._checkSpecialHeader(':path'     , headers[':path']  );\n  if (!this.method || !this.scheme || !this.host || !this.url) {\n    // This is invalid, and we've sent a RST_STREAM, so don't continue processing\n    return;\n  }\n\n  // * Host header is included in the headers object for backwards compatibility.\n  this.headers.host = this.host;\n\n  // * Handling regular headers.\n  IncomingMessage.prototype._onHeaders.call(this, headers);\n\n  // * Signaling that the headers arrived.\n  this._log.info({ method: this.method, scheme: this.scheme, host: this.host,\n                   path: this.url, headers: this.headers }, 'Incoming request');\n  this.emit('ready');\n};\n\n// OutgoingResponse class\n// ----------------------\n\nfunction OutgoingResponse(stream) {\n  OutgoingMessage.call(this);\n\n  this._log = stream._log.child({ component: 'http' });\n\n  this.stream = stream;\n  this.statusCode = 200;\n  this.sendDate = true;\n\n  this.stream.once('headers', this._onRequestHeaders.bind(this));\n}\nOutgoingResponse.prototype = Object.create(OutgoingMessage.prototype, { constructor: { value: OutgoingResponse } });\n\nOutgoingResponse.prototype.writeHead = function writeHead(statusCode, reasonPhrase, headers) {\n  if (this.headersSent) {\n    return;\n  }\n\n  if (typeof reasonPhrase === 'string') {\n    this._log.warn('Reason phrase argument was present but ignored by the writeHead method');\n  } else {\n    headers = reasonPhrase;\n  }\n\n  for (var name in headers) {\n    this.setHeader(name, headers[name]);\n  }\n  headers = this._headers;\n\n  if (this.sendDate && !('date' in this._headers)) {\n    headers.date = (new Date()).toUTCString();\n  }\n\n  this._log.info({ status: statusCode, headers: this._headers }, 'Sending server response');\n\n  headers[':status'] = this.statusCode = statusCode;\n\n  this.stream.headers(headers);\n  this.headersSent = true;\n};\n\nOutgoingResponse.prototype._implicitHeaders = function _implicitHeaders() {\n  if (!this.headersSent) {\n    this.writeHead(this.statusCode);\n  }\n};\n\nOutgoingResponse.prototype._implicitHeader = function() {\n  this._implicitHeaders();\n};\n\nOutgoingResponse.prototype.write = function write() {\n  this._implicitHeaders();\n  return OutgoingMessage.prototype.write.apply(this, arguments);\n};\n\nOutgoingResponse.prototype.end = function end() {\n  this.finshed = true;\n  this._implicitHeaders();\n  return OutgoingMessage.prototype.end.apply(this, arguments);\n};\n\nOutgoingResponse.prototype._onRequestHeaders = function _onRequestHeaders(headers) {\n  this._requestHeaders = headers;\n};\n\nOutgoingResponse.prototype.push = function push(options) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  }\n\n  if (!options.path) {\n    throw new Error('`path` option is mandatory.');\n  }\n\n  var promise = util._extend({\n    ':method': (options.method || 'GET').toUpperCase(),\n    ':scheme': (options.protocol && options.protocol.slice(0, -1)) || this._requestHeaders[':scheme'],\n    ':authority': options.hostname || options.host || this._requestHeaders[':authority'],\n    ':path': options.path\n  }, options.headers);\n\n  this._log.info({ method: promise[':method'], scheme: promise[':scheme'],\n                   authority: promise[':authority'], path: promise[':path'],\n                   headers: options.headers }, 'Promising push stream');\n\n  var pushStream = this.stream.promise(promise);\n\n  return new OutgoingResponse(pushStream);\n};\n\nOutgoingResponse.prototype.altsvc = function altsvc(host, port, protocolID, maxAge, origin) {\n    if (origin === undefined) {\n        origin = \"\";\n    }\n    this.stream.altsvc(host, port, protocolID, maxAge, origin);\n};\n\n// Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\nOutgoingResponse.prototype.on = function on(event, listener) {\n  if (this.request && (event === 'timeout')) {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n};\n\n// Client side\n// ===========\n\nexports.ClientRequest = OutgoingRequest; // for API compatibility\nexports.OutgoingRequest = OutgoingRequest;\nexports.IncomingResponse = IncomingResponse;\nexports.Agent = Agent;\nexports.globalAgent = undefined;\n\nfunction requestRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = true;\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.request) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction requestTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = false;\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.request) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction getRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = true;\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.get) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n  return exports.globalAgent.get(options, callback);\n}\n\nfunction getTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n  options.plain = false;\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n  if (options.agent && typeof(options.agent.get) === 'function') {\n    var agentOptions = util._extend({}, options);\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n  return exports.globalAgent.get(options, callback);\n}\n\n// Agent class\n// -----------\n\nfunction Agent(options) {\n  EventEmitter.call(this);\n  this.setMaxListeners(0);\n\n  options = util._extend({}, options);\n\n  this._settings = options.settings;\n  this._log = (options.log || defaultLogger).child({ component: 'http' });\n  this.endpoints = {};\n\n  // * Using an own HTTPS agent, because the global agent does not look at `NPN/ALPNProtocols` when\n  //   generating the key identifying the connection, so we may get useless non-negotiated TLS\n  //   channels even if we ask for a negotiated one. This agent will contain only negotiated\n  //   channels.\n  options.ALPNProtocols = supportedProtocols;\n  options.NPNProtocols = supportedProtocols;\n  this._httpsAgent = new https.Agent(options);\n\n  this.sockets = this._httpsAgent.sockets;\n  this.requests = this._httpsAgent.requests;\n}\nAgent.prototype = Object.create(EventEmitter.prototype, { constructor: { value: Agent } });\n\nAgent.prototype.request = function request(options, callback) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  } else {\n    options = util._extend({}, options);\n  }\n\n  options.method = (options.method || 'GET').toUpperCase();\n  options.protocol = options.protocol || 'https:';\n  options.host = options.hostname || options.host || 'localhost';\n  options.port = options.port || 443;\n  options.path = options.path || '/';\n\n  if (!options.plain && options.protocol === 'http:') {\n    this._log.error('Trying to negotiate client request with Upgrade from HTTP/1.1');\n    this.emit('error', new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported.'));\n  }\n\n  var request = new OutgoingRequest(this._log);\n\n  if (callback) {\n    request.on('response', callback);\n  }\n\n  var key = [\n    !!options.plain,\n    options.host,\n    options.port\n  ].join(':');\n  var self = this;\n\n  // * There's an existing HTTP/2 connection to this host\n  if (key in this.endpoints) {\n    var endpoint = this.endpoints[key];\n    request._start(endpoint.createStream(), options);\n  }\n\n  // * HTTP/2 over plain TCP\n  else if (options.plain) {\n    endpoint = new Endpoint(this._log, 'CLIENT', this._settings);\n    endpoint.socket = net.connect({\n      host: options.host,\n      port: options.port,\n      localAddress: options.localAddress\n    });\n\n    endpoint.socket.on('error', function (error) {\n      self._log.error('Socket error: ' + error.toString());\n      request.emit('error', error);\n    });\n\n    endpoint.on('error', function(error){\n      self._log.error('Connection error: ' + error.toString());\n      request.emit('error', error);\n    });\n\n    this.endpoints[key] = endpoint;\n    endpoint.pipe(endpoint.socket).pipe(endpoint);\n    request._start(endpoint.createStream(), options);\n  }\n\n  // * HTTP/2 over TLS negotiated using NPN or ALPN, or fallback to HTTPS1\n  else {\n    var started = false;\n    var createAgent = hasAgentOptions(options);\n    options.ALPNProtocols = supportedProtocols;\n    options.NPNProtocols = supportedProtocols;\n    options.servername = options.host; // Server Name Indication\n    options.ciphers = options.ciphers || cipherSuites;\n    if (createAgent) {\n      options.agent = new https.Agent(options);\n    } else if (options.agent == null) {\n      options.agent = this._httpsAgent;\n    }\n    var httpsRequest = https.request(options);\n\n    httpsRequest.on('error', function (error) {\n      self._log.error('Socket error: ' + error.toString());\n      self.removeAllListeners(key);\n      request.emit('error', error);\n    });\n\n    httpsRequest.on('socket', function(socket) {\n      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n      if (negotiatedProtocol != null) { // null in >=0.11.0, undefined in <0.11.0\n        negotiated();\n      } else {\n        socket.on('secureConnect', negotiated);\n      }\n    });\n\n    function negotiated() {\n      var endpoint;\n      var negotiatedProtocol = httpsRequest.socket.alpnProtocol || httpsRequest.socket.npnProtocol;\n      if (negotiatedProtocol === protocol.VERSION) {\n        httpsRequest.socket.emit('agentRemove');\n        unbundleSocket(httpsRequest.socket);\n        endpoint = new Endpoint(self._log, 'CLIENT', self._settings);\n        endpoint.socket = httpsRequest.socket;\n        endpoint.pipe(endpoint.socket).pipe(endpoint);\n      }\n      if (started) {\n        // ** In the meantime, an other connection was made to the same host...\n        if (endpoint) {\n          // *** and it turned out to be HTTP2 and the request was multiplexed on that one, so we should close this one\n          endpoint.close();\n        }\n        // *** otherwise, the fallback to HTTPS1 is already done.\n      } else {\n        if (endpoint) {\n          self._log.info({ e: endpoint, server: options.host + ':' + options.port },\n                         'New outgoing HTTP/2 connection');\n          self.endpoints[key] = endpoint;\n          self.emit(key, endpoint);\n        } else {\n          self.emit(key, undefined);\n        }\n      }\n    }\n\n    this.once(key, function(endpoint) {\n      started = true;\n      if (endpoint) {\n        request._start(endpoint.createStream(), options);\n      } else {\n        request._fallback(httpsRequest);\n      }\n    });\n  }\n\n  return request;\n};\n\nAgent.prototype.get = function get(options, callback) {\n  var request = this.request(options, callback);\n  request.end();\n  return request;\n};\n\nAgent.prototype.destroy = function(error) {\n  if (this._httpsAgent) {\n    this._httpsAgent.destroy();\n  }\n  for (var key in this.endpoints) {\n    this.endpoints[key].close(error);\n  }\n};\n\nfunction unbundleSocket(socket) {\n  socket.removeAllListeners('data');\n  socket.removeAllListeners('end');\n  socket.removeAllListeners('readable');\n  socket.removeAllListeners('close');\n  socket.removeAllListeners('error');\n  socket.unpipe();\n  delete socket.ondata;\n  delete socket.onend;\n}\n\nfunction hasAgentOptions(options) {\n  return options.pfx != null ||\n    options.key != null ||\n    options.passphrase != null ||\n    options.cert != null ||\n    options.ca != null ||\n    options.ciphers != null ||\n    options.rejectUnauthorized != null ||\n    options.secureProtocol != null;\n}\n\nObject.defineProperty(Agent.prototype, 'maxSockets', {\n  get: function getMaxSockets() {\n    return this._httpsAgent.maxSockets;\n  },\n  set: function setMaxSockets(value) {\n    this._httpsAgent.maxSockets = value;\n  }\n});\n\nexports.globalAgent = new Agent();\n\n// OutgoingRequest class\n// ---------------------\n\nfunction OutgoingRequest() {\n  OutgoingMessage.call(this);\n\n  this._log = undefined;\n\n  this.stream = undefined;\n}\nOutgoingRequest.prototype = Object.create(OutgoingMessage.prototype, { constructor: { value: OutgoingRequest } });\n\nOutgoingRequest.prototype._start = function _start(stream, options) {\n  this.stream = stream;\n  this.options = options;\n\n  this._log = stream._log.child({ component: 'http' });\n\n  for (var key in options.headers) {\n    this.setHeader(key, options.headers[key]);\n  }\n  var headers = this._headers;\n  delete headers.host;\n\n  if (options.auth) {\n    headers.authorization = 'Basic ' + new Buffer(options.auth).toString('base64');\n  }\n\n  headers[':scheme'] = options.protocol.slice(0, -1);\n  headers[':method'] = options.method;\n  headers[':authority'] = options.host;\n  headers[':path'] = options.path;\n\n  this._log.info({ scheme: headers[':scheme'], method: headers[':method'],\n                   authority: headers[':authority'], path: headers[':path'],\n                   headers: (options.headers || {}) }, 'Sending request');\n  this.stream.headers(headers);\n  this.headersSent = true;\n\n  this.emit('socket', this.stream);\n  var response = new IncomingResponse(this.stream);\n  response.req = this;\n  response.once('ready', this.emit.bind(this, 'response', response));\n\n  this.stream.on('promise', this._onPromise.bind(this));\n};\n\nOutgoingRequest.prototype._fallback = function _fallback(request) {\n  request.on('response', this.emit.bind(this, 'response'));\n  this.stream = this.request = request;\n  this.emit('socket', this.socket);\n};\n\nOutgoingRequest.prototype.setPriority = function setPriority(priority) {\n  if (this.stream) {\n    this.stream.priority(priority);\n  } else {\n    this.once('socket', this.setPriority.bind(this, priority));\n  }\n};\n\n// Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\nOutgoingRequest.prototype.on = function on(event, listener) {\n  if (this.request && (event === 'upgrade')) {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n};\n\n// Methods only in fallback mode\nOutgoingRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  if (this.request) {\n    this.request.setNoDelay(noDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setNoDelay.bind(this, noDelay));\n  }\n};\n\nOutgoingRequest.prototype.setSocketKeepAlive = function setSocketKeepAlive(enable, initialDelay) {\n  if (this.request) {\n    this.request.setSocketKeepAlive(enable, initialDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setSocketKeepAlive.bind(this, enable, initialDelay));\n  }\n};\n\nOutgoingRequest.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this.request) {\n    this.request.setTimeout(timeout, callback);\n  } else if (!this.stream) {\n    this.on('socket', this.setTimeout.bind(this, timeout, callback));\n  }\n};\n\n// Aborting the request\nOutgoingRequest.prototype.abort = function abort() {\n  if (this.request) {\n    this.request.abort();\n  } else if (this.stream) {\n    this.stream.reset('CANCEL');\n  } else {\n    this.on('socket', this.abort.bind(this));\n  }\n};\n\n// Receiving push promises\nOutgoingRequest.prototype._onPromise = function _onPromise(stream, headers) {\n  this._log.info({ push_stream: stream.id }, 'Receiving push promise');\n\n  var promise = new IncomingPromise(stream, headers);\n\n  if (this.listeners('push').length > 0) {\n    this.emit('push', promise);\n  } else {\n    promise.cancel();\n  }\n};\n\n// IncomingResponse class\n// ----------------------\n\nfunction IncomingResponse(stream) {\n  IncomingMessage.call(this, stream);\n}\nIncomingResponse.prototype = Object.create(IncomingMessage.prototype, { constructor: { value: IncomingResponse } });\n\n// [Response Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.4)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\nIncomingResponse.prototype._onHeaders = function _onHeaders(headers) {\n  // * A single \":status\" header field is defined that carries the HTTP status code field. This\n  //   header field MUST be included in all responses.\n  // * A client MUST treat the absence of the \":status\" header field, the presence of multiple\n  //   values, or an invalid value as a stream error of type PROTOCOL_ERROR.\n  //   Note: currently, we do not enforce it strictly: we accept any format, and parse it as int\n  // * HTTP/2.0 does not define a way to carry the reason phrase that is included in an HTTP/1.1\n  //   status line.\n  this.statusCode = parseInt(this._checkSpecialHeader(':status', headers[':status']));\n\n  // * Handling regular headers.\n  IncomingMessage.prototype._onHeaders.call(this, headers);\n\n  // * Signaling that the headers arrived.\n  this._log.info({ status: this.statusCode, headers: this.headers}, 'Incoming response');\n  this.emit('ready');\n};\n\n// IncomingPromise class\n// -------------------------\n\nfunction IncomingPromise(responseStream, promiseHeaders) {\n  var stream = new Readable();\n  stream._read = noop;\n  stream.push(null);\n  stream._log = responseStream._log;\n\n  IncomingRequest.call(this, stream);\n\n  this._onHeaders(promiseHeaders);\n\n  this._responseStream = responseStream;\n\n  var response = new IncomingResponse(this._responseStream);\n  response.once('ready', this.emit.bind(this, 'response', response));\n\n  this.stream.on('promise', this._onPromise.bind(this));\n}\nIncomingPromise.prototype = Object.create(IncomingRequest.prototype, { constructor: { value: IncomingPromise } });\n\nIncomingPromise.prototype.cancel = function cancel() {\n  this._responseStream.reset('CANCEL');\n};\n\nIncomingPromise.prototype.setPriority = function setPriority(priority) {\n  this._responseStream.priority(priority);\n};\n\nIncomingPromise.prototype._onPromise = OutgoingRequest.prototype._onPromise;\n"]},"metadata":{},"sourceType":"script"}