{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentials = void 0;\n\nconst metadata_1 = require(\"./metadata\");\n\nfunction isCurrentOauth2Client(client) {\n  return 'getRequestHeaders' in client && typeof client.getRequestHeaders === 'function';\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\n\n\nclass CallCredentials {\n  /**\n   * Creates a new CallCredentials object from a given function that generates\n   * Metadata objects.\n   * @param metadataGenerator A function that accepts a set of options, and\n   * generates a Metadata object based on these options, which is passed back\n   * to the caller via a supplied (err, metadata) callback.\n   */\n  static createFromMetadataGenerator(metadataGenerator) {\n    return new SingleCallCredentials(metadataGenerator);\n  }\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n\n\n  static createFromGoogleCredential(googleCredentials) {\n    return CallCredentials.createFromMetadataGenerator((options, callback) => {\n      let getHeaders;\n\n      if (isCurrentOauth2Client(googleCredentials)) {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise((resolve, reject) => {\n          googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(headers);\n          });\n        });\n      }\n\n      getHeaders.then(headers => {\n        const metadata = new metadata_1.Metadata();\n\n        for (const key of Object.keys(headers)) {\n          metadata.add(key, headers[key]);\n        }\n\n        callback(null, metadata);\n      }, err => {\n        callback(err);\n      });\n    });\n  }\n\n  static createEmpty() {\n    return new EmptyCallCredentials();\n  }\n\n}\n\nexports.CallCredentials = CallCredentials;\n\nclass ComposedCallCredentials extends CallCredentials {\n  constructor(creds) {\n    super();\n    this.creds = creds;\n  }\n\n  async generateMetadata(options) {\n    const base = new metadata_1.Metadata();\n    const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));\n\n    for (const gen of generated) {\n      base.merge(gen);\n    }\n\n    return base;\n  }\n\n  compose(other) {\n    return new ComposedCallCredentials(this.creds.concat([other]));\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ComposedCallCredentials) {\n      return this.creds.every((value, index) => value._equals(other.creds[index]));\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass SingleCallCredentials extends CallCredentials {\n  constructor(metadataGenerator) {\n    super();\n    this.metadataGenerator = metadataGenerator;\n  }\n\n  generateMetadata(options) {\n    return new Promise((resolve, reject) => {\n      this.metadataGenerator(options, (err, metadata) => {\n        if (metadata !== undefined) {\n          resolve(metadata);\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  compose(other) {\n    return new ComposedCallCredentials([this, other]);\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof SingleCallCredentials) {\n      return this.metadataGenerator === other.metadataGenerator;\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass EmptyCallCredentials extends CallCredentials {\n  generateMetadata(options) {\n    return Promise.resolve(new metadata_1.Metadata());\n  }\n\n  compose(other) {\n    return other;\n  }\n\n  _equals(other) {\n    return other instanceof EmptyCallCredentials;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isCurrentOauth2Client","client","getRequestHeaders","CallCredentials","createFromMetadataGenerator","metadataGenerator","SingleCallCredentials","createFromGoogleCredential","googleCredentials","options","callback","getHeaders","service_url","Promise","resolve","reject","getRequestMetadata","err","headers","then","metadata","metadata_1","key","Object","keys","add","createEmpty","EmptyCallCredentials","exports","ComposedCallCredentials","constructor","creds","generateMetadata","base","generated","all","map","cred","gen","merge","compose","other","concat","_equals","every","value","index","undefined"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/call-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\n\nexport interface CallMetadataOptions {\n  service_url: string;\n}\n\nexport type CallMetadataGenerator = (\n  options: CallMetadataOptions,\n  cb: (err: Error | null, metadata?: Metadata) => void\n) => void;\n\n// google-auth-library pre-v2.0.0 does not have getRequestHeaders\n// but has getRequestMetadata, which is deprecated in v2.0.0\nexport interface OldOAuth2Client {\n  getRequestMetadata: (\n    url: string,\n    callback: (\n      err: Error | null,\n      headers?: {\n        [index: string]: string;\n      }\n    ) => void\n  ) => void;\n}\n\nexport interface CurrentOAuth2Client {\n  getRequestHeaders: (url?: string) => Promise<{ [index: string]: string }>;\n}\n\nexport type OAuth2Client = OldOAuth2Client | CurrentOAuth2Client;\n\nfunction isCurrentOauth2Client(\n  client: OAuth2Client\n): client is CurrentOAuth2Client {\n  return (\n    'getRequestHeaders' in client &&\n    typeof client.getRequestHeaders === 'function'\n  );\n}\n\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nexport abstract class CallCredentials {\n  /**\n   * Asynchronously generates a new Metadata object.\n   * @param options Options used in generating the Metadata object.\n   */\n  abstract generateMetadata(options: CallMetadataOptions): Promise<Metadata>;\n  /**\n   * Creates a new CallCredentials object from properties of both this and\n   * another CallCredentials object. This object's metadata generator will be\n   * called first.\n   * @param callCredentials The other CallCredentials object.\n   */\n  abstract compose(callCredentials: CallCredentials): CallCredentials;\n\n  /**\n   * Check whether two call credentials objects are equal. Separate\n   * SingleCallCredentials with identical metadata generator functions are\n   * equal.\n   * @param other The other CallCredentials object to compare with.\n   */\n  abstract _equals(other: CallCredentials): boolean;\n\n  /**\n   * Creates a new CallCredentials object from a given function that generates\n   * Metadata objects.\n   * @param metadataGenerator A function that accepts a set of options, and\n   * generates a Metadata object based on these options, which is passed back\n   * to the caller via a supplied (err, metadata) callback.\n   */\n  static createFromMetadataGenerator(\n    metadataGenerator: CallMetadataGenerator\n  ): CallCredentials {\n    return new SingleCallCredentials(metadataGenerator);\n  }\n\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n  static createFromGoogleCredential(\n    googleCredentials: OAuth2Client\n  ): CallCredentials {\n    return CallCredentials.createFromMetadataGenerator((options, callback) => {\n      let getHeaders: Promise<{ [index: string]: string }>;\n      if (isCurrentOauth2Client(googleCredentials)) {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise((resolve, reject) => {\n          googleCredentials.getRequestMetadata(\n            options.service_url,\n            (err, headers) => {\n              if (err) {\n                reject(err);\n                return;\n              }\n              resolve(headers);\n            }\n          );\n        });\n      }\n      getHeaders.then(\n        (headers) => {\n          const metadata = new Metadata();\n          for (const key of Object.keys(headers)) {\n            metadata.add(key, headers[key]);\n          }\n          callback(null, metadata);\n        },\n        (err) => {\n          callback(err);\n        }\n      );\n    });\n  }\n\n  static createEmpty(): CallCredentials {\n    return new EmptyCallCredentials();\n  }\n}\n\nclass ComposedCallCredentials extends CallCredentials {\n  constructor(private creds: CallCredentials[]) {\n    super();\n  }\n\n  async generateMetadata(options: CallMetadataOptions): Promise<Metadata> {\n    const base: Metadata = new Metadata();\n    const generated: Metadata[] = await Promise.all(\n      this.creds.map((cred) => cred.generateMetadata(options))\n    );\n    for (const gen of generated) {\n      base.merge(gen);\n    }\n    return base;\n  }\n\n  compose(other: CallCredentials): CallCredentials {\n    return new ComposedCallCredentials(this.creds.concat([other]));\n  }\n\n  _equals(other: CallCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedCallCredentials) {\n      return this.creds.every((value, index) =>\n        value._equals(other.creds[index])\n      );\n    } else {\n      return false;\n    }\n  }\n}\n\nclass SingleCallCredentials extends CallCredentials {\n  constructor(private metadataGenerator: CallMetadataGenerator) {\n    super();\n  }\n\n  generateMetadata(options: CallMetadataOptions): Promise<Metadata> {\n    return new Promise<Metadata>((resolve, reject) => {\n      this.metadataGenerator(options, (err, metadata) => {\n        if (metadata !== undefined) {\n          resolve(metadata);\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  compose(other: CallCredentials): CallCredentials {\n    return new ComposedCallCredentials([this, other]);\n  }\n\n  _equals(other: CallCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SingleCallCredentials) {\n      return this.metadataGenerator === other.metadataGenerator;\n    } else {\n      return false;\n    }\n  }\n}\n\nclass EmptyCallCredentials extends CallCredentials {\n  generateMetadata(options: CallMetadataOptions): Promise<Metadata> {\n    return Promise.resolve(new Metadata());\n  }\n\n  compose(other: CallCredentials): CallCredentials {\n    return other;\n  }\n\n  _equals(other: CallCredentials): boolean {\n    return other instanceof EmptyCallCredentials;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}