{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\n\nconst http2 = require(\"http2\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst server_call_1 = require(\"./server-call\");\n\nconst server_credentials_1 = require(\"./server-credentials\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging = require(\"./logging\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst channelz_1 = require(\"./channelz\");\n\nconst TRACER_NAME = 'server';\n\nfunction noop() {}\n\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n    metadata: new metadata_1.Metadata()\n  };\n}\n\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\nclass Server {\n  constructor(options) {\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Map();\n    this.started = false; // Channelz Info\n\n    this.channelzEnabled = true;\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.options = options !== null && options !== void 0 ? options : {};\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    if (this.channelzEnabled) {\n      this.channelzRef = channelz_1.registerChannelzServer(() => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n      this.trace('Server constructed');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'server',\n        id: -1\n      };\n    }\n  }\n\n  getChannelzInfo() {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists()\n    };\n  }\n\n  getChannelzSessionInfoGetter(session) {\n    return () => {\n      var _a, _b, _c;\n\n      const sessionInfo = this.sessions.get(session);\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n      let tlsInfo;\n\n      if (session.encrypted) {\n        const tlsSocket = sessionSocket;\n        const cipherInfo = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n          remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n\n      const socketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: 0,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n        remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n      };\n      return socketInfo;\n    };\n  }\n\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n  }\n\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(service, implementation) {\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service) {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const initialPortUri = uri_parser_1.parseUri(port);\n\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n\n    const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n\n    const serverOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n    };\n\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    }\n\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n\n    const deferredCallback = (error, port) => {\n      process.nextTick(() => callback(error, port));\n    };\n\n    const setupServer = () => {\n      let http2Server;\n\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('secureConnection', socket => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', e => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n\n      http2Server.setTimeout(0, noop);\n\n      this._setupHandlers(http2Server);\n\n      return http2Server;\n    };\n\n    const bindSpecificPort = (addressList, portNum, previousCount) => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: portNum,\n          count: previousCount\n        });\n      }\n\n      return Promise.all(addressList.map(address => {\n        this.trace('Attempting to bind ' + subchannel_address_1.subchannelAddressToString(address));\n        let addr;\n\n        if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n          addr = {\n            host: address.host,\n            port: portNum\n          };\n        } else {\n          addr = address;\n        }\n\n        const http2Server = setupServer();\n        return new Promise((resolve, reject) => {\n          const onError = err => {\n            this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n            resolve(err);\n          };\n\n          http2Server.once('error', onError);\n          http2Server.listen(addr, () => {\n            const boundAddress = http2Server.address();\n            let boundSubchannelAddress;\n\n            if (typeof boundAddress === 'string') {\n              boundSubchannelAddress = {\n                path: boundAddress\n              };\n            } else {\n              boundSubchannelAddress = {\n                host: boundAddress.address,\n                port: boundAddress.port\n              };\n            }\n\n            let channelzRef;\n\n            if (this.channelzEnabled) {\n              channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n                return {\n                  localAddress: boundSubchannelAddress,\n                  remoteAddress: null,\n                  security: null,\n                  remoteName: null,\n                  streamsStarted: 0,\n                  streamsSucceeded: 0,\n                  streamsFailed: 0,\n                  messagesSent: 0,\n                  messagesReceived: 0,\n                  keepAlivesSent: 0,\n                  lastLocalStreamCreatedTimestamp: null,\n                  lastRemoteStreamCreatedTimestamp: null,\n                  lastMessageSentTimestamp: null,\n                  lastMessageReceivedTimestamp: null,\n                  localFlowControlWindow: null,\n                  remoteFlowControlWindow: null\n                };\n              });\n              this.listenerChildrenTracker.refChild(channelzRef);\n            } else {\n              channelzRef = {\n                kind: 'socket',\n                id: -1,\n                name: ''\n              };\n            }\n\n            this.http2ServerList.push({\n              server: http2Server,\n              channelzRef: channelzRef\n            });\n            this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n            resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n            http2Server.removeListener('error', onError);\n          });\n        });\n      })).then(results => {\n        let count = 0;\n\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n\n            if (result !== portNum) {\n              throw new Error('Invalid state: multiple port numbers added from single address');\n            }\n          }\n        }\n\n        return {\n          port: portNum,\n          count: count + previousCount\n        };\n      });\n    };\n\n    const bindWildcardPort = addressList => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: 0,\n          count: 0\n        });\n      }\n\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise((resolve, reject) => {\n        const onError = err => {\n          this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);\n          resolve(bindWildcardPort(addressList.slice(1)));\n        };\n\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address();\n          const boundSubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port\n          };\n          let channelzRef;\n\n          if (this.channelzEnabled) {\n            channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {\n              return {\n                localAddress: boundSubchannelAddress,\n                remoteAddress: null,\n                security: null,\n                remoteName: null,\n                streamsStarted: 0,\n                streamsSucceeded: 0,\n                streamsFailed: 0,\n                messagesSent: 0,\n                messagesReceived: 0,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: null,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null,\n                localFlowControlWindow: null,\n                remoteFlowControlWindow: null\n              };\n            });\n            this.listenerChildrenTracker.refChild(channelzRef);\n          } else {\n            channelzRef = {\n              kind: 'socket',\n              id: -1,\n              name: ''\n            };\n          }\n\n          this.http2ServerList.push({\n            server: http2Server,\n            channelzRef: channelzRef\n          });\n          this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n          resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n\n    const resolverListener = {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n\n        if (addressList.length === 0) {\n          deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n\n        let bindResultPromise;\n\n        if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n\n        bindResultPromise.then(bindResult => {\n          if (bindResult.count === 0) {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(constants_1.LogVerbosity.ERROR, errorString);\n            deferredCallback(new Error(errorString), 0);\n          } else {\n            if (bindResult.count < addressList.length) {\n              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n            }\n\n            deferredCallback(null, bindResult.port);\n          }\n        }, error => {\n          const errorString = `No address added out of total ${addressList.length} resolved`;\n          logging.log(constants_1.LogVerbosity.ERROR, errorString);\n          deferredCallback(new Error(errorString), 0);\n        });\n      },\n      onError: error => {\n        deferredCallback(new Error(error.details), 0);\n      }\n    };\n    const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n\n  forceShutdown() {\n    // Close the server if it is still running.\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            channelz_1.unregisterChannelzRef(ref);\n          }\n        });\n      }\n    }\n\n    this.started = false; // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n\n    this.sessions.forEach((channelzInfo, session) => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n  }\n\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name\n    });\n    return true;\n  }\n\n  unregister(name) {\n    return this.handlers.delete(name);\n  }\n\n  start() {\n    if (this.http2ServerList.length === 0 || this.http2ServerList.every(_ref => {\n      let {\n        server: http2Server\n      } = _ref;\n      return http2Server.listening !== true;\n    })) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Starting');\n    }\n\n    this.started = true;\n  }\n\n  tryShutdown(callback) {\n    const wrappedCallback = error => {\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n\n      callback(error);\n    };\n\n    let pendingChecks = 0;\n\n    function maybeCallback() {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    } // Close the server if necessary.\n\n\n    this.started = false;\n\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            channelz_1.unregisterChannelzRef(ref);\n          }\n\n          maybeCallback();\n        });\n      }\n    }\n\n    this.sessions.forEach((channelzInfo, session) => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns\n   */\n\n\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  _setupHandlers(http2Server) {\n    if (http2Server === null) {\n      return;\n    }\n\n    http2Server.on('stream', (stream, headers) => {\n      var _a;\n\n      const channelzSessionInfo = this.sessions.get(stream.session);\n\n      if (this.channelzEnabled) {\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n      }\n\n      const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n      if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n        stream.respond({\n          [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n        }, {\n          endStream: true\n        });\n        this.callTracker.addCallFailed();\n\n        if (this.channelzEnabled) {\n          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n\n        return;\n      }\n\n      let call = null;\n\n      try {\n        const path = headers[http2.constants.HTTP2_HEADER_PATH];\n        const serverAddress = http2Server.address();\n        let serverAddressString = 'null';\n\n        if (serverAddress) {\n          if (typeof serverAddress === 'string') {\n            serverAddressString = serverAddress;\n          } else {\n            serverAddressString = serverAddress.address + ':' + serverAddress.port;\n          }\n        }\n\n        this.trace('Received call to method ' + path + ' at address ' + serverAddressString);\n        const handler = this.handlers.get(path);\n\n        if (handler === undefined) {\n          this.trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n          throw getUnimplementedStatusResponse(path);\n        }\n\n        call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once('callEnd', code => {\n          if (code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        });\n\n        if (this.channelzEnabled && channelzSessionInfo) {\n          call.once('streamEnd', success => {\n            if (success) {\n              channelzSessionInfo.streamTracker.addCallSucceeded();\n            } else {\n              channelzSessionInfo.streamTracker.addCallFailed();\n            }\n          });\n          call.on('sendMessage', () => {\n            channelzSessionInfo.messagesSent += 1;\n            channelzSessionInfo.lastMessageSentTimestamp = new Date();\n          });\n          call.on('receiveMessage', () => {\n            channelzSessionInfo.messagesReceived += 1;\n            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n          });\n        }\n\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n        metadata.remove('grpc-encoding');\n\n        switch (handler.type) {\n          case 'unary':\n            handleUnary(call, handler, metadata, encoding);\n            break;\n\n          case 'clientStream':\n            handleClientStreaming(call, handler, metadata, encoding);\n            break;\n\n          case 'serverStream':\n            handleServerStreaming(call, handler, metadata, encoding);\n            break;\n\n          case 'bidi':\n            handleBidiStreaming(call, handler, metadata, encoding);\n            break;\n\n          default:\n            throw new Error(`Unknown handler type: ${handler.type}`);\n        }\n      } catch (err) {\n        if (!call) {\n          call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n\n          if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n          }\n        }\n\n        if (err.code === undefined) {\n          err.code = constants_1.Status.INTERNAL;\n        }\n\n        call.sendError(err);\n      }\n    });\n    http2Server.on('session', session => {\n      var _a;\n\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      let channelzRef;\n\n      if (this.channelzEnabled) {\n        channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session));\n      } else {\n        channelzRef = {\n          kind: 'socket',\n          id: -1,\n          name: ''\n        };\n      }\n\n      const channelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new channelz_1.ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null\n      };\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = session.socket.remoteAddress;\n\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n      }\n\n      session.on('close', () => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          channelz_1.unregisterChannelzRef(channelzRef);\n        }\n\n        this.sessions.delete(session);\n      });\n    });\n  }\n\n}\n\nexports.Server = Server;\n\nasync function handleUnary(call, handler, metadata, encoding) {\n  const request = await call.receiveUnaryMessage(encoding);\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n  handler.func(emitter, (err, value, trailer, flags) => {\n    call.sendUnaryMessage(err, value, trailer, flags);\n  });\n}\n\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nasync function handleServerStreaming(call, handler, metadata, encoding) {\n  const request = await call.receiveUnaryMessage(encoding);\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n  handler.func(stream);\n}\n\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}","map":{"version":3,"mappings":"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","names":["TRACER_NAME","noop","getUnimplementedStatusResponse","methodName","code","constants_1","UNIMPLEMENTED","details","metadata","metadata_1","getDefaultHandler","handlerType","unimplementedStatusResponse","call","callback","emit","Error","Server","constructor","options","Map","channelz_1","channelzEnabled","channelzRef","getChannelzInfo","channelzTrace","addTrace","trace","kind","id","callTracker","listenerChildren","listenerChildrenTracker","getChildLists","sessionChildren","sessionChildrenTracker","getChannelzSessionInfoGetter","session","sessionInfo","sessions","get","sessionSocket","socket","remoteAddress","subchannel_address_1","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","_a","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastRemoteStreamCreatedTimestamp","lastCallStartedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","state","localWindowSize","_b","remoteFlowControlWindow","remoteWindowSize","_c","text","logging","DEBUG","addProtoService","addService","service","implementation","serviceKeys","Object","keys","length","forEach","attrs","methodType","requestStream","responseStream","implFn","impl","undefined","originalName","bind","success","register","path","responseSerialize","requestDeserialize","removeService","unregister","port","creds","bindAsync","started","TypeError","server_credentials_1","initialPortUri","uri_parser_1","portUri","resolver_1","serverOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","settings","maxConcurrentStreams","deferredCallback","error","process","nextTick","setupServer","http2Server","_isSecure","secureServerOptions","assign","_getSettings","http2","createSecureServer","on","e","message","createServer","setTimeout","_setupHandlers","bindSpecificPort","addressList","portNum","previousCount","Promise","resolve","count","all","map","address","addr","host","reject","onError","err","once","listen","boundAddress","boundSubchannelAddress","refChild","http2ServerList","push","server","removeListener","then","results","result","bindWildcardPort","slice","resolverListener","onSuccessfulResolution","serviceConfig","serviceConfigError","bindResultPromise","bindResult","errorString","log","ERROR","INFO","resolver","updateResolution","forceShutdown","ref","listening","close","unrefChild","channelzInfo","destroy","constants","NGHTTP2_CANCEL","clear","handler","serialize","deserialize","type","handlers","has","set","func","delete","start","every","tryShutdown","wrappedCallback","pendingChecks","maybeCallback","closed","addHttp2Port","getChannelzRef","stream","headers","channelzSessionInfo","addCallStarted","contentType","HTTP2_HEADER_CONTENT_TYPE","startsWith","respond","HTTP2_HEADER_STATUS","HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE","endStream","addCallFailed","HTTP2_HEADER_PATH","serverAddress","serverAddressString","server_call_1","OK","addCallSucceeded","Date","receiveMetadata","encoding","remove","handleUnary","handleClientStreaming","handleServerStreaming","handleBidiStreaming","INTERNAL","sendError","clientAddress","exports","request","receiveUnaryMessage","cancelled","emitter","value","trailer","flags","sendUnaryMessage"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/server.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { AddressInfo } from 'net';\n\nimport { ServiceError } from './call';\nimport { Status, LogVerbosity } from './constants';\nimport { Deserialize, Serialize, ServiceDefinition } from './make-client';\nimport { Metadata } from './metadata';\nimport {\n  BidiStreamingHandler,\n  ClientStreamingHandler,\n  HandleCall,\n  Handler,\n  HandlerType,\n  Http2ServerCallStream,\n  sendUnaryData,\n  ServerDuplexStream,\n  ServerDuplexStreamImpl,\n  ServerReadableStream,\n  ServerReadableStreamImpl,\n  ServerStreamingHandler,\n  ServerUnaryCall,\n  ServerUnaryCallImpl,\n  ServerWritableStream,\n  ServerWritableStreamImpl,\n  UnaryHandler,\n  ServerErrorResponse,\n  ServerStatusResponse,\n} from './server-call';\nimport { ServerCredentials } from './server-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  createResolver,\n  ResolverListener,\n  mapUriDefaultScheme,\n} from './resolver';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  TcpSubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n  stringToSubchannelAddress,\n} from './subchannel-address';\nimport { parseUri } from './uri-parser';\nimport { ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzServer, registerChannelzSocket, ServerInfo, ServerRef, SocketInfo, SocketRef, TlsInfo, unregisterChannelzRef } from './channelz';\nimport { CipherNameAndProtocol, TLSSocket } from 'tls';\n\nconst TRACER_NAME = 'server';\n\ninterface BindResult {\n  port: number;\n  count: number;\n}\n\nfunction noop(): void {}\n\nfunction getUnimplementedStatusResponse(\n  methodName: string\n): Partial<ServiceError> {\n  return {\n    code: Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n    metadata: new Metadata(),\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedUnaryHandler = UnaryHandler<any, any>;\ntype UntypedClientStreamingHandler = ClientStreamingHandler<any, any>;\ntype UntypedServerStreamingHandler = ServerStreamingHandler<any, any>;\ntype UntypedBidiStreamingHandler = BidiStreamingHandler<any, any>;\nexport type UntypedHandleCall = HandleCall<any, any>;\ntype UntypedHandler = Handler<any, any>;\nexport interface UntypedServiceImplementation {\n  [name: string]: UntypedHandleCall;\n}\n\nfunction getDefaultHandler(handlerType: HandlerType, methodName: string) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(\n    methodName\n  );\n  switch (handlerType) {\n    case 'unary':\n      return (\n        call: ServerUnaryCall<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'clientStream':\n      return (\n        call: ServerReadableStream<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'serverStream':\n      return (call: ServerWritableStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return (call: ServerDuplexStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\ninterface ChannelzSessionInfo {\n  ref: SocketRef;\n  streamTracker: ChannelzCallTracker;\n  messagesSent: number;\n  messagesReceived: number;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n}\n\ninterface ChannelzListenerInfo {\n  ref: SocketRef;\n}\n\nexport class Server {\n  private http2ServerList: { server: (http2.Http2Server | http2.Http2SecureServer), channelzRef: SocketRef }[] = [];\n\n  private handlers: Map<string, UntypedHandler> = new Map<\n    string,\n    UntypedHandler\n  >();\n  private sessions = new Map<http2.ServerHttp2Session, ChannelzSessionInfo>();\n  private started = false;\n  private options: ChannelOptions;\n\n  // Channelz Info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: ServerRef;\n  private channelzTrace = new ChannelzTrace();\n  private callTracker = new ChannelzCallTracker();\n  private listenerChildrenTracker = new ChannelzChildrenTracker();\n  private sessionChildrenTracker = new ChannelzChildrenTracker();\n\n  constructor(options?: ChannelOptions) {\n    this.options = options ?? {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    if (this.channelzEnabled) {\n      this.channelzRef = registerChannelzServer(() => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n      this.trace('Server constructed');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'server',\n        id: -1\n      };\n    }\n  }\n\n  private getChannelzInfo(): ServerInfo {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists()\n    };\n  }\n\n  private getChannelzSessionInfoGetter(session: http2.ServerHttp2Session): () => SocketInfo {\n    return () => {\n      const sessionInfo = this.sessions.get(session)!;\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress!, sessionSocket.localPort) : null;\n      let tlsInfo: TlsInfo | null;\n      if (session.encrypted) {\n        const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n        const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: cipherInfo.standardName ?? null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n          remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo: SocketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: 0,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: session.state.localWindowSize ?? null,\n        remoteFlowControlWindow: session.state.remoteWindowSize ?? null\n      };\n      return socketInfo;\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n  }\n  \n\n  addProtoService(): never {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(\n    service: ServiceDefinition,\n    implementation: UntypedServiceImplementation\n  ): void {\n    if (\n      service === null ||\n      typeof service !== 'object' ||\n      implementation === null ||\n      typeof implementation !== 'object'\n    ) {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach((name) => {\n      const attrs = service[name];\n      let methodType: HandlerType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(\n        attrs.path,\n        impl as UntypedHandleCall,\n        attrs.responseSerialize,\n        attrs.requestDeserialize,\n        methodType\n      );\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service: ServiceDefinition): void {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach((name) => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port: string, creds: ServerCredentials): never {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(\n    port: string,\n    creds: ServerCredentials,\n    callback: (error: Error | null, port: number) => void\n  ): void {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || !(creds instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const initialPortUri = parseUri(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = mapUriDefaultScheme(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n\n    const serverOptions: http2.ServerOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options[\n        'grpc-node.max_session_memory'\n      ];\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n      };\n    }\n\n    const deferredCallback = (error: Error | null, port: number) => {\n      process.nextTick(() => callback(error, port));\n    }\n\n    const setupServer = (): http2.Http2Server | http2.Http2SecureServer => {\n      let http2Server: http2.Http2Server | http2.Http2SecureServer;\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(\n          serverOptions,\n          creds._getSettings()!\n        );\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('secureConnection', (socket: TLSSocket) => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', (e: Error) => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server);\n      return http2Server;\n    };\n\n    const bindSpecificPort = (\n      addressList: SubchannelAddress[],\n      portNum: number,\n      previousCount: number\n    ): Promise<BindResult> => {\n      if (addressList.length === 0) {\n        return Promise.resolve({ port: portNum, count: previousCount });\n      }\n      return Promise.all(\n        addressList.map((address) => {\n          this.trace('Attempting to bind ' + subchannelAddressToString(address));\n          let addr: SubchannelAddress;\n          if (isTcpSubchannelAddress(address)) {\n            addr = {\n              host: (address as TcpSubchannelAddress).host,\n              port: portNum,\n            };\n          } else {\n            addr = address;\n          }\n\n          const http2Server = setupServer();\n          return new Promise<number | Error>((resolve, reject) => {\n            const onError = (err: Error) => {\n              this.trace('Failed to bind ' + subchannelAddressToString(address) + ' with error ' + err.message);\n              resolve(err);\n            }\n\n            http2Server.once('error', onError);\n\n            http2Server.listen(addr, () => {\n              const boundAddress = http2Server.address()!;\n              let boundSubchannelAddress: SubchannelAddress;\n              if (typeof boundAddress === 'string') {\n                boundSubchannelAddress = {\n                  path: boundAddress\n                };\n              } else {\n                boundSubchannelAddress = {\n                  host: boundAddress.address,\n                  port: boundAddress.port\n                }\n              }\n              let channelzRef: SocketRef;\n              if (this.channelzEnabled) {\n                channelzRef = registerChannelzSocket(subchannelAddressToString(boundSubchannelAddress), () => {\n                  return {\n                    localAddress: boundSubchannelAddress,\n                    remoteAddress: null,\n                    security: null,\n                    remoteName: null,\n                    streamsStarted: 0,\n                    streamsSucceeded: 0,\n                    streamsFailed: 0,\n                    messagesSent: 0,\n                    messagesReceived: 0,\n                    keepAlivesSent: 0,\n                    lastLocalStreamCreatedTimestamp: null,\n                    lastRemoteStreamCreatedTimestamp: null,\n                    lastMessageSentTimestamp: null,\n                    lastMessageReceivedTimestamp: null,\n                    localFlowControlWindow: null,\n                    remoteFlowControlWindow: null\n                  };\n                });\n                this.listenerChildrenTracker.refChild(channelzRef);\n              } else {\n                channelzRef = {\n                  kind: 'socket',\n                  id: -1,\n                  name: ''\n                };\n              }\n              this.http2ServerList.push({server: http2Server, channelzRef: channelzRef});\n              this.trace('Successfully bound ' + subchannelAddressToString(boundSubchannelAddress));\n              resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n              http2Server.removeListener('error', onError);\n            });\n          });\n        })\n      ).then((results) => {\n        let count = 0;\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n            if (result !== portNum) {\n              throw new Error(\n                'Invalid state: multiple port numbers added from single address'\n              );\n            }\n          }\n        }\n        return {\n          port: portNum,\n          count: count + previousCount,\n        };\n      });\n    };\n\n    const bindWildcardPort = (\n      addressList: SubchannelAddress[]\n    ): Promise<BindResult> => {\n      if (addressList.length === 0) {\n        return Promise.resolve<BindResult>({ port: 0, count: 0 });\n      }\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise<BindResult>((resolve, reject) => {\n        const onError = (err: Error) => {\n          this.trace('Failed to bind ' + subchannelAddressToString(address) + ' with error ' + err.message);\n          resolve(bindWildcardPort(addressList.slice(1)));\n        }\n\n        http2Server.once('error', onError);\n\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address() as AddressInfo;\n          const boundSubchannelAddress: SubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port\n          };\n          let channelzRef: SocketRef;\n          if (this.channelzEnabled) {\n            channelzRef = registerChannelzSocket(subchannelAddressToString(boundSubchannelAddress), () => {\n              return {\n                localAddress: boundSubchannelAddress,\n                remoteAddress: null,\n                security: null,\n                remoteName: null,\n                streamsStarted: 0,\n                streamsSucceeded: 0,\n                streamsFailed: 0,\n                messagesSent: 0,\n                messagesReceived: 0,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: null,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null,\n                localFlowControlWindow: null,\n                remoteFlowControlWindow: null\n              };\n            });\n            this.listenerChildrenTracker.refChild(channelzRef);\n          } else {\n            channelzRef = {\n              kind: 'socket',\n              id: -1,\n              name: ''\n            };\n          }\n          this.http2ServerList.push({server: http2Server, channelzRef: channelzRef});\n          this.trace('Successfully bound ' + subchannelAddressToString(boundSubchannelAddress));\n          resolve(\n            bindSpecificPort(\n              addressList.slice(1),\n              boundAddress.port,\n              1\n            )\n          );\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n\n    const resolverListener: ResolverListener = {\n      onSuccessfulResolution: (\n        addressList,\n        serviceConfig,\n        serviceConfigError\n      ) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n        if (addressList.length === 0) {\n          deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n        let bindResultPromise: Promise<BindResult>;\n        if (isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(\n              addressList,\n              addressList[0].port,\n              0\n            );\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n        bindResultPromise.then(\n          (bindResult) => {\n            if (bindResult.count === 0) {\n              const errorString = `No address added out of total ${addressList.length} resolved`;\n              logging.log(LogVerbosity.ERROR, errorString);\n              deferredCallback(new Error(errorString), 0);\n            } else {\n              if (bindResult.count < addressList.length) {\n                logging.log(\n                  LogVerbosity.INFO,\n                  `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`\n                );\n              }\n              deferredCallback(null, bindResult.port);\n            }\n          },\n          (error) => {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(LogVerbosity.ERROR, errorString);\n            deferredCallback(new Error(errorString), 0);\n          }\n        );\n      },\n      onError: (error) => {\n        deferredCallback(new Error(error.details), 0);\n      },\n    };\n\n    const resolver = createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n\n  forceShutdown(): void {\n    // Close the server if it is still running.\n\n    for (const {server: http2Server, channelzRef: ref} of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            unregisterChannelzRef(ref);\n          }\n        });\n      }\n    }\n\n    this.started = false;\n\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n    });\n    this.sessions.clear();\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n  }\n\n  register<RequestType, ResponseType>(\n    name: string,\n    handler: HandleCall<RequestType, ResponseType>,\n    serialize: Serialize<ResponseType>,\n    deserialize: Deserialize<RequestType>,\n    type: string\n  ): boolean {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name,\n    } as UntypedHandler);\n    return true;\n  }\n\n  unregister(name: string): boolean {\n    return this.handlers.delete(name);\n  }\n\n  start(): void {\n    if (\n      this.http2ServerList.length === 0 ||\n      this.http2ServerList.every(\n        ({server: http2Server}) => http2Server.listening !== true\n      )\n    ) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Starting');\n    }\n    this.started = true;\n  }\n\n  tryShutdown(callback: (error?: Error) => void): void {\n    const wrappedCallback = (error?: Error) => {\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n      callback(error);\n    };\n    let pendingChecks = 0;\n\n    function maybeCallback(): void {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n\n    // Close the server if necessary.\n    this.started = false;\n\n    for (const {server: http2Server, channelzRef: ref} of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            unregisterChannelzRef(ref);\n          }\n          maybeCallback();\n        });\n      }\n    }\n\n    this.sessions.forEach((channelzInfo, session) => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n\n  addHttp2Port(): never {\n    throw new Error('Not yet implemented');\n  }\n\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  private _setupHandlers(\n    http2Server: http2.Http2Server | http2.Http2SecureServer\n  ): void {\n    if (http2Server === null) {\n      return;\n    }\n\n    http2Server.on(\n      'stream',\n      (stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders) => {\n        const channelzSessionInfo = this.sessions.get(stream.session as http2.ServerHttp2Session);\n        if (this.channelzEnabled) {\n          this.callTracker.addCallStarted();\n          channelzSessionInfo?.streamTracker.addCallStarted();\n        }\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n        if (\n          typeof contentType !== 'string' ||\n          !contentType.startsWith('application/grpc')\n        ) {\n          stream.respond(\n            {\n              [http2.constants.HTTP2_HEADER_STATUS]:\n                http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n            },\n            { endStream: true }\n          );\n          this.callTracker.addCallFailed();\n          if (this.channelzEnabled) {\n            channelzSessionInfo?.streamTracker.addCallFailed();\n          }\n          return;\n        }\n\n        let call: Http2ServerCallStream<any, any> | null = null;\n\n        try {\n          const path = headers[http2.constants.HTTP2_HEADER_PATH] as string;\n          const serverAddress = http2Server.address();\n          let serverAddressString = 'null';\n          if (serverAddress) {\n            if (typeof serverAddress === 'string') {\n              serverAddressString = serverAddress;\n            } else {\n              serverAddressString =\n                serverAddress.address + ':' + serverAddress.port;\n            }\n          }\n          this.trace(\n            'Received call to method ' +\n              path +\n              ' at address ' +\n              serverAddressString\n          );\n          const handler = this.handlers.get(path);\n\n          if (handler === undefined) {\n            this.trace(\n              'No handler registered for method ' +\n                path +\n                '. Sending UNIMPLEMENTED status.'\n            );\n            throw getUnimplementedStatusResponse(path);\n          }\n\n          call = new Http2ServerCallStream(stream, handler, this.options);\n          call.once('callEnd', (code: Status) => {\n            if (code === Status.OK) {\n              this.callTracker.addCallSucceeded();\n            } else {\n              this.callTracker.addCallFailed();\n            }\n          });\n          if (this.channelzEnabled && channelzSessionInfo) {\n            call.once('streamEnd', (success: boolean) => {\n              if (success) {\n                channelzSessionInfo.streamTracker.addCallSucceeded();\n              } else {\n                channelzSessionInfo.streamTracker.addCallFailed();\n              }\n            });\n            call.on('sendMessage', () => {\n              channelzSessionInfo.messagesSent += 1;\n              channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on('receiveMessage', () => {\n              channelzSessionInfo.messagesReceived += 1;\n              channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n          }\n          const metadata = call.receiveMetadata(headers);\n          const encoding = (metadata.get('grpc-encoding')[0] as string | undefined) ?? 'identity';\n          metadata.remove('grpc-encoding');\n\n          switch (handler.type) {\n            case 'unary':\n              handleUnary(call, handler as UntypedUnaryHandler, metadata, encoding);\n              break;\n            case 'clientStream':\n              handleClientStreaming(\n                call,\n                handler as UntypedClientStreamingHandler,\n                metadata,\n                encoding\n              );\n              break;\n            case 'serverStream':\n              handleServerStreaming(\n                call,\n                handler as UntypedServerStreamingHandler,\n                metadata,\n                encoding\n              );\n              break;\n            case 'bidi':\n              handleBidiStreaming(\n                call,\n                handler as UntypedBidiStreamingHandler,\n                metadata,\n                encoding\n              );\n              break;\n            default:\n              throw new Error(`Unknown handler type: ${handler.type}`);\n          }\n        } catch (err) {\n          if (!call) {\n            call = new Http2ServerCallStream(stream, null!, this.options);\n            if (this.channelzEnabled) {\n              this.callTracker.addCallFailed();\n              channelzSessionInfo?.streamTracker.addCallFailed()\n            }\n          }\n\n          if (err.code === undefined) {\n            err.code = Status.INTERNAL;\n          }\n\n          call.sendError(err);\n        }\n      }\n    );\n\n    http2Server.on('session', (session) => {\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      let channelzRef: SocketRef;\n      if (this.channelzEnabled) {\n        channelzRef = registerChannelzSocket(session.socket.remoteAddress ?? 'unknown', this.getChannelzSessionInfoGetter(session));\n      } else {\n        channelzRef = {\n          kind: 'socket',\n          id: -1,\n          name: ''\n        }\n      }\n\n      const channelzSessionInfo: ChannelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null\n      };\n\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = session.socket.remoteAddress;\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n      }\n      session.on('close', () => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          unregisterChannelzRef(channelzRef);\n        }\n        this.sessions.delete(session);\n      });\n    });\n  }\n}\n\nasync function handleUnary<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: UnaryHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): Promise<void> {\n  const request = await call.receiveUnaryMessage(encoding);\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  const emitter = new ServerUnaryCallImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    request\n  );\n\n  handler.func(\n    emitter,\n    (\n      err: ServerErrorResponse | ServerStatusResponse | null,\n      value?: ResponseType | null,\n      trailer?: Metadata,\n      flags?: number\n    ) => {\n      call.sendUnaryMessage(err, value, trailer, flags);\n    }\n  );\n}\n\nfunction handleClientStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: ClientStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  const stream = new ServerReadableStreamImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    handler.deserialize,\n    encoding\n  );\n\n  function respond(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    trailer?: Metadata,\n    flags?: number\n  ) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nasync function handleServerStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: ServerStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): Promise<void> {\n  const request = await call.receiveUnaryMessage(encoding);\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  const stream = new ServerWritableStreamImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    handler.serialize,\n    request\n  );\n\n  handler.func(stream);\n}\n\nfunction handleBidiStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: BidiStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  const stream = new ServerDuplexStreamImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    handler.serialize,\n    handler.deserialize,\n    encoding\n  );\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}\n"]},"metadata":{},"sourceType":"script"}