{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst picker_1 = require(\"./picker\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\n\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n\nclass PickFirstLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  static createFromJson(obj) {\n    return new PickFirstLoadBalancingConfig();\n  }\n\n}\n\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\n\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null\n    };\n  }\n\n}\n\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of backend addresses most recently passed to `updateAddressList`.\n     */\n\n    this.latestAddressList = [];\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n\n    this.subchannels = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n\n    this.currentPick = null;\n    this.triedAllSubchannels = false;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      /* If the subchannel we most recently attempted to start connecting\n       * to goes into TRANSIENT_FAILURE, immediately try to start\n       * connecting to the next one instead of waiting for the connection\n       * delay timer. */\n\n      if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.startNextSubchannelConnecting();\n      }\n\n      if (newState === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      } else {\n        if (this.triedAllSubchannels && this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] === this.subchannels.length) {\n          /* If all of the subchannels are IDLE we should go back to a\n           * basic IDLE state where there is no subchannel list to avoid\n           * holding unused resources */\n          this.resetSubchannelList();\n          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n          return;\n        }\n\n        if (this.currentPick === null) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n\n            if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = connectivity_state_1.ConnectivityState.IDLE;\n            }\n\n            if (newLBState !== this.currentState) {\n              if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.updateState(newLBState, new picker_1.UnavailablePicker());\n              } else {\n                this.updateState(newLBState, new picker_1.QueuePicker(this));\n              }\n            }\n          } else {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        }\n      }\n    };\n\n    this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {\n      if (newState !== connectivity_state_1.ConnectivityState.READY) {\n        this.currentPick = null;\n        subchannel.unref();\n        subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n\n        if (this.subchannels.length > 0) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n\n            if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = connectivity_state_1.ConnectivityState.IDLE;\n            }\n\n            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n              this.updateState(newLBState, new picker_1.UnavailablePicker());\n            } else {\n              this.updateState(newLBState, new picker_1.QueuePicker(this));\n            }\n          } else {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        } else {\n          /* We don't need to backoff here because this only happens if a\n           * subchannel successfully connects then disconnects, so it will not\n           * create a loop of attempting to connect to an unreachable backend\n           */\n          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n      }\n    };\n\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  startNextSubchannelConnecting() {\n    if (this.triedAllSubchannels) {\n      return;\n    }\n\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      if (index > this.currentSubchannelIndex) {\n        const subchannelState = subchannel.getConnectivityState();\n\n        if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n\n    this.triedAllSubchannels = true;\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n\n\n  startConnecting(subchannelIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n\n    if (this.subchannels[subchannelIndex].getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.subchannels[subchannelIndex].getAddress());\n      process.nextTick(() => {\n        this.subchannels[subchannelIndex].startConnecting();\n      });\n    }\n\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting();\n    }, CONNECTION_DELAY_INTERVAL_MS);\n  }\n\n  pickSubchannel(subchannel) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n    }\n\n    this.currentPick = subchannel;\n    this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n    subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n\n    this.currentSubchannelIndex = 0;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n    this.triedAllSubchannels = false;\n  }\n  /**\n   * Start connecting to the address list most recently passed to\n   * `updateAddressList`.\n   */\n\n\n  connectToAddressList() {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + this.latestAddressList.map(address => subchannel_address_1.subchannelAddressToString(address)));\n    this.subchannels = this.latestAddressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n\n    for (const subchannel of this.subchannels) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n\n      if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        this.resetSubchannelList();\n        return;\n      }\n    }\n\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      const subchannelState = subchannel.getConnectivityState();\n\n      if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n        this.startConnecting(index);\n\n        if (this.currentPick === null) {\n          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n\n        return;\n      }\n    } // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n\n\n    if (this.currentPick === null) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    }\n  }\n\n  updateAddressList(addressList, lbConfig) {\n    // lbConfig has no useful information for pick first load balancing\n\n    /* To avoid unnecessary churn, we only do something with this address list\n     * if we're not currently trying to establish a connection, or if the new\n     * address list is different from the existing one */\n    if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index) => addressList[index] === value)) {\n      this.latestAddressList = addressList;\n      this.connectToAddressList();\n    }\n  }\n\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      if (this.latestAddressList.length > 0) {\n        this.connectToAddressList();\n      }\n    }\n\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.triedAllSubchannels) {\n      this.channelControlHelper.requestReresolution();\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n    }\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n}\n\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\n\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n  load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);\n}\n\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","trace","text","logging","constants_1","DEBUG","TYPE_NAME","CONNECTION_DELAY_INTERVAL_MS","PickFirstLoadBalancingConfig","getLoadBalancerName","constructor","toJsonObject","createFromJson","obj","exports","PickFirstPicker","subchannel","pick","pickArgs","pickResultType","picker_1","COMPLETE","status","extraFilterFactories","onCallStarted","PickFirstLoadBalancer","channelControlHelper","connectivity_state_1","IDLE","subchannelStateCounts","CONNECTING","READY","SHUTDOWN","TRANSIENT_FAILURE","subchannelStateListener","previousState","newState","subchannels","currentSubchannelIndex","startNextSubchannelConnecting","pickSubchannel","triedAllSubchannels","length","resetSubchannelList","updateState","currentPick","newLBState","currentState","pickedSubchannelStateListener","unref","removeConnectivityStateListener","removeChannelzChild","getChannelzRef","connectionDelayTimeout","setTimeout","clearTimeout","index","entries","subchannelState","getConnectivityState","startConnecting","subchannelIndex","getAddress","process","nextTick","addConnectivityStateListener","ref","addChannelzChild","picker","connectToAddressList","latestAddressList","map","address","subchannel_address_1","createSubchannel","updateAddressList","addressList","lbConfig","every","value","exitIdle","requestReresolution","resetBackoff","destroy","getTypeName","setup","load_balancer_1"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/load-balancer-pick-first.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  registerDefaultLoadBalancerType,\n  registerLoadBalancerType,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { SubchannelInterface, ConnectivityStateListener } from './subchannel-interface';\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n\nexport class PickFirstLoadBalancingConfig implements LoadBalancingConfig {\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {},\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    return new PickFirstLoadBalancingConfig();\n  }\n}\n\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker implements Picker {\n  constructor(private subchannel: SubchannelInterface) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null,\n    };\n  }\n}\n\ninterface ConnectivityStateCounts {\n  [ConnectivityState.CONNECTING]: number;\n  [ConnectivityState.IDLE]: number;\n  [ConnectivityState.READY]: number;\n  [ConnectivityState.SHUTDOWN]: number;\n  [ConnectivityState.TRANSIENT_FAILURE]: number;\n}\n\nexport class PickFirstLoadBalancer implements LoadBalancer {\n  /**\n   * The list of backend addresses most recently passed to `updateAddressList`.\n   */\n  private latestAddressList: SubchannelAddress[] = [];\n  /**\n   * The list of subchannels this load balancer is currently attempting to\n   * connect to.\n   */\n  private subchannels: SubchannelInterface[] = [];\n  /**\n   * The current connectivity state of the load balancer.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The index within the `subchannels` array of the subchannel with the most\n   * recently started connection attempt.\n   */\n  private currentSubchannelIndex = 0;\n\n  private subchannelStateCounts: ConnectivityStateCounts;\n  /**\n   * The currently picked subchannel used for making calls. Populated if\n   * and only if the load balancer's current state is READY. In that case,\n   * the subchannel's current state is also READY.\n   */\n  private currentPick: SubchannelInterface | null = null;\n  /**\n   * Listener callback attached to each subchannel in the `subchannels` list\n   * while establishing a connection.\n   */\n  private subchannelStateListener: ConnectivityStateListener;\n  /**\n   * Listener callback attached to the current picked subchannel.\n   */\n  private pickedSubchannelStateListener: ConnectivityStateListener;\n  /**\n   * Timer reference for the timer tracking when to start\n   */\n  private connectionDelayTimeout: NodeJS.Timeout;\n\n  private triedAllSubchannels = false;\n\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannelStateListener = (\n      subchannel: SubchannelInterface,\n      previousState: ConnectivityState,\n      newState: ConnectivityState\n    ) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      /* If the subchannel we most recently attempted to start connecting\n       * to goes into TRANSIENT_FAILURE, immediately try to start\n       * connecting to the next one instead of waiting for the connection\n       * delay timer. */\n      if (\n        subchannel === this.subchannels[this.currentSubchannelIndex] &&\n        newState === ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        this.startNextSubchannelConnecting();\n      }\n      if (newState === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      } else {\n        if (\n          this.triedAllSubchannels &&\n          this.subchannelStateCounts[ConnectivityState.IDLE] ===\n            this.subchannels.length\n        ) {\n          /* If all of the subchannels are IDLE we should go back to a\n           * basic IDLE state where there is no subchannel list to avoid\n           * holding unused resources */\n          this.resetSubchannelList();\n          this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n          return;\n        }\n        if (this.currentPick === null) {\n          if (this.triedAllSubchannels) {\n            let newLBState: ConnectivityState;\n            if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) {\n              newLBState = ConnectivityState.CONNECTING;\n            } else if (\n              this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] >\n              0\n            ) {\n              newLBState = ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = ConnectivityState.IDLE;\n            }\n            if (newLBState !== this.currentState) {\n              if (newLBState === ConnectivityState.TRANSIENT_FAILURE) {\n                this.updateState(newLBState, new UnavailablePicker());\n              } else {\n                this.updateState(newLBState, new QueuePicker(this));\n              }\n            }\n          } else {\n            this.updateState(\n              ConnectivityState.CONNECTING,\n              new QueuePicker(this)\n            );\n          }\n        }\n      }\n    };\n    this.pickedSubchannelStateListener = (\n      subchannel: SubchannelInterface,\n      previousState: ConnectivityState,\n      newState: ConnectivityState\n    ) => {\n      if (newState !== ConnectivityState.READY) {\n        this.currentPick = null;\n        subchannel.unref();\n        subchannel.removeConnectivityStateListener(\n          this.pickedSubchannelStateListener\n        );\n        this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        if (this.subchannels.length > 0) {\n          if (this.triedAllSubchannels) {\n            let newLBState: ConnectivityState;\n            if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) {\n              newLBState = ConnectivityState.CONNECTING;\n            } else if (\n              this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] >\n              0\n            ) {\n              newLBState = ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = ConnectivityState.IDLE;\n            }\n            if (newLBState === ConnectivityState.TRANSIENT_FAILURE) {\n              this.updateState(newLBState, new UnavailablePicker());\n            } else {\n              this.updateState(newLBState, new QueuePicker(this));\n            }\n          } else {\n            this.updateState(\n              ConnectivityState.CONNECTING,\n              new QueuePicker(this)\n            );\n          }\n        } else {\n          /* We don't need to backoff here because this only happens if a\n           * subchannel successfully connects then disconnects, so it will not\n           * create a loop of attempting to connect to an unreachable backend\n           */\n          this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n        }\n      }\n    };\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  private startNextSubchannelConnecting() {\n    if (this.triedAllSubchannels) {\n      return;\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      if (index > this.currentSubchannelIndex) {\n        const subchannelState = subchannel.getConnectivityState();\n        if (\n          subchannelState === ConnectivityState.IDLE ||\n          subchannelState === ConnectivityState.CONNECTING\n        ) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.triedAllSubchannels = true;\n  }\n\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  private startConnecting(subchannelIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (\n      this.subchannels[subchannelIndex].getConnectivityState() ===\n      ConnectivityState.IDLE\n    ) {\n      trace(\n        'Start connecting to subchannel with address ' +\n          this.subchannels[subchannelIndex].getAddress()\n      );\n      process.nextTick(() => {\n        this.subchannels[subchannelIndex].startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting();\n    }, CONNECTION_DELAY_INTERVAL_MS);\n  }\n\n  private pickSubchannel(subchannel: SubchannelInterface) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.currentPick.removeConnectivityStateListener(\n        this.pickedSubchannelStateListener\n      );\n    }\n    this.currentPick = subchannel;\n    this.updateState(ConnectivityState.READY, new PickFirstPicker(subchannel));\n    subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannels = [];\n    this.triedAllSubchannels = false;\n  }\n\n  /**\n   * Start connecting to the address list most recently passed to\n   * `updateAddressList`.\n   */\n  private connectToAddressList(): void {\n    this.resetSubchannelList();\n    trace(\n      'Connect to address list ' +\n        this.latestAddressList.map((address) =>\n          subchannelAddressToString(address)\n        )\n    );\n    this.subchannels = this.latestAddressList.map((address) =>\n      this.channelControlHelper.createSubchannel(address, {})\n    );\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    for (const subchannel of this.subchannels) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n      if (subchannel.getConnectivityState() === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        this.resetSubchannelList();\n        return;\n      }\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      const subchannelState = subchannel.getConnectivityState();\n      if (\n        subchannelState === ConnectivityState.IDLE ||\n        subchannelState === ConnectivityState.CONNECTING\n      ) {\n        this.startConnecting(index);\n        if (this.currentPick === null) {\n          this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n        }\n        return;\n      }\n    }\n    // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n    if (this.currentPick === null) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker()\n      );\n    }\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig\n  ): void {\n    // lbConfig has no useful information for pick first load balancing\n    /* To avoid unnecessary churn, we only do something with this address list\n     * if we're not currently trying to establish a connection, or if the new\n     * address list is different from the existing one */\n    if (\n      this.subchannels.length === 0 ||\n      !this.latestAddressList.every(\n        (value, index) => addressList[index] === value\n      )\n    ) {\n      this.latestAddressList = addressList;\n      this.connectToAddressList();\n    }\n  }\n\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n    if (this.currentState === ConnectivityState.IDLE) {\n      if (this.latestAddressList.length > 0) {\n        this.connectToAddressList();\n      }\n    }\n    if (\n      this.currentState === ConnectivityState.IDLE ||\n      this.triedAllSubchannels\n    ) {\n      this.channelControlHelper.requestReresolution();\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(\n        this.pickedSubchannelStateListener\n      );\n      this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n    }\n  }\n\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup(): void {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    PickFirstLoadBalancer,\n    PickFirstLoadBalancingConfig\n  );\n  registerDefaultLoadBalancerType(TYPE_NAME);\n}\n"]},"metadata":{},"sourceType":"script"}