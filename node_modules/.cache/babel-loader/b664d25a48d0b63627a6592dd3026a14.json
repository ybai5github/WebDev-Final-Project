{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelCredentials = void 0;\n\nconst tls_1 = require(\"tls\");\n\nconst call_credentials_1 = require(\"./call-credentials\");\n\nconst tls_helpers_1 = require(\"./tls-helpers\"); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\nfunction bufferOrNullEqual(buf1, buf2) {\n  if (buf1 === null && buf2 === null) {\n    return true;\n  } else {\n    return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n  }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\n\n\nclass ChannelCredentials {\n  constructor(callCredentials) {\n    this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n  }\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n\n\n  _getCallCredentials() {\n    return this.callCredentials;\n  }\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n\n\n  static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n    var _a;\n\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n\n    if (privateKey && !certChain) {\n      throw new Error('Private key must be given with accompanying certificate chain');\n    }\n\n    if (!privateKey && certChain) {\n      throw new Error('Certificate chain must be given with accompanying private key');\n    }\n\n    const secureContext = tls_1.createSecureContext({\n      ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : tls_helpers_1.getDefaultRootsData()) !== null && _a !== void 0 ? _a : undefined,\n      key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n      cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n      ciphers: tls_helpers_1.CIPHER_SUITES\n    });\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n\n\n  static createFromSecureContext(secureContext, verifyOptions) {\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n\n\n  static createInsecure() {\n    return new InsecureChannelCredentialsImpl();\n  }\n\n}\n\nexports.ChannelCredentials = ChannelCredentials;\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials) {\n    super(callCredentials);\n  }\n\n  compose(callCredentials) {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions() {\n    return null;\n  }\n\n  _isSecure() {\n    return false;\n  }\n\n  _equals(other) {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(secureContext, verifyOptions) {\n    super();\n    this.secureContext = secureContext;\n    this.verifyOptions = verifyOptions;\n    this.connectionOptions = {\n      secureContext\n    }; // Node asserts that this option is a function, so we cannot pass undefined\n\n    if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n  }\n\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n\n  _getConnectionOptions() {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return Object.assign({}, this.connectionOptions);\n  }\n\n  _isSecure() {\n    return true;\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(channelCredentials, callCreds) {\n    super(callCreds);\n    this.channelCredentials = channelCredentials;\n  }\n\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n  }\n\n  _getConnectionOptions() {\n    return this.channelCredentials._getConnectionOptions();\n  }\n\n  _isSecure() {\n    return true;\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n    } else {\n      return false;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["verifyIsBufferOrNull","obj","friendlyName","Buffer","TypeError","bufferOrNullEqual","buf1","buf2","equals","ChannelCredentials","constructor","callCredentials","call_credentials_1","createEmpty","_getCallCredentials","createSsl","rootCerts","privateKey","certChain","verifyOptions","Error","secureContext","tls_1","ca","tls_helpers_1","_a","undefined","key","cert","ciphers","SecureChannelCredentialsImpl","createFromSecureContext","createInsecure","InsecureChannelCredentialsImpl","exports","compose","_getConnectionOptions","_isSecure","_equals","other","connectionOptions","checkServerIdentity","combinedCallCredentials","ComposedChannelCredentialsImpl","channelCredentials","callCreds"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/channel-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ConnectionOptions, createSecureContext, PeerCertificate, SecureContext } from 'tls';\n\nimport { CallCredentials } from './call-credentials';\nimport { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj: any, friendlyName: string): void {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\n/**\n * A callback that will receive the expected hostname and presented peer\n * certificate as parameters. The callback should return an error to\n * indicate that the presented certificate is considered invalid and\n * otherwise returned undefined.\n */\nexport type CheckServerIdentityCallback = (\n  hostname: string,\n  cert: PeerCertificate\n) => Error | undefined;\n\nfunction bufferOrNullEqual(buf1: Buffer | null, buf2: Buffer | null) {\n  if (buf1 === null && buf2 === null) {\n    return true;\n  } else {\n    return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n  }\n}\n\n/**\n * Additional peer verification options that can be set when creating\n * SSL credentials.\n */\nexport interface VerifyOptions {\n  /**\n   * If set, this callback will be invoked after the usual hostname verification\n   * has been performed on the peer certificate.\n   */\n  checkServerIdentity?: CheckServerIdentityCallback;\n}\n\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nexport abstract class ChannelCredentials {\n  protected callCredentials: CallCredentials;\n\n  protected constructor(callCredentials?: CallCredentials) {\n    this.callCredentials = callCredentials || CallCredentials.createEmpty();\n  }\n  /**\n   * Returns a copy of this object with the included set of per-call credentials\n   * expanded to include callCredentials.\n   * @param callCredentials A CallCredentials object to associate with this\n   * instance.\n   */\n  abstract compose(callCredentials: CallCredentials): ChannelCredentials;\n\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n  _getCallCredentials(): CallCredentials {\n    return this.callCredentials;\n  }\n\n  /**\n   * Gets a SecureContext object generated from input parameters if this\n   * instance was created with createSsl, or null if this instance was created\n   * with createInsecure.\n   */\n  abstract _getConnectionOptions(): ConnectionOptions | null;\n\n  /**\n   * Indicates whether this credentials object creates a secure channel.\n   */\n  abstract _isSecure(): boolean;\n\n  /**\n   * Check whether two channel credentials objects are equal. Two secure\n   * credentials are equal if they were constructed with the same parameters.\n   * @param other The other ChannelCredentials Object\n   */\n  abstract _equals(other: ChannelCredentials): boolean;\n\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(\n    rootCerts?: Buffer | null,\n    privateKey?: Buffer | null,\n    certChain?: Buffer | null,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error(\n        'Private key must be given with accompanying certificate chain'\n      );\n    }\n    if (!privateKey && certChain) {\n      throw new Error(\n        'Certificate chain must be given with accompanying private key'\n      );\n    }\n    const secureContext = createSecureContext({\n      ca: rootCerts ?? getDefaultRootsData() ?? undefined,\n      key: privateKey ?? undefined,\n      cert: certChain ?? undefined,\n      ciphers: CIPHER_SUITES,\n    });\n    return new SecureChannelCredentialsImpl(\n      secureContext,\n      verifyOptions ?? {}\n    );\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(secureContext: SecureContext, verifyOptions?: VerifyOptions): ChannelCredentials {\n    return new SecureChannelCredentialsImpl(\n      secureContext,\n      verifyOptions ?? {}\n    )\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure(): ChannelCredentials {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials?: CallCredentials) {\n    super(callCredentials);\n  }\n\n  compose(callCredentials: CallCredentials): never {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return null;\n  }\n  _isSecure(): boolean {\n    return false;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  connectionOptions: ConnectionOptions;\n\n  constructor(\n    private secureContext: SecureContext,\n    private verifyOptions: VerifyOptions\n  ) {\n    super();\n    this.connectionOptions = { \n      secureContext\n    };\n    // Node asserts that this option is a function, so we cannot pass undefined\n    if (verifyOptions?.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n  }\n\n  compose(callCredentials: CallCredentials): ChannelCredentials {\n    const combinedCallCredentials = this.callCredentials.compose(\n      callCredentials\n    );\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return { ...this.connectionOptions };\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return (\n        this.secureContext === other.secureContext && \n        this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity\n        );\n    } else {\n      return false;\n    }\n  }\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(\n    private channelCredentials: SecureChannelCredentialsImpl,\n    callCreds: CallCredentials\n  ) {\n    super(callCreds);\n  }\n  compose(callCredentials: CallCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(\n      callCredentials\n    );\n    return new ComposedChannelCredentialsImpl(\n      this.channelCredentials,\n      combinedCallCredentials\n    );\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return this.channelCredentials._getConnectionOptions();\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return (\n        this.channelCredentials._equals(other.channelCredentials) &&\n        this.callCredentials._equals(other.callCredentials)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}