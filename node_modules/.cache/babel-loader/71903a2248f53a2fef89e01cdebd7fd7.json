{"ast":null,"code":"\"use strict\";\n\nvar $protobuf = require(\"../..\");\n\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require(\"../../google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace,\n    Root = $protobuf.Root,\n    Enum = $protobuf.Enum,\n    Type = $protobuf.Type,\n    Field = $protobuf.Field,\n    MapField = $protobuf.MapField,\n    OneOf = $protobuf.OneOf,\n    Service = $protobuf.Service,\n    Method = $protobuf.Method; // --- Root ---\n\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */\n\n/**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */\n\n/**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */\n\n/**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */\n\n/**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */\n\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n  var root = new Root();\n\n  if (descriptor.file) {\n    var fileDescriptor, filePackage;\n\n    for (var j = 0, i; j < descriptor.file.length; ++j) {\n      filePackage = root;\n      if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n      if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n      if (fileDescriptor.messageType) for (i = 0; i < fileDescriptor.messageType.length; ++i) filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n      if (fileDescriptor.enumType) for (i = 0; i < fileDescriptor.enumType.length; ++i) filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n      if (fileDescriptor.extension) for (i = 0; i < fileDescriptor.extension.length; ++i) filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n      if (fileDescriptor.service) for (i = 0; i < fileDescriptor.service.length; ++i) filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n      var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n\n      if (opts) {\n        var ks = Object.keys(opts);\n\n        for (i = 0; i < ks.length; ++i) filePackage.setOption(ks[i], opts[ks[i]]);\n      }\n    }\n  }\n\n  return root;\n};\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\n\n\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\n  var set = exports.FileDescriptorSet.create();\n  Root_toDescriptorRecursive(this, set.file, syntax);\n  return set;\n}; // Traverses a namespace and assembles the descriptor set\n\n\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n  // Create a new file\n  var file = exports.FileDescriptorProto.create({\n    name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n  });\n  if (syntax) file.syntax = syntax;\n  if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1); // Add nested types\n\n  for (var i = 0, nested; i < ns.nestedArray.length; ++i) if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(syntax));else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());else if (nested instanceof Field) file.extension.push(nested.toDescriptor(syntax));else if (nested instanceof Service) file.service.push(nested.toDescriptor());else if (nested instanceof\n  /* plain */\n  Namespace) Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n  // Keep package-level options\n\n\n  file.options = toDescriptorOptions(ns.options, exports.FileOptions); // And keep the file only if there is at least one nested object\n\n  if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n} // --- Type ---\n\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */\n\n/**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */\n\n/**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\n/**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\n\nvar unnamedMessageIndex = 0;\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */\n\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor); // Create the message type\n\n  var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\n      i;\n  /* Oneofs */\n\n  if (descriptor.oneofDecl) for (i = 0; i < descriptor.oneofDecl.length; ++i) type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n  /* Fields */\n\n  if (descriptor.field) for (i = 0; i < descriptor.field.length; ++i) {\n    var field = Field.fromDescriptor(descriptor.field[i], syntax);\n    type.add(field);\n    if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) // eslint-disable-line no-prototype-builtins\n      type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n  }\n  /* Extension fields */\n\n  if (descriptor.extension) for (i = 0; i < descriptor.extension.length; ++i) type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n  /* Nested types */\n\n  if (descriptor.nestedType) for (i = 0; i < descriptor.nestedType.length; ++i) {\n    type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n    if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n  }\n  /* Nested enums */\n\n  if (descriptor.enumType) for (i = 0; i < descriptor.enumType.length; ++i) type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n  /* Extension ranges */\n\n  if (descriptor.extensionRange && descriptor.extensionRange.length) {\n    type.extensions = [];\n\n    for (i = 0; i < descriptor.extensionRange.length; ++i) type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);\n  }\n  /* Reserved... */\n\n\n  if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n    type.reserved = [];\n    /* Ranges */\n\n    if (descriptor.reservedRange) for (i = 0; i < descriptor.reservedRange.length; ++i) type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);\n    /* Names */\n\n    if (descriptor.reservedName) for (i = 0; i < descriptor.reservedName.length; ++i) type.reserved.push(descriptor.reservedName[i]);\n  }\n\n  return type;\n};\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\n\n\nType.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.DescriptorProto.create({\n    name: this.name\n  }),\n      i;\n  /* Fields */\n\n  for (i = 0; i < this.fieldsArray.length; ++i) {\n    var fieldDescriptor;\n    descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n\n    if (this._fieldsArray[i] instanceof MapField) {\n      // map fields are repeated FieldNameEntry\n      var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\n          valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\n          valueTypeName = valueType ===\n      /* type */\n      11 || valueType ===\n      /* enum */\n      14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n      descriptor.nestedType.push(exports.DescriptorProto.create({\n        name: fieldDescriptor.typeName,\n        field: [exports.FieldDescriptorProto.create({\n          name: \"key\",\n          number: 1,\n          label: 1,\n          type: keyType\n        }), // can't reference a type or enum\n        exports.FieldDescriptorProto.create({\n          name: \"value\",\n          number: 2,\n          label: 1,\n          type: valueType,\n          typeName: valueTypeName\n        })],\n        options: exports.MessageOptions.create({\n          mapEntry: true\n        })\n      }));\n    }\n  }\n  /* Oneofs */\n\n\n  for (i = 0; i < this.oneofsArray.length; ++i) descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n  /* Nested... */\n\n\n  for (i = 0; i < this.nestedArray.length; ++i) {\n    /* Extension fields */\n    if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n    /* Types */\n    else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n    /* Enums */\n    else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor()); // plain nested namespaces become packages instead in Root#toDescriptor\n  }\n  /* Extension ranges */\n\n\n  if (this.extensions) for (i = 0; i < this.extensions.length; ++i) descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n    start: this.extensions[i][0],\n    end: this.extensions[i][1]\n  }));\n  /* Reserved... */\n\n  if (this.reserved) for (i = 0; i < this.reserved.length; ++i)\n  /* Names */\n  if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n  /* Ranges */\n  else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n    start: this.reserved[i][0],\n    end: this.reserved[i][1]\n  }));\n  descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n  return descriptor;\n}; // --- Field ---\n\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */\n\n/**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */\n\n/**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */\n\n/**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */\n\n/**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */\n// copied here from parse.js\n\n\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */\n\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n  if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\"); // Rewire field type\n\n  var fieldType;\n  if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;else fieldType = fromDescriptorType(descriptor.type); // Rewire field rule\n\n  var fieldRule;\n\n  switch (descriptor.label) {\n    // 0 is reserved for errors\n    case 1:\n      fieldRule = undefined;\n      break;\n\n    case 2:\n      fieldRule = \"required\";\n      break;\n\n    case 3:\n      fieldRule = \"repeated\";\n      break;\n\n    default:\n      throw Error(\"illegal label: \" + descriptor.label);\n  }\n\n  var extendee = descriptor.extendee;\n\n  if (descriptor.extendee !== undefined) {\n    extendee = extendee.length ? extendee : undefined;\n  }\n\n  var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n  field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n\n  if (descriptor.defaultValue && descriptor.defaultValue.length) {\n    var defaultValue = descriptor.defaultValue;\n\n    switch (defaultValue) {\n      case \"true\":\n      case \"TRUE\":\n        defaultValue = true;\n        break;\n\n      case \"false\":\n      case \"FALSE\":\n        defaultValue = false;\n        break;\n\n      default:\n        var match = numberRe.exec(defaultValue);\n        if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n\n        break;\n    }\n\n    field.setOption(\"default\", defaultValue);\n  }\n\n  if (packableDescriptorType(descriptor.type)) {\n    if (syntax === \"proto3\") {\n      // defaults to packed=true (internal preset is packed=true)\n      if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n    } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false\n      field.setOption(\"packed\", false);\n  }\n\n  return field;\n};\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\n\n\nField.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.FieldDescriptorProto.create({\n    name: this.name,\n    number: this.id\n  });\n\n  if (this.map) {\n    descriptor.type = 11; // message\n\n    descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n\n    descriptor.label = 3; // repeated\n  } else {\n    // Rewire field type\n    switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\n      case 10: // group\n\n      case 11: // type\n\n      case 14:\n        // enum\n        descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n        break;\n    } // Rewire field rule\n\n\n    switch (this.rule) {\n      case \"repeated\":\n        descriptor.label = 3;\n        break;\n\n      case \"required\":\n        descriptor.label = 2;\n        break;\n\n      default:\n        descriptor.label = 1;\n        break;\n    }\n  } // Handle extension field\n\n\n  descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend; // Handle part of oneof\n\n  if (this.partOf) if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n\n  if (this.options) {\n    descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n    if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n  }\n\n  if (syntax === \"proto3\") {\n    // defaults to packed=true\n    if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n  } else if (this.packed) // defaults to packed=false\n    (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n\n  return descriptor;\n}; // --- Enum ---\n\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */\n\n/**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */\n\n/**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */\n\n\nvar unnamedEnumIndex = 0;\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */\n\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor); // Construct values object\n\n  var values = {};\n  if (descriptor.value) for (var i = 0; i < descriptor.value.length; ++i) {\n    var name = descriptor.value[i].name,\n        value = descriptor.value[i].number || 0;\n    values[name && name.length ? name : \"NAME\" + value] = value;\n  }\n  return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n};\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */\n\n\nEnum.prototype.toDescriptor = function toDescriptor() {\n  // Values\n  var values = [];\n\n  for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i) values.push(exports.EnumValueDescriptorProto.create({\n    name: ks[i],\n    number: this.values[ks[i]]\n  }));\n\n  return exports.EnumDescriptorProto.create({\n    name: this.name,\n    value: values,\n    options: toDescriptorOptions(this.options, exports.EnumOptions)\n  });\n}; // --- OneOf ---\n\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */\n\n\nvar unnamedOneofIndex = 0;\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */\n\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n  return new OneOf( // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++ // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\n  );\n};\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */\n\n\nOneOf.prototype.toDescriptor = function toDescriptor() {\n  return exports.OneofDescriptorProto.create({\n    name: this.name // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\n\n  });\n}; // --- Service ---\n\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */\n\n/**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */\n\n\nvar unnamedServiceIndex = 0;\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */\n\nService.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n  var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n  if (descriptor.method) for (var i = 0; i < descriptor.method.length; ++i) service.add(Method.fromDescriptor(descriptor.method[i]));\n  return service;\n};\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */\n\n\nService.prototype.toDescriptor = function toDescriptor() {\n  // Methods\n  var methods = [];\n\n  for (var i = 0; i < this.methodsArray.length; ++i) methods.push(this._methodsArray[i].toDescriptor());\n\n  return exports.ServiceDescriptorProto.create({\n    name: this.name,\n    method: methods,\n    options: toDescriptorOptions(this.options, exports.ServiceOptions)\n  });\n}; // --- Method ---\n\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */\n\n/**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */\n\n\nvar unnamedMethodIndex = 0;\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */\n\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n  return new Method( // unnamedMethodIndex is global, not per service, because we have no ref to a service here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */\n\n\nMethod.prototype.toDescriptor = function toDescriptor() {\n  return exports.MethodDescriptorProto.create({\n    name: this.name,\n    inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n    outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n    clientStreaming: this.requestStream,\n    serverStreaming: this.responseStream,\n    options: toDescriptorOptions(this.options, exports.MethodOptions)\n  });\n}; // --- utility ---\n// Converts a descriptor type to a protobuf.js basic type\n\n\nfunction fromDescriptorType(type) {\n  switch (type) {\n    // 0 is reserved for errors\n    case 1:\n      return \"double\";\n\n    case 2:\n      return \"float\";\n\n    case 3:\n      return \"int64\";\n\n    case 4:\n      return \"uint64\";\n\n    case 5:\n      return \"int32\";\n\n    case 6:\n      return \"fixed64\";\n\n    case 7:\n      return \"fixed32\";\n\n    case 8:\n      return \"bool\";\n\n    case 9:\n      return \"string\";\n\n    case 12:\n      return \"bytes\";\n\n    case 13:\n      return \"uint32\";\n\n    case 15:\n      return \"sfixed32\";\n\n    case 16:\n      return \"sfixed64\";\n\n    case 17:\n      return \"sint32\";\n\n    case 18:\n      return \"sint64\";\n  }\n\n  throw Error(\"illegal type: \" + type);\n} // Tests if a descriptor type is packable\n\n\nfunction packableDescriptorType(type) {\n  switch (type) {\n    case 1: // double\n\n    case 2: // float\n\n    case 3: // int64\n\n    case 4: // uint64\n\n    case 5: // int32\n\n    case 6: // fixed64\n\n    case 7: // fixed32\n\n    case 8: // bool\n\n    case 13: // uint32\n\n    case 14: // enum (!)\n\n    case 15: // sfixed32\n\n    case 16: // sfixed64\n\n    case 17: // sint32\n\n    case 18:\n      // sint64\n      return true;\n  }\n\n  return false;\n} // Converts a protobuf.js basic type to a descriptor type\n\n\nfunction toDescriptorType(type, resolvedType) {\n  switch (type) {\n    // 0 is reserved for errors\n    case \"double\":\n      return 1;\n\n    case \"float\":\n      return 2;\n\n    case \"int64\":\n      return 3;\n\n    case \"uint64\":\n      return 4;\n\n    case \"int32\":\n      return 5;\n\n    case \"fixed64\":\n      return 6;\n\n    case \"fixed32\":\n      return 7;\n\n    case \"bool\":\n      return 8;\n\n    case \"string\":\n      return 9;\n\n    case \"bytes\":\n      return 12;\n\n    case \"uint32\":\n      return 13;\n\n    case \"sfixed32\":\n      return 15;\n\n    case \"sfixed64\":\n      return 16;\n\n    case \"sint32\":\n      return 17;\n\n    case \"sint64\":\n      return 18;\n  }\n\n  if (resolvedType instanceof Enum) return 14;\n  if (resolvedType instanceof Type) return resolvedType.group ? 10 : 11;\n  throw Error(\"illegal type: \" + type);\n} // Converts descriptor options to an options object\n\n\nfunction fromDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n\n  for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i) if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\") if (options.hasOwnProperty(key)) {\n    // eslint-disable-line no-prototype-builtins\n    val = options[key];\n    if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined) val = field.resolvedType.valuesById[val];\n    out.push(underScore(key), val);\n  }\n\n  return out.length ? $protobuf.util.toObject(out) : undefined;\n} // Converts an options object to descriptor options\n\n\nfunction toDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n\n  for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\n    val = options[key = ks[i]];\n    if (key === \"default\") continue;\n    var field = type.fields[key];\n    if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)])) continue;\n    out.push(key, val);\n  }\n\n  return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n} // Calculates the shortest relative path from `from` to `to`.\n\n\nfunction shortname(from, to) {\n  var fromPath = from.fullName.split(\".\"),\n      toPath = to.fullName.split(\".\"),\n      i = 0,\n      j = 0,\n      k = toPath.length - 1;\n  if (!(from instanceof Root) && to instanceof Namespace) while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\n    var other = to.lookup(fromPath[i++], true);\n    if (other !== null && other !== to) break;\n    ++j;\n  } else for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n  return toPath.slice(j).join(\".\");\n} // copied here from cli/targets/proto.js\n\n\nfunction underScore(str) {\n  return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function ($0, $1) {\n    return \"_\" + $1.toLowerCase();\n  });\n} // --- exports ---\n\n/**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */\n\n/**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */\n\n/**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */\n\n/**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */","map":{"version":3,"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/protobufjs/ext/descriptor/index.js"],"names":["$protobuf","require","module","exports","descriptor","Root","fromJSON","lookup","Namespace","Enum","Type","Field","MapField","OneOf","Service","Method","fromDescriptor","length","FileDescriptorSet","decode","root","file","fileDescriptor","filePackage","j","i","define","name","files","push","filename","messageType","add","syntax","enumType","extension","service","opts","fromDescriptorOptions","options","FileOptions","ks","Object","keys","setOption","prototype","toDescriptor","set","create","Root_toDescriptorRecursive","ns","FileDescriptorProto","fullName","substring","replace","nested","nestedArray","_nestedArray","toDescriptorOptions","unnamedMessageIndex","DescriptorProto","type","MessageOptions","oneofDecl","field","hasOwnProperty","oneofsArray","oneofIndex","nestedType","mapEntry","extensionRange","extensions","start","end","reservedRange","reservedName","reserved","fieldsArray","fieldDescriptor","_fieldsArray","keyType","toDescriptorType","resolvedKeyType","valueType","resolvedType","valueTypeName","shortname","parent","undefined","typeName","FieldDescriptorProto","number","label","_oneofsArray","ExtensionRange","ReservedRange","numberRe","Error","fieldType","fromDescriptorType","fieldRule","extendee","FieldOptions","defaultValue","match","exec","parseInt","packableDescriptorType","packed","id","map","util","ucFirst","resolve","rule","extensionField","extend","partOf","indexOf","String","unnamedEnumIndex","EnumDescriptorProto","values","value","EnumOptions","EnumValueDescriptorProto","unnamedOneofIndex","OneofDescriptorProto","unnamedServiceIndex","ServiceDescriptorProto","ServiceOptions","method","methods","methodsArray","_methodsArray","unnamedMethodIndex","MethodDescriptorProto","inputType","outputType","Boolean","clientStreaming","serverStreaming","MethodOptions","resolvedRequestType","requestType","resolvedResponseType","responseType","requestStream","responseStream","group","out","key","val","valuesById","underScore","toObject","fields","camelCase","fromObject","from","to","fromPath","split","toPath","k","other","slice","join","str","$0","$1","toLowerCase"],"mappings":"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AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nvar $protobuf = require(\"../..\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require(\"../../google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\n\nvar Namespace = $protobuf.Namespace,\n    Root      = $protobuf.Root,\n    Enum      = $protobuf.Enum,\n    Type      = $protobuf.Type,\n    Field     = $protobuf.Field,\n    MapField  = $protobuf.MapField,\n    OneOf     = $protobuf.OneOf,\n    Service   = $protobuf.Service,\n    Method    = $protobuf.Method;\n\n// --- Root ---\n\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */\n\n/**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */\n\n/**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */\n\n/**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */\n\n/**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.FileDescriptorSet.decode(descriptor);\n\n    var root = new Root();\n\n    if (descriptor.file) {\n        var fileDescriptor,\n            filePackage;\n        for (var j = 0, i; j < descriptor.file.length; ++j) {\n            filePackage = root;\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length)\n                filePackage = root.define(fileDescriptor[\"package\"]);\n            if (fileDescriptor.name && fileDescriptor.name.length)\n                root.files.push(filePackage.filename = fileDescriptor.name);\n            if (fileDescriptor.messageType)\n                for (i = 0; i < fileDescriptor.messageType.length; ++i)\n                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n            if (fileDescriptor.enumType)\n                for (i = 0; i < fileDescriptor.enumType.length; ++i)\n                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n            if (fileDescriptor.extension)\n                for (i = 0; i < fileDescriptor.extension.length; ++i)\n                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n            if (fileDescriptor.service)\n                for (i = 0; i < fileDescriptor.service.length; ++i)\n                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n            if (opts) {\n                var ks = Object.keys(opts);\n                for (i = 0; i < ks.length; ++i)\n                    filePackage.setOption(ks[i], opts[ks[i]]);\n            }\n        }\n    }\n\n    return root;\n};\n\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\n    var set = exports.FileDescriptorSet.create();\n    Root_toDescriptorRecursive(this, set.file, syntax);\n    return set;\n};\n\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n\n    // Create a new file\n    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\" });\n    if (syntax)\n        file.syntax = syntax;\n    if (!(ns instanceof Root))\n        file[\"package\"] = ns.fullName.substring(1);\n\n    // Add nested types\n    for (var i = 0, nested; i < ns.nestedArray.length; ++i)\n        if ((nested = ns._nestedArray[i]) instanceof Type)\n            file.messageType.push(nested.toDescriptor(syntax));\n        else if (nested instanceof Enum)\n            file.enumType.push(nested.toDescriptor());\n        else if (nested instanceof Field)\n            file.extension.push(nested.toDescriptor(syntax));\n        else if (nested instanceof Service)\n            file.service.push(nested.toDescriptor());\n        else if (nested instanceof /* plain */ Namespace)\n            Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n\n    // Keep package-level options\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n\n    // And keep the file only if there is at least one nested object\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)\n        files.push(file);\n}\n\n// --- Type ---\n\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */\n\n/**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */\n\n/**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\n/**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\nvar unnamedMessageIndex = 0;\n\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.DescriptorProto.decode(descriptor);\n\n    // Create the message type\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\n        i;\n\n    /* Oneofs */ if (descriptor.oneofDecl)\n        for (i = 0; i < descriptor.oneofDecl.length; ++i)\n            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n    /* Fields */ if (descriptor.field)\n        for (i = 0; i < descriptor.field.length; ++i) {\n            var field = Field.fromDescriptor(descriptor.field[i], syntax);\n            type.add(field);\n            if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) // eslint-disable-line no-prototype-builtins\n                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n        }\n    /* Extension fields */ if (descriptor.extension)\n        for (i = 0; i < descriptor.extension.length; ++i)\n            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n    /* Nested types */ if (descriptor.nestedType)\n        for (i = 0; i < descriptor.nestedType.length; ++i) {\n            type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n            if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)\n                type.setOption(\"map_entry\", true);\n        }\n    /* Nested enums */ if (descriptor.enumType)\n        for (i = 0; i < descriptor.enumType.length; ++i)\n            type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\n        type.extensions = [];\n        for (i = 0; i < descriptor.extensionRange.length; ++i)\n            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);\n    }\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n        type.reserved = [];\n        /* Ranges */ if (descriptor.reservedRange)\n            for (i = 0; i < descriptor.reservedRange.length; ++i)\n                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);\n        /* Names */ if (descriptor.reservedName)\n            for (i = 0; i < descriptor.reservedName.length; ++i)\n                type.reserved.push(descriptor.reservedName[i]);\n    }\n\n    return type;\n};\n\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nType.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.DescriptorProto.create({ name: this.name }),\n        i;\n\n    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {\n        var fieldDescriptor;\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\n                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\n                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14\n                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type\n                    : undefined;\n            descriptor.nestedType.push(exports.DescriptorProto.create({\n                name: fieldDescriptor.typeName,\n                field: [\n                    exports.FieldDescriptorProto.create({ name: \"key\", number: 1, label: 1, type: keyType }), // can't reference a type or enum\n                    exports.FieldDescriptorProto.create({ name: \"value\", number: 2, label: 1, type: valueType, typeName: valueTypeName })\n                ],\n                options: exports.MessageOptions.create({ mapEntry: true })\n            }));\n        }\n    }\n    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)\n        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field)\n            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n        /* Types */ else if (this._nestedArray[i] instanceof Type)\n            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n        /* Enums */ else if (this._nestedArray[i] instanceof Enum)\n            descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n        // plain nested namespaces become packages instead in Root#toDescriptor\n    }\n    /* Extension ranges */ if (this.extensions)\n        for (i = 0; i < this.extensions.length; ++i)\n            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));\n    /* Reserved... */ if (this.reserved)\n        for (i = 0; i < this.reserved.length; ++i)\n            /* Names */ if (typeof this.reserved[i] === \"string\")\n                descriptor.reservedName.push(this.reserved[i]);\n            /* Ranges */ else\n                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));\n\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n\n    return descriptor;\n};\n\n// --- Field ---\n\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */\n\n/**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */\n\n/**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */\n\n/**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */\n\n/**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */\n\n// copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.DescriptorProto.decode(descriptor);\n\n    if (typeof descriptor.number !== \"number\")\n        throw Error(\"missing field id\");\n\n    // Rewire field type\n    var fieldType;\n    if (descriptor.typeName && descriptor.typeName.length)\n        fieldType = descriptor.typeName;\n    else\n        fieldType = fromDescriptorType(descriptor.type);\n\n    // Rewire field rule\n    var fieldRule;\n    switch (descriptor.label) {\n        // 0 is reserved for errors\n        case 1: fieldRule = undefined; break;\n        case 2: fieldRule = \"required\"; break;\n        case 3: fieldRule = \"repeated\"; break;\n        default: throw Error(\"illegal label: \" + descriptor.label);\n    }\n\n\tvar extendee = descriptor.extendee;\n\tif (descriptor.extendee !== undefined) {\n\t\textendee = extendee.length ? extendee : undefined;\n\t}\n    var field = new Field(\n        descriptor.name.length ? descriptor.name : \"field\" + descriptor.number,\n        descriptor.number,\n        fieldType,\n        fieldRule,\n        extendee\n    );\n\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\n        var defaultValue = descriptor.defaultValue;\n        switch (defaultValue) {\n            case \"true\": case \"TRUE\":\n                defaultValue = true;\n                break;\n            case \"false\": case \"FALSE\":\n                defaultValue = false;\n                break;\n            default:\n                var match = numberRe.exec(defaultValue);\n                if (match)\n                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n                break;\n        }\n        field.setOption(\"default\", defaultValue);\n    }\n\n    if (packableDescriptorType(descriptor.type)) {\n        if (syntax === \"proto3\") { // defaults to packed=true (internal preset is packed=true)\n            if (descriptor.options && !descriptor.options.packed)\n                field.setOption(\"packed\", false);\n        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false\n            field.setOption(\"packed\", false);\n    }\n\n    return field;\n};\n\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nField.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });\n\n    if (this.map) {\n\n        descriptor.type = 11; // message\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n        descriptor.label = 3; // repeated\n\n    } else {\n\n        // Rewire field type\n        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\n            case 10: // group\n            case 11: // type\n            case 14: // enum\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n                break;\n        }\n\n        // Rewire field rule\n        switch (this.rule) {\n            case \"repeated\": descriptor.label = 3; break;\n            case \"required\": descriptor.label = 2; break;\n            default: descriptor.label = 1; break;\n        }\n\n    }\n\n    // Handle extension field\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n\n    // Handle part of oneof\n    if (this.partOf)\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)\n            throw Error(\"missing oneof\");\n\n    if (this.options) {\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n        if (this.options[\"default\"] != null)\n            descriptor.defaultValue = String(this.options[\"default\"]);\n    }\n\n    if (syntax === \"proto3\") { // defaults to packed=true\n        if (!this.packed)\n            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n    } else if (this.packed) // defaults to packed=false\n        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n\n    return descriptor;\n};\n\n// --- Enum ---\n\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */\n\n/**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */\n\n/**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */\n\nvar unnamedEnumIndex = 0;\n\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.EnumDescriptorProto.decode(descriptor);\n\n    // Construct values object\n    var values = {};\n    if (descriptor.value)\n        for (var i = 0; i < descriptor.value.length; ++i) {\n            var name  = descriptor.value[i].name,\n                value = descriptor.value[i].number || 0;\n            values[name && name.length ? name : \"NAME\" + value] = value;\n        }\n\n    return new Enum(\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++,\n        values,\n        fromDescriptorOptions(descriptor.options, exports.EnumOptions)\n    );\n};\n\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */\nEnum.prototype.toDescriptor = function toDescriptor() {\n\n    // Values\n    var values = [];\n    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)\n        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));\n\n    return exports.EnumDescriptorProto.create({\n        name: this.name,\n        value: values,\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\n    });\n};\n\n// --- OneOf ---\n\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */\n\nvar unnamedOneofIndex = 0;\n\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.OneofDescriptorProto.decode(descriptor);\n\n    return new OneOf(\n        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n        descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++\n        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\n    );\n};\n\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */\nOneOf.prototype.toDescriptor = function toDescriptor() {\n    return exports.OneofDescriptorProto.create({\n        name: this.name\n        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\n    });\n};\n\n// --- Service ---\n\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */\n\n/**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedServiceIndex = 0;\n\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */\nService.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n    if (descriptor.method)\n        for (var i = 0; i < descriptor.method.length; ++i)\n            service.add(Method.fromDescriptor(descriptor.method[i]));\n\n    return service;\n};\n\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */\nService.prototype.toDescriptor = function toDescriptor() {\n\n    // Methods\n    var methods = [];\n    for (var i = 0; i < this.methodsArray.length; ++i)\n        methods.push(this._methodsArray[i].toDescriptor());\n\n    return exports.ServiceDescriptorProto.create({\n        name: this.name,\n        method: methods,\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\n    });\n};\n\n// --- Method ---\n\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */\n\n/**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedMethodIndex = 0;\n\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.MethodDescriptorProto.decode(descriptor);\n\n    return new Method(\n        // unnamedMethodIndex is global, not per service, because we have no ref to a service here\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++,\n        \"rpc\",\n        descriptor.inputType,\n        descriptor.outputType,\n        Boolean(descriptor.clientStreaming),\n        Boolean(descriptor.serverStreaming),\n        fromDescriptorOptions(descriptor.options, exports.MethodOptions)\n    );\n};\n\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */\nMethod.prototype.toDescriptor = function toDescriptor() {\n    return exports.MethodDescriptorProto.create({\n        name: this.name,\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n        clientStreaming: this.requestStream,\n        serverStreaming: this.responseStream,\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\n    });\n};\n\n// --- utility ---\n\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n    switch (type) {\n        // 0 is reserved for errors\n        case 1: return \"double\";\n        case 2: return \"float\";\n        case 3: return \"int64\";\n        case 4: return \"uint64\";\n        case 5: return \"int32\";\n        case 6: return \"fixed64\";\n        case 7: return \"fixed32\";\n        case 8: return \"bool\";\n        case 9: return \"string\";\n        case 12: return \"bytes\";\n        case 13: return \"uint32\";\n        case 15: return \"sfixed32\";\n        case 16: return \"sfixed64\";\n        case 17: return \"sint32\";\n        case 18: return \"sint64\";\n    }\n    throw Error(\"illegal type: \" + type);\n}\n\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n    switch (type) {\n        case 1: // double\n        case 2: // float\n        case 3: // int64\n        case 4: // uint64\n        case 5: // int32\n        case 6: // fixed64\n        case 7: // fixed32\n        case 8: // bool\n        case 13: // uint32\n        case 14: // enum (!)\n        case 15: // sfixed32\n        case 16: // sfixed64\n        case 17: // sint32\n        case 18: // sint64\n            return true;\n    }\n    return false;\n}\n\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType) {\n    switch (type) {\n        // 0 is reserved for errors\n        case \"double\": return 1;\n        case \"float\": return 2;\n        case \"int64\": return 3;\n        case \"uint64\": return 4;\n        case \"int32\": return 5;\n        case \"fixed64\": return 6;\n        case \"fixed32\": return 7;\n        case \"bool\": return 8;\n        case \"string\": return 9;\n        case \"bytes\": return 12;\n        case \"uint32\": return 13;\n        case \"sfixed32\": return 15;\n        case \"sfixed64\": return 16;\n        case \"sint32\": return 17;\n        case \"sint64\": return 18;\n    }\n    if (resolvedType instanceof Enum)\n        return 14;\n    if (resolvedType instanceof Type)\n        return resolvedType.group ? 10 : 11;\n    throw Error(\"illegal type: \" + type);\n}\n\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n    if (!options)\n        return undefined;\n    var out = [];\n    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)\n        if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\")\n            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins\n                val = options[key];\n                if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined)\n                    val = field.resolvedType.valuesById[val];\n                out.push(underScore(key), val);\n            }\n    return out.length ? $protobuf.util.toObject(out) : undefined;\n}\n\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n    if (!options)\n        return undefined;\n    var out = [];\n    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\n        val = options[key = ks[i]];\n        if (key === \"default\")\n            continue;\n        var field = type.fields[key];\n        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))\n            continue;\n        out.push(key, val);\n    }\n    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n}\n\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n    var fromPath = from.fullName.split(\".\"),\n        toPath = to.fullName.split(\".\"),\n        i = 0,\n        j = 0,\n        k = toPath.length - 1;\n    if (!(from instanceof Root) && to instanceof Namespace)\n        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\n            var other = to.lookup(fromPath[i++], true);\n            if (other !== null && other !== to)\n                break;\n            ++j;\n        }\n    else\n        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n    return toPath.slice(j).join(\".\");\n}\n\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n    return str.substring(0,1)\n         + str.substring(1)\n               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return \"_\" + $1.toLowerCase(); });\n}\n\n// --- exports ---\n\n/**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */\n\n/**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */\n\n/**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */\n\n/**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */\n"]},"metadata":{},"sourceType":"script"}