{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    this.multiplier = BACKOFF_MULTIPLIER;\n    this.maxDelay = MAX_BACKOFF_MS;\n    this.jitter = BACKOFF_JITTER;\n    this.running = false;\n    this.hasRef = true;\n\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n\n\n  runOnce() {\n    var _a, _b;\n\n    this.running = true;\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, this.nextDelay);\n\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n\n\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value.\n   */\n\n\n  reset() {\n    this.nextDelay = this.initialDelay;\n  }\n\n  isRunning() {\n    return this.running;\n  }\n\n  ref() {\n    var _a, _b;\n\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n\n  unref() {\n    var _a, _b;\n\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n\n}\n\nexports.BackoffTimeout = BackoffTimeout;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAiBA,MAAMA,kBAAkB,GAAG,IAA3B;AACA,MAAMC,kBAAkB,GAAG,GAA3B;AACA,MAAMC,cAAc,GAAG,MAAvB;AACA,MAAMC,cAAc,GAAG,GAAvB;AAEA;;;;;;AAKA,SAASC,aAAT,CAAuBC,GAAvB,EAAoCC,GAApC,EAA+C;AAC7C,SAAOC,IAAI,CAACC,MAAL,MAAiBF,GAAG,GAAGD,GAAvB,IAA8BA,GAArC;AACD;;AASD,MAAaI,cAAb,CAA2B;AAUzBC,cAAoBC,QAApB,EAA0CC,OAA1C,EAAkE;AAA9C;AATZ,wBAAuBZ,kBAAvB;AACA,sBAAqBC,kBAArB;AACA,oBAAmBC,cAAnB;AACA,kBAAiBC,cAAjB;AAGA,mBAAU,KAAV;AACA,kBAAS,IAAT;;AAGN,QAAIS,OAAJ,EAAa;AACX,UAAIA,OAAO,CAACC,YAAZ,EAA0B;AACxB,aAAKA,YAAL,GAAoBD,OAAO,CAACC,YAA5B;AACD;;AACD,UAAID,OAAO,CAACE,UAAZ,EAAwB;AACtB,aAAKA,UAAL,GAAkBF,OAAO,CAACE,UAA1B;AACD;;AACD,UAAIF,OAAO,CAACG,MAAZ,EAAoB;AAClB,aAAKA,MAAL,GAAcH,OAAO,CAACG,MAAtB;AACD;;AACD,UAAIH,OAAO,CAACI,QAAZ,EAAsB;AACpB,aAAKA,QAAL,GAAgBJ,OAAO,CAACI,QAAxB;AACD;AACF;;AACD,SAAKC,SAAL,GAAiB,KAAKJ,YAAtB;AACA,SAAKK,OAAL,GAAeC,UAAU,CAAC,MAAK,CAAG,CAAT,EAAW,CAAX,CAAzB;AACAC,gBAAY,CAAC,KAAKF,OAAN,CAAZ;AACD;AAED;;;;;AAGAG,SAAO;;;AACL,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKJ,OAAL,GAAeC,UAAU,CAAC,MAAK;AAC7B,WAAKR,QAAL;AACA,WAAKW,OAAL,GAAe,KAAf;AACD,KAHwB,EAGtB,KAAKL,SAHiB,CAAzB;;AAIA,QAAI,CAAC,KAAKM,MAAV,EAAkB;AAChB,uBAAKL,OAAL,EAAaM,KAAb,MAAkB,IAAlB,IAAkBC,aAAlB,GAAkB,MAAlB,GAAkBA,WAAlB;AACD;;AACD,UAAMC,WAAW,GAAGnB,IAAI,CAACF,GAAL,CAClB,KAAKY,SAAL,GAAiB,KAAKH,UADJ,EAElB,KAAKE,QAFa,CAApB;AAIA,UAAMW,eAAe,GAAGD,WAAW,GAAG,KAAKX,MAA3C;AACA,SAAKE,SAAL,GACES,WAAW,GAAGtB,aAAa,CAAC,CAACuB,eAAF,EAAmBA,eAAnB,CAD7B;AAED;AAED;;;;;;AAIAC,MAAI;AACFR,gBAAY,CAAC,KAAKF,OAAN,CAAZ;AACA,SAAKI,OAAL,GAAe,KAAf;AACD;AAED;;;;;AAGAO,OAAK;AACH,SAAKZ,SAAL,GAAiB,KAAKJ,YAAtB;AACD;;AAEDiB,WAAS;AACP,WAAO,KAAKR,OAAZ;AACD;;AAEDS,KAAG;;;AACD,SAAKR,MAAL,GAAc,IAAd;AACA,qBAAKL,OAAL,EAAaa,GAAb,MAAgB,IAAhB,IAAgBN,aAAhB,GAAgB,MAAhB,GAAgBA,WAAhB;AACD;;AAEDD,OAAK;;;AACH,SAAKD,MAAL,GAAc,KAAd;AACA,qBAAKL,OAAL,EAAaM,KAAb,MAAkB,IAAlB,IAAkBC,aAAlB,GAAkB,MAAlB,GAAkBA,WAAlB;AACD;;AA/EwB;;AAA3BO","names":["INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","uniformRandom","min","max","Math","random","BackoffTimeout","constructor","callback","options","initialDelay","multiplier","jitter","maxDelay","nextDelay","timerId","setTimeout","clearTimeout","runOnce","running","hasRef","unref","_b","nextBackoff","jitterMagnitude","stop","reset","isRunning","ref","exports"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/backoff-timeout.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nexport interface BackoffOptions {\n  initialDelay?: number;\n  multiplier?: number;\n  jitter?: number;\n  maxDelay?: number;\n}\n\nexport class BackoffTimeout {\n  private initialDelay: number = INITIAL_BACKOFF_MS;\n  private multiplier: number = BACKOFF_MULTIPLIER;\n  private maxDelay: number = MAX_BACKOFF_MS;\n  private jitter: number = BACKOFF_JITTER;\n  private nextDelay: number;\n  private timerId: NodeJS.Timer;\n  private running = false;\n  private hasRef = true;\n\n  constructor(private callback: () => void, options?: BackoffOptions) {\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, this.nextDelay);\n    if (!this.hasRef) {\n      this.timerId.unref?.();\n    }\n    const nextBackoff = Math.min(\n      this.nextDelay * this.multiplier,\n      this.maxDelay\n    );\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay =\n      nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n\n  /**\n   * Reset the delay time to its initial value.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n  }\n\n  isRunning() {\n    return this.running;\n  }\n\n  ref() {\n    this.hasRef = true;\n    this.timerId.ref?.();\n  }\n\n  unref() {\n    this.hasRef = false;\n    this.timerId.unref?.();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}