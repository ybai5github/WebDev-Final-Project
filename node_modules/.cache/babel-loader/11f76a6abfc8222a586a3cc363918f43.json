{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\n\nfunction registerResolver(scheme, resolverClass) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\n\nfunction registerDefaultScheme(scheme) {\n  defaultScheme = scheme;\n}\n\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\n\nfunction createResolver(target, listener, options) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);\n  }\n}\n\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\n\nfunction getDefaultAuthority(target) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);\n  }\n}\n\nexports.getDefaultAuthority = getDefaultAuthority;\n\nfunction mapUriDefaultScheme(target) {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uri_parser_1.uriToString(target)\n      };\n    } else {\n      return null;\n    }\n  }\n\n  return target;\n}\n\nexports.mapUriDefaultScheme = mapUriDefaultScheme;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;AAoBA;;AAoFA,MAAMA,mBAAmB,GAA8C,EAAvE;AACA,IAAIC,aAAa,GAAkB,IAAnC;AAEA;;;;;;;;AAOA,SAAgBC,gBAAhB,CACEC,MADF,EAEEC,aAFF,EAEoC;AAElCJ,qBAAmB,CAACG,MAAD,CAAnB,GAA8BC,aAA9B;AACD;;AALDC;AAOA;;;;;;AAKA,SAAgBC,qBAAhB,CAAsCH,MAAtC,EAAoD;AAClDF,eAAa,GAAGE,MAAhB;AACD;;AAFDE;AAIA;;;;;;;AAMA,SAAgBE,cAAhB,CACEC,MADF,EAEEC,QAFF,EAGEC,OAHF,EAGyB;AAEvB,MAAIF,MAAM,CAACL,MAAP,KAAkBQ,SAAlB,IAA+BH,MAAM,CAACL,MAAP,IAAiBH,mBAApD,EAAyE;AACvE,WAAO,IAAIA,mBAAmB,CAACQ,MAAM,CAACL,MAAR,CAAvB,CAAuCK,MAAvC,EAA+CC,QAA/C,EAAyDC,OAAzD,CAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAIE,KAAJ,CACJ,2CAA2CC,yBAAYL,MAAZ,CAAmB,EAD1D,CAAN;AAGD;AACF;;AAZDH;AAcA;;;;;;AAKA,SAAgBS,mBAAhB,CAAoCN,MAApC,EAAmD;AACjD,MAAIA,MAAM,CAACL,MAAP,KAAkBQ,SAAlB,IAA+BH,MAAM,CAACL,MAAP,IAAiBH,mBAApD,EAAyE;AACvE,WAAOA,mBAAmB,CAACQ,MAAM,CAACL,MAAR,CAAnB,CAAmCW,mBAAnC,CAAuDN,MAAvD,CAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAII,KAAJ,CAAU,kBAAkBC,yBAAYL,MAAZ,CAAmB,EAA/C,CAAN;AACD;AACF;;AANDH;;AAQA,SAAgBU,mBAAhB,CAAoCP,MAApC,EAAmD;AACjD,MAAIA,MAAM,CAACL,MAAP,KAAkBQ,SAAlB,IAA+B,EAAEH,MAAM,CAACL,MAAP,IAAiBH,mBAAnB,CAAnC,EAA4E;AAC1E,QAAIC,aAAa,KAAK,IAAtB,EAA4B;AAC1B,aAAO;AACLE,cAAM,EAAEF,aADH;AAELe,iBAAS,EAAEL,SAFN;AAGLM,YAAI,EAAEJ,yBAAYL,MAAZ;AAHD,OAAP;AAKD,KAND,MAMO;AACL,aAAO,IAAP;AACD;AACF;;AACD,SAAOA,MAAP;AACD;;AAbDH","names":["registeredResolvers","defaultScheme","registerResolver","scheme","resolverClass","exports","registerDefaultScheme","createResolver","target","listener","options","undefined","Error","uri_parser_1","getDefaultAuthority","mapUriDefaultScheme","authority","path"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/resolver.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { MethodConfig, ServiceConfig } from './service-config';\nimport { StatusObject } from './call-stream';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChannelOptions } from './channel-options';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { Filter, FilterFactory } from './filter';\n\nexport interface CallConfig {\n  methodConfig: MethodConfig;\n  onCommitted?: () => void;\n  pickInformation: { [key: string]: string };\n  status: Status;\n  dynamicFilterFactories: FilterFactory<Filter>[];\n}\n\n/**\n * Selects a configuration for a method given the name and metadata. Defined in\n * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#new-functionality-in-grpc\n */\nexport interface ConfigSelector {\n  (methodName: string, metadata: Metadata): CallConfig;\n}\n\n/**\n * A listener object passed to the resolver's constructor that provides name\n * resolution updates back to the resolver's owner.\n */\nexport interface ResolverListener {\n  /**\n   * Called whenever the resolver has new name resolution results to report\n   * @param addressList The new list of backend addresses\n   * @param serviceConfig The new service configuration corresponding to the\n   *     `addressList`. Will be `null` if no service configuration was\n   *     retrieved or if the service configuration was invalid\n   * @param serviceConfigError If non-`null`, indicates that the retrieved\n   *     service configuration was invalid\n   */\n  onSuccessfulResolution(\n    addressList: SubchannelAddress[],\n    serviceConfig: ServiceConfig | null,\n    serviceConfigError: StatusObject | null,\n    configSelector: ConfigSelector | null,\n    attributes: { [key: string]: unknown }\n  ): void;\n  /**\n   * Called whenever a name resolution attempt fails.\n   * @param error Describes how resolution failed\n   */\n  onError(error: StatusObject): void;\n}\n\n/**\n * A resolver class that handles one or more of the name syntax schemes defined\n * in the [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n */\nexport interface Resolver {\n  /**\n   * Indicates that the caller wants new name resolution data. Calling this\n   * function may eventually result in calling one of the `ResolverListener`\n   * functions, but that is not guaranteed. Those functions will never be\n   * called synchronously with the constructor or updateResolution.\n   */\n  updateResolution(): void;\n\n  /**\n   * Destroy the resolver. Should be called when the owning channel shuts down.\n   */\n  destroy(): void;\n}\n\nexport interface ResolverConstructor {\n  new (\n    target: GrpcUri,\n    listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ): Resolver;\n  /**\n   * Get the default authority for a target. This loosely corresponds to that\n   * target's hostname. Throws an error if this resolver class cannot parse the\n   * `target`.\n   * @param target\n   */\n  getDefaultAuthority(target: GrpcUri): string;\n}\n\nconst registeredResolvers: { [scheme: string]: ResolverConstructor } = {};\nlet defaultScheme: string | null = null;\n\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nexport function registerResolver(\n  scheme: string,\n  resolverClass: ResolverConstructor\n) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nexport function registerDefaultScheme(scheme: string) {\n  defaultScheme = scheme;\n}\n\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nexport function createResolver(\n  target: GrpcUri,\n  listener: ResolverListener,\n  options: ChannelOptions\n): Resolver {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(\n      `No resolver could be created for target ${uriToString(target)}`\n    );\n  }\n}\n\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nexport function getDefaultAuthority(target: GrpcUri): string {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uriToString(target)}`);\n  }\n}\n\nexport function mapUriDefaultScheme(target: GrpcUri): GrpcUri | null {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uriToString(target),\n      };\n    } else {\n      return null;\n    }\n  }\n  return target;\n}\n"]},"metadata":{},"sourceType":"script"}