{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\n\nconst channel_options_1 = require(\"./channel-options\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst uri_parser_1 = require(\"./uri-parser\"); // 10 seconds in milliseconds. This value is arbitrary.\n\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\n\n\nconst REF_CHECK_INTERVAL = 10000;\n\nclass SubchannelPool {\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   * @param global If true, this is the global subchannel pool. Otherwise, it\n   * is the pool for a single channel.\n   */\n  constructor(global) {\n    this.global = global;\n    this.pool = Object.create(null);\n    /**\n     * A timer of a task performing a periodic subchannel cleanup.\n     */\n\n    this.cleanupTimer = null;\n  }\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n\n\n  unrefUnusedSubchannels() {\n    let allSubchannelsUnrefed = true;\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n\n\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n    // Cancel the cleanup task if all subchannels have been unrefed.\n\n\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n\n\n  ensureCleanupTask() {\n    var _a, _b;\n\n    if (this.global && this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL); // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n\n      (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n\n\n  getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n    this.ensureCleanupTask();\n    const channelTarget = uri_parser_1.uriToString(channelTargetUri);\n\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n\n      for (const subchannelObj of subchannelObjArray) {\n        if (subchannel_address_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n          return subchannelObj.subchannel;\n        }\n      }\n    } // If we get here, no matching subchannel was found\n\n\n    const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);\n\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel\n    });\n\n    if (this.global) {\n      subchannel.ref();\n    }\n\n    return subchannel;\n  }\n\n}\n\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool(true);\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\n\nfunction getSubchannelPool(global) {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool(false);\n  }\n}\n\nexports.getSubchannelPool = getSubchannelPool;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;AAiBA;;AACA;;AACA;;AAKA,6C,CAEA;;AACA;;;;;;AAIA,MAAMA,kBAAkB,GAAG,KAA3B;;AAEA,MAAaC,cAAb,CAA2B;AAezB;;;;;;AAMAC,cAAoBC,MAApB,EAAmC;AAAf;AApBZ,gBAOJC,MAAM,CAACC,MAAP,CAAc,IAAd,CAPI;AASR;;;;AAGQ,wBAAoC,IAApC;AAQ+B;AAEvC;;;;;;AAIAC,wBAAsB;AACpB,QAAIC,qBAAqB,GAAG,IAA5B;AAEA;;;AAGA;;AACA,SAAK,MAAMC,aAAX,IAA4B,KAAKC,IAAjC,EAAuC;AACrC,YAAMC,kBAAkB,GAAG,KAAKD,IAAL,CAAUD,aAAV,CAA3B;AAEA,YAAMG,gBAAgB,GAAGD,kBAAkB,CAACE,MAAnB,CACtBC,KAAD,IAAW,CAACA,KAAK,CAACC,UAAN,CAAiBC,aAAjB,EADW,CAAzB;;AAIA,UAAIJ,gBAAgB,CAACK,MAAjB,GAA0B,CAA9B,EAAiC;AAC/BT,6BAAqB,GAAG,KAAxB;AACD;AAED;;;;;AAGA,WAAKE,IAAL,CAAUD,aAAV,IAA2BG,gBAA3B;AACD;AACD;;AAGA;;;AACA,QAAIJ,qBAAqB,IAAI,KAAKU,YAAL,KAAsB,IAAnD,EAAyD;AACvDC,mBAAa,CAAC,KAAKD,YAAN,CAAb;AACA,WAAKA,YAAL,GAAoB,IAApB;AACD;AACF;AAED;;;;;AAGAE,mBAAiB;;;AACf,QAAI,KAAKhB,MAAL,IAAe,KAAKc,YAAL,KAAsB,IAAzC,EAA+C;AAC7C,WAAKA,YAAL,GAAoBG,WAAW,CAAC,MAAK;AACnC,aAAKd,sBAAL;AACD,OAF8B,EAE5BN,kBAF4B,CAA/B,CAD6C,CAK7C;AACA;;AACA,uBAAKiB,YAAL,EAAkBI,KAAlB,MAAuB,IAAvB,IAAuBC,aAAvB,GAAuB,MAAvB,GAAuBA,WAAvB;AACD;AACF;AAED;;;;;;;;;;AAQAC,uBAAqB,CACnBC,gBADmB,EAEnBC,gBAFmB,EAGnBC,gBAHmB,EAInBC,kBAJmB,EAImB;AAEtC,SAAKR,iBAAL;AACA,UAAMX,aAAa,GAAGoB,yBAAYJ,gBAAZ,CAAtB;;AACA,QAAIhB,aAAa,IAAI,KAAKC,IAA1B,EAAgC;AAC9B,YAAMC,kBAAkB,GAAG,KAAKD,IAAL,CAAUD,aAAV,CAA3B;;AACA,WAAK,MAAMqB,aAAX,IAA4BnB,kBAA5B,EAAgD;AAC9C,YACEoB,4CACEL,gBADF,EAEEI,aAAa,CAACE,iBAFhB,KAIAC,sCACEN,gBADF,EAEEG,aAAa,CAACH,gBAFhB,CAJA,IAQAC,kBAAkB,CAACM,OAAnB,CAA2BJ,aAAa,CAACF,kBAAzC,CATF,EAUE;AACA,iBAAOE,aAAa,CAACf,UAArB;AACD;AACF;AACF,KArBqC,CAsBtC;;;AACA,UAAMA,UAAU,GAAG,IAAIoB,uBAAJ,CACjBV,gBADiB,EAEjBC,gBAFiB,EAGjBC,gBAHiB,EAIjBC,kBAJiB,CAAnB;;AAMA,QAAI,EAAEnB,aAAa,IAAI,KAAKC,IAAxB,CAAJ,EAAmC;AACjC,WAAKA,IAAL,CAAUD,aAAV,IAA2B,EAA3B;AACD;;AACD,SAAKC,IAAL,CAAUD,aAAV,EAAyB2B,IAAzB,CAA8B;AAC5BJ,uBAAiB,EAAEN,gBADS;AAE5BC,sBAF4B;AAG5BC,wBAH4B;AAI5Bb;AAJ4B,KAA9B;;AAMA,QAAI,KAAKX,MAAT,EAAiB;AACfW,gBAAU,CAACsB,GAAX;AACD;;AACD,WAAOtB,UAAP;AACD;;AAjIwB;;AAA3BuB;AAoIA,MAAMC,oBAAoB,GAAG,IAAIrC,cAAJ,CAAmB,IAAnB,CAA7B;AAEA;;;;;AAIA,SAAgBsC,iBAAhB,CAAkCpC,MAAlC,EAAiD;AAC/C,MAAIA,MAAJ,EAAY;AACV,WAAOmC,oBAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAIrC,cAAJ,CAAmB,KAAnB,CAAP;AACD;AACF;;AANDoC","names":["REF_CHECK_INTERVAL","SubchannelPool","constructor","global","Object","create","unrefUnusedSubchannels","allSubchannelsUnrefed","channelTarget","pool","subchannelObjArray","refedSubchannels","filter","value","subchannel","unrefIfOneRef","length","cleanupTimer","clearInterval","ensureCleanupTask","setInterval","unref","_b","getOrCreateSubchannel","channelTargetUri","subchannelTarget","channelArguments","channelCredentials","uri_parser_1","subchannelObj","subchannel_address_1","subchannelAddress","channel_options_1","_equals","subchannel_1","push","ref","exports","globalSubchannelPool","getSubchannelPool"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/subchannel-pool.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions, channelOptionsEqual } from './channel-options';\nimport { Subchannel } from './subchannel';\nimport {\n  SubchannelAddress,\n  subchannelAddressEqual,\n} from './subchannel-address';\nimport { ChannelCredentials } from './channel-credentials';\nimport { GrpcUri, uriToString } from './uri-parser';\n\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10_000;\n\nexport class SubchannelPool {\n  private pool: {\n    [channelTarget: string]: Array<{\n      subchannelAddress: SubchannelAddress;\n      channelArguments: ChannelOptions;\n      channelCredentials: ChannelCredentials;\n      subchannel: Subchannel;\n    }>;\n  } = Object.create(null);\n\n  /**\n   * A timer of a task performing a periodic subchannel cleanup.\n   */\n  private cleanupTimer: NodeJS.Timer | null = null;\n\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   * @param global If true, this is the global subchannel pool. Otherwise, it\n   * is the pool for a single channel.\n   */\n  constructor(private global: boolean) {}\n\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n  unrefUnusedSubchannels(): void {\n    let allSubchannelsUnrefed = true;\n\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n\n      const refedSubchannels = subchannelObjArray.filter(\n        (value) => !value.subchannel.unrefIfOneRef()\n      );\n\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n\n    // Cancel the cleanup task if all subchannels have been unrefed.\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n  ensureCleanupTask(): void {\n    if (this.global && this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL);\n\n      // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n      this.cleanupTimer.unref?.();\n    }\n  }\n\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n  getOrCreateSubchannel(\n    channelTargetUri: GrpcUri,\n    subchannelTarget: SubchannelAddress,\n    channelArguments: ChannelOptions,\n    channelCredentials: ChannelCredentials\n  ): Subchannel {\n    this.ensureCleanupTask();\n    const channelTarget = uriToString(channelTargetUri);\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      for (const subchannelObj of subchannelObjArray) {\n        if (\n          subchannelAddressEqual(\n            subchannelTarget,\n            subchannelObj.subchannelAddress\n          ) &&\n          channelOptionsEqual(\n            channelArguments,\n            subchannelObj.channelArguments\n          ) &&\n          channelCredentials._equals(subchannelObj.channelCredentials)\n        ) {\n          return subchannelObj.subchannel;\n        }\n      }\n    }\n    // If we get here, no matching subchannel was found\n    const subchannel = new Subchannel(\n      channelTargetUri,\n      subchannelTarget,\n      channelArguments,\n      channelCredentials\n    );\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel,\n    });\n    if (this.global) {\n      subchannel.ref();\n    }\n    return subchannel;\n  }\n}\n\nconst globalSubchannelPool = new SubchannelPool(true);\n\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nexport function getSubchannelPool(global: boolean): SubchannelPool {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool(false);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}