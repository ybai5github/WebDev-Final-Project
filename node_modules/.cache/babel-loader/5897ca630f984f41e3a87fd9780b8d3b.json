{"ast":null,"code":"// The implementation of the [HTTP/2 Header Compression][http2-compression] spec is separated from\n// the 'integration' part which handles HEADERS and PUSH_PROMISE frames. The compression itself is\n// implemented in the first part of the file, and consists of three classes: `HeaderTable`,\n// `HeaderSetDecompressor` and `HeaderSetCompressor`. The two latter classes are\n// [Transform Stream][node-transform] subclasses that operate in [object mode][node-objectmode].\n// These transform chunks of binary data into `[name, value]` pairs and vice versa, and store their\n// state in `HeaderTable` instances.\n//\n// The 'integration' part is also implemented by two [Transform Stream][node-transform] subclasses\n// that operate in [object mode][node-objectmode]: the `Compressor` and the `Decompressor`. These\n// provide a layer between the [framer](framer.html) and the\n// [connection handling component](connection.html).\n//\n// [node-transform]: https://nodejs.org/api/stream.html#stream_class_stream_transform\n// [node-objectmode]: https://nodejs.org/api/stream.html#stream_new_stream_readable_options\n// [http2-compression]: https://tools.ietf.org/html/rfc7541\nexports.HeaderTable = HeaderTable;\nexports.HuffmanTable = HuffmanTable;\nexports.HeaderSetCompressor = HeaderSetCompressor;\nexports.HeaderSetDecompressor = HeaderSetDecompressor;\nexports.Compressor = Compressor;\nexports.Decompressor = Decompressor;\n\nvar TransformStream = require('stream').Transform;\n\nvar assert = require('assert');\n\nvar util = require('util'); // Header compression\n// ==================\n// The HeaderTable class\n// ---------------------\n// The [Header Table] is a component used to associate headers to index values. It is basically an\n// ordered list of `[name, value]` pairs, so it's implemented as a subclass of `Array`.\n// In this implementation, the Header Table and the [Static Table] are handled as a single table.\n// [Header Table]: https://tools.ietf.org/html/rfc7541#section-2.3.2\n// [Static Table]: https://tools.ietf.org/html/rfc7541#section-2.3.1\n\n\nfunction HeaderTable(log, limit) {\n  var self = HeaderTable.staticTable.map(entryFromPair);\n  self._log = log;\n  self._limit = limit || DEFAULT_HEADER_TABLE_LIMIT;\n  self._staticLength = self.length;\n  self._size = 0;\n  self._enforceLimit = HeaderTable.prototype._enforceLimit;\n  self.add = HeaderTable.prototype.add;\n  self.setSizeLimit = HeaderTable.prototype.setSizeLimit;\n  return self;\n}\n\nfunction entryFromPair(pair) {\n  var entry = pair.slice();\n  entry._size = size(entry);\n  return entry;\n} // The encoder decides how to update the header table and as such can control how much memory is\n// used by the header table.  To limit the memory requirements on the decoder side, the header table\n// size is bounded.\n//\n// * The default header table size limit is 4096 bytes.\n// * The size of an entry is defined as follows: the size of an entry is the sum of its name's\n//   length in bytes, of its value's length in bytes and of 32 bytes.\n// * The size of a header table is the sum of the size of its entries.\n\n\nvar DEFAULT_HEADER_TABLE_LIMIT = 4096;\n\nfunction size(entry) {\n  return new Buffer(entry[0] + entry[1], 'utf8').length + 32;\n} // The `add(index, entry)` can be used to [manage the header table][tablemgmt]:\n// [tablemgmt]: https://tools.ietf.org/html/rfc7541#section-4\n//\n// * it pushes the new `entry` at the beggining of the table\n// * before doing such a modification, it has to be ensured that the header table size will stay\n//   lower than or equal to the header table size limit. To achieve this, entries are evicted from\n//   the end of the header table until the size of the header table is less than or equal to\n//   `(this._limit - entry.size)`, or until the table is empty.\n//\n//              <----------  Index Address Space ---------->\n//              <-- Static  Table -->  <-- Header  Table -->\n//              +---+-----------+---+  +---+-----------+---+\n//              | 0 |    ...    | k |  |k+1|    ...    | n |\n//              +---+-----------+---+  +---+-----------+---+\n//                                     ^                   |\n//                                     |                   V\n//                              Insertion Point       Drop Point\n\n\nHeaderTable.prototype._enforceLimit = function _enforceLimit(limit) {\n  var droppedEntries = [];\n\n  while (this._size > 0 && this._size > limit) {\n    var dropped = this.pop();\n    this._size -= dropped._size;\n    droppedEntries.unshift(dropped);\n  }\n\n  return droppedEntries;\n};\n\nHeaderTable.prototype.add = function (entry) {\n  var limit = this._limit - entry._size;\n\n  var droppedEntries = this._enforceLimit(limit);\n\n  if (this._size <= limit) {\n    this.splice(this._staticLength, 0, entry);\n    this._size += entry._size;\n  }\n\n  return droppedEntries;\n}; // The table size limit can be changed externally. In this case, the same eviction algorithm is used\n\n\nHeaderTable.prototype.setSizeLimit = function setSizeLimit(limit) {\n  this._limit = limit;\n\n  this._enforceLimit(this._limit);\n}; // [The Static Table](https://tools.ietf.org/html/rfc7541#section-2.3.1)\n// ------------------\n// The table is generated with feeding the table from the spec to the following sed command:\n//\n//     sed -re \"s/\\s*\\| [0-9]+\\s*\\| ([^ ]*)/  [ '\\1'/g\" -e \"s/\\|\\s([^ ]*)/, '\\1'/g\" -e 's/ \\|/],/g'\n\n\nHeaderTable.staticTable = [[':authority', ''], [':method', 'GET'], [':method', 'POST'], [':path', '/'], [':path', '/index.html'], [':scheme', 'http'], [':scheme', 'https'], [':status', '200'], [':status', '204'], [':status', '206'], [':status', '304'], [':status', '400'], [':status', '404'], [':status', '500'], ['accept-charset', ''], ['accept-encoding', 'gzip, deflate'], ['accept-language', ''], ['accept-ranges', ''], ['accept', ''], ['access-control-allow-origin', ''], ['age', ''], ['allow', ''], ['authorization', ''], ['cache-control', ''], ['content-disposition', ''], ['content-encoding', ''], ['content-language', ''], ['content-length', ''], ['content-location', ''], ['content-range', ''], ['content-type', ''], ['cookie', ''], ['date', ''], ['etag', ''], ['expect', ''], ['expires', ''], ['from', ''], ['host', ''], ['if-match', ''], ['if-modified-since', ''], ['if-none-match', ''], ['if-range', ''], ['if-unmodified-since', ''], ['last-modified', ''], ['link', ''], ['location', ''], ['max-forwards', ''], ['proxy-authenticate', ''], ['proxy-authorization', ''], ['range', ''], ['referer', ''], ['refresh', ''], ['retry-after', ''], ['server', ''], ['set-cookie', ''], ['strict-transport-security', ''], ['transfer-encoding', ''], ['user-agent', ''], ['vary', ''], ['via', ''], ['www-authenticate', '']]; // The HeaderSetDecompressor class\n// -------------------------------\n// A `HeaderSetDecompressor` instance is a transform stream that can be used to *decompress a\n// single header set*. Its input is a stream of binary data chunks and its output is a stream of\n// `[name, value]` pairs.\n//\n// Currently, it is not a proper streaming decompressor implementation, since it buffer its input\n// until the end os the stream, and then processes the whole header block at once.\n\nutil.inherits(HeaderSetDecompressor, TransformStream);\n\nfunction HeaderSetDecompressor(log, table) {\n  TransformStream.call(this, {\n    objectMode: true\n  });\n  this._log = log.child({\n    component: 'compressor'\n  });\n  this._table = table;\n  this._chunks = [];\n} // `_transform` is the implementation of the [corresponding virtual function][_transform] of the\n// TransformStream class. It collects the data chunks for later processing.\n// [_transform]: https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback\n\n\nHeaderSetDecompressor.prototype._transform = function _transform(chunk, encoding, callback) {\n  this._chunks.push(chunk);\n\n  callback();\n}; // `execute(rep)` executes the given [header representation][representation].\n// [representation]: https://tools.ietf.org/html/rfc7541#section-6\n// The *JavaScript object representation* of a header representation:\n//\n//     {\n//       name: String || Integer,  // string literal or index\n//       value: String || Integer, // string literal or index\n//       index: Boolean            // with or without indexing\n//     }\n//\n// *Important:* to ease the indexing of the header table, indexes start at 0 instead of 1.\n//\n// Examples:\n//\n//     Indexed:\n//     { name: 2  , value: 2  , index: false }\n//     Literal:\n//     { name: 2  , value: 'X', index: false } // without indexing\n//     { name: 2  , value: 'Y', index: true  } // with indexing\n//     { name: 'A', value: 'Z', index: true  } // with indexing, literal name\n\n\nHeaderSetDecompressor.prototype._execute = function _execute(rep) {\n  this._log.trace({\n    key: rep.name,\n    value: rep.value,\n    index: rep.index\n  }, 'Executing header representation');\n\n  var entry, pair;\n\n  if (rep.contextUpdate) {\n    this._table.setSizeLimit(rep.newMaxSize);\n  } // * An _indexed representation_ entails the following actions:\n  //   * The header field corresponding to the referenced entry is emitted\n  else if (typeof rep.value === 'number') {\n    var index = rep.value;\n    entry = this._table[index];\n    pair = entry.slice();\n    this.push(pair);\n  } // * A _literal representation_ that is _not added_ to the header table entails the following\n  //   action:\n  //   * The header is emitted.\n  // * A _literal representation_ that is _added_ to the header table entails the following further\n  //   actions:\n  //   * The header is added to the header table.\n  //   * The header is emitted.\n  else {\n    if (typeof rep.name === 'number') {\n      pair = [this._table[rep.name][0], rep.value];\n    } else {\n      pair = [rep.name, rep.value];\n    }\n\n    if (rep.index) {\n      entry = entryFromPair(pair);\n\n      this._table.add(entry);\n    }\n\n    this.push(pair);\n  }\n}; // `_flush` is the implementation of the [corresponding virtual function][_flush] of the\n// TransformStream class. The whole decompressing process is done in `_flush`. It gets called when\n// the input stream is over.\n// [_flush]: https://nodejs.org/api/stream.html#stream_transform_flush_callback\n\n\nHeaderSetDecompressor.prototype._flush = function _flush(callback) {\n  var buffer = concat(this._chunks); // * processes the header representations\n\n  buffer.cursor = 0;\n\n  while (buffer.cursor < buffer.length) {\n    this._execute(HeaderSetDecompressor.header(buffer));\n  }\n\n  callback();\n}; // The HeaderSetCompressor class\n// -----------------------------\n// A `HeaderSetCompressor` instance is a transform stream that can be used to *compress a single\n// header set*. Its input is a stream of `[name, value]` pairs and its output is a stream of\n// binary data chunks.\n//\n// It is a real streaming compressor, since it does not wait until the header set is complete.\n//\n// The compression algorithm is (intentionally) not specified by the spec. Therefore, the current\n// compression algorithm can probably be improved in the future.\n\n\nutil.inherits(HeaderSetCompressor, TransformStream);\n\nfunction HeaderSetCompressor(log, table) {\n  TransformStream.call(this, {\n    objectMode: true\n  });\n  this._log = log.child({\n    component: 'compressor'\n  });\n  this._table = table;\n  this.push = TransformStream.prototype.push.bind(this);\n}\n\nHeaderSetCompressor.prototype.send = function send(rep) {\n  this._log.trace({\n    key: rep.name,\n    value: rep.value,\n    index: rep.index\n  }, 'Emitting header representation');\n\n  if (!rep.chunks) {\n    rep.chunks = HeaderSetCompressor.header(rep);\n  }\n\n  rep.chunks.forEach(this.push);\n}; // `_transform` is the implementation of the [corresponding virtual function][_transform] of the\n// TransformStream class. It processes the input headers one by one:\n// [_transform]: https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback\n\n\nHeaderSetCompressor.prototype._transform = function _transform(pair, encoding, callback) {\n  var name = pair[0].toLowerCase();\n  var value = pair[1];\n  var entry, rep; // * tries to find full (name, value) or name match in the header table\n\n  var nameMatch = -1,\n      fullMatch = -1;\n\n  for (var droppedIndex = 0; droppedIndex < this._table.length; droppedIndex++) {\n    entry = this._table[droppedIndex];\n\n    if (entry[0] === name) {\n      if (entry[1] === value) {\n        fullMatch = droppedIndex;\n        break;\n      } else if (nameMatch === -1) {\n        nameMatch = droppedIndex;\n      }\n    }\n  }\n\n  var mustNeverIndex = name === 'cookie' && value.length < 20 || name === 'set-cookie' && value.length < 20 || name === 'authorization';\n\n  if (fullMatch !== -1 && !mustNeverIndex) {\n    this.send({\n      name: fullMatch,\n      value: fullMatch,\n      index: false\n    });\n  } // * otherwise, it will be a literal representation (with a name index if there's a name match)\n  else {\n    entry = entryFromPair(pair);\n    var indexing = entry._size < this._table._limit / 2 && !mustNeverIndex;\n\n    if (indexing) {\n      this._table.add(entry);\n    }\n\n    this.send({\n      name: nameMatch !== -1 ? nameMatch : name,\n      value: value,\n      index: indexing,\n      mustNeverIndex: mustNeverIndex,\n      contextUpdate: false\n    });\n  }\n\n  callback();\n}; // `_flush` is the implementation of the [corresponding virtual function][_flush] of the\n// TransformStream class. It gets called when there's no more header to compress. The final step:\n// [_flush]: https://nodejs.org/api/stream.html#stream_transform_flush_callback\n\n\nHeaderSetCompressor.prototype._flush = function _flush(callback) {\n  callback();\n}; // [Detailed Format](https://tools.ietf.org/html/rfc7541#section-5)\n// -----------------\n// ### Integer representation ###\n//\n// The algorithm to represent an integer I is as follows:\n//\n// 1. If I < 2^N - 1, encode I on N bits\n// 2. Else, encode 2^N - 1 on N bits and do the following steps:\n//    1. Set I to (I - (2^N - 1)) and Q to 1\n//    2. While Q > 0\n//       1. Compute Q and R, quotient and remainder of I divided by 2^7\n//       2. If Q is strictly greater than 0, write one 1 bit; otherwise, write one 0 bit\n//       3. Encode R on the next 7 bits\n//       4. I = Q\n\n\nHeaderSetCompressor.integer = function writeInteger(I, N) {\n  var limit = Math.pow(2, N) - 1;\n\n  if (I < limit) {\n    return [new Buffer([I])];\n  }\n\n  var bytes = [];\n\n  if (N !== 0) {\n    bytes.push(limit);\n  }\n\n  I -= limit;\n  var Q = 1,\n      R;\n\n  while (Q > 0) {\n    Q = Math.floor(I / 128);\n    R = I % 128;\n\n    if (Q > 0) {\n      R += 128;\n    }\n\n    bytes.push(R);\n    I = Q;\n  }\n\n  return [new Buffer(bytes)];\n}; // The inverse algorithm:\n//\n// 1. Set I to the number coded on the lower N bits of the first byte\n// 2. If I is smaller than 2^N - 1 then return I\n// 2. Else the number is encoded on more than one byte, so do the following steps:\n//    1. Set M to 0\n//    2. While returning with I\n//       1. Let B be the next byte (the first byte if N is 0)\n//       2. Read out the lower 7 bits of B and multiply it with 2^M\n//       3. Increase I with this number\n//       4. Increase M by 7\n//       5. Return I if the most significant bit of B is 0\n\n\nHeaderSetDecompressor.integer = function readInteger(buffer, N) {\n  var limit = Math.pow(2, N) - 1;\n  var I = buffer[buffer.cursor] & limit;\n\n  if (N !== 0) {\n    buffer.cursor += 1;\n  }\n\n  if (I === limit) {\n    var M = 0;\n\n    do {\n      I += (buffer[buffer.cursor] & 127) << M;\n      M += 7;\n      buffer.cursor += 1;\n    } while (buffer[buffer.cursor - 1] & 128);\n  }\n\n  return I;\n}; // ### Huffman Encoding ###\n\n\nfunction HuffmanTable(table) {\n  function createTree(codes, position) {\n    if (codes.length === 1) {\n      return [table.indexOf(codes[0])];\n    } else {\n      position = position || 0;\n      var zero = [];\n      var one = [];\n\n      for (var i = 0; i < codes.length; i++) {\n        var string = codes[i];\n\n        if (string[position] === '0') {\n          zero.push(string);\n        } else {\n          one.push(string);\n        }\n      }\n\n      return [createTree(zero, position + 1), createTree(one, position + 1)];\n    }\n  }\n\n  this.tree = createTree(table);\n  this.codes = table.map(function (bits) {\n    return parseInt(bits, 2);\n  });\n  this.lengths = table.map(function (bits) {\n    return bits.length;\n  });\n}\n\nHuffmanTable.prototype.encode = function encode(buffer) {\n  var result = [];\n  var space = 8;\n\n  function add(data) {\n    if (space === 8) {\n      result.push(data);\n    } else {\n      result[result.length - 1] |= data;\n    }\n  }\n\n  for (var i = 0; i < buffer.length; i++) {\n    var byte = buffer[i];\n    var code = this.codes[byte];\n    var length = this.lengths[byte];\n\n    while (length !== 0) {\n      if (space >= length) {\n        add(code << space - length);\n        code = 0;\n        space -= length;\n        length = 0;\n      } else {\n        var shift = length - space;\n        var msb = code >> shift;\n        add(msb);\n        code -= msb << shift;\n        length -= space;\n        space = 0;\n      }\n\n      if (space === 0) {\n        space = 8;\n      }\n    }\n  }\n\n  if (space !== 8) {\n    add(this.codes[256] >> this.lengths[256] - space);\n  }\n\n  return new Buffer(result);\n};\n\nHuffmanTable.prototype.decode = function decode(buffer) {\n  var result = [];\n  var subtree = this.tree;\n\n  for (var i = 0; i < buffer.length; i++) {\n    var byte = buffer[i];\n\n    for (var j = 0; j < 8; j++) {\n      var bit = byte & 128 ? 1 : 0;\n      byte = byte << 1;\n      subtree = subtree[bit];\n\n      if (subtree.length === 1) {\n        result.push(subtree[0]);\n        subtree = this.tree;\n      }\n    }\n  }\n\n  return new Buffer(result);\n}; // The initializer arrays for the Huffman tables are generated with feeding the tables from the\n// spec to this sed command:\n//\n//     sed -e \"s/^.* [|]//g\" -e \"s/|//g\" -e \"s/ .*//g\" -e \"s/^/  '/g\" -e \"s/$/',/g\"\n\n\nHuffmanTable.huffmanTable = new HuffmanTable(['1111111111000', '11111111111111111011000', '1111111111111111111111100010', '1111111111111111111111100011', '1111111111111111111111100100', '1111111111111111111111100101', '1111111111111111111111100110', '1111111111111111111111100111', '1111111111111111111111101000', '111111111111111111101010', '111111111111111111111111111100', '1111111111111111111111101001', '1111111111111111111111101010', '111111111111111111111111111101', '1111111111111111111111101011', '1111111111111111111111101100', '1111111111111111111111101101', '1111111111111111111111101110', '1111111111111111111111101111', '1111111111111111111111110000', '1111111111111111111111110001', '1111111111111111111111110010', '111111111111111111111111111110', '1111111111111111111111110011', '1111111111111111111111110100', '1111111111111111111111110101', '1111111111111111111111110110', '1111111111111111111111110111', '1111111111111111111111111000', '1111111111111111111111111001', '1111111111111111111111111010', '1111111111111111111111111011', '010100', '1111111000', '1111111001', '111111111010', '1111111111001', '010101', '11111000', '11111111010', '1111111010', '1111111011', '11111001', '11111111011', '11111010', '010110', '010111', '011000', '00000', '00001', '00010', '011001', '011010', '011011', '011100', '011101', '011110', '011111', '1011100', '11111011', '111111111111100', '100000', '111111111011', '1111111100', '1111111111010', '100001', '1011101', '1011110', '1011111', '1100000', '1100001', '1100010', '1100011', '1100100', '1100101', '1100110', '1100111', '1101000', '1101001', '1101010', '1101011', '1101100', '1101101', '1101110', '1101111', '1110000', '1110001', '1110010', '11111100', '1110011', '11111101', '1111111111011', '1111111111111110000', '1111111111100', '11111111111100', '100010', '111111111111101', '00011', '100011', '00100', '100100', '00101', '100101', '100110', '100111', '00110', '1110100', '1110101', '101000', '101001', '101010', '00111', '101011', '1110110', '101100', '01000', '01001', '101101', '1110111', '1111000', '1111001', '1111010', '1111011', '111111111111110', '11111111100', '11111111111101', '1111111111101', '1111111111111111111111111100', '11111111111111100110', '1111111111111111010010', '11111111111111100111', '11111111111111101000', '1111111111111111010011', '1111111111111111010100', '1111111111111111010101', '11111111111111111011001', '1111111111111111010110', '11111111111111111011010', '11111111111111111011011', '11111111111111111011100', '11111111111111111011101', '11111111111111111011110', '111111111111111111101011', '11111111111111111011111', '111111111111111111101100', '111111111111111111101101', '1111111111111111010111', '11111111111111111100000', '111111111111111111101110', '11111111111111111100001', '11111111111111111100010', '11111111111111111100011', '11111111111111111100100', '111111111111111011100', '1111111111111111011000', '11111111111111111100101', '1111111111111111011001', '11111111111111111100110', '11111111111111111100111', '111111111111111111101111', '1111111111111111011010', '111111111111111011101', '11111111111111101001', '1111111111111111011011', '1111111111111111011100', '11111111111111111101000', '11111111111111111101001', '111111111111111011110', '11111111111111111101010', '1111111111111111011101', '1111111111111111011110', '111111111111111111110000', '111111111111111011111', '1111111111111111011111', '11111111111111111101011', '11111111111111111101100', '111111111111111100000', '111111111111111100001', '1111111111111111100000', '111111111111111100010', '11111111111111111101101', '1111111111111111100001', '11111111111111111101110', '11111111111111111101111', '11111111111111101010', '1111111111111111100010', '1111111111111111100011', '1111111111111111100100', '11111111111111111110000', '1111111111111111100101', '1111111111111111100110', '11111111111111111110001', '11111111111111111111100000', '11111111111111111111100001', '11111111111111101011', '1111111111111110001', '1111111111111111100111', '11111111111111111110010', '1111111111111111101000', '1111111111111111111101100', '11111111111111111111100010', '11111111111111111111100011', '11111111111111111111100100', '111111111111111111111011110', '111111111111111111111011111', '11111111111111111111100101', '111111111111111111110001', '1111111111111111111101101', '1111111111111110010', '111111111111111100011', '11111111111111111111100110', '111111111111111111111100000', '111111111111111111111100001', '11111111111111111111100111', '111111111111111111111100010', '111111111111111111110010', '111111111111111100100', '111111111111111100101', '11111111111111111111101000', '11111111111111111111101001', '1111111111111111111111111101', '111111111111111111111100011', '111111111111111111111100100', '111111111111111111111100101', '11111111111111101100', '111111111111111111110011', '11111111111111101101', '111111111111111100110', '1111111111111111101001', '111111111111111100111', '111111111111111101000', '11111111111111111110011', '1111111111111111101010', '1111111111111111101011', '1111111111111111111101110', '1111111111111111111101111', '111111111111111111110100', '111111111111111111110101', '11111111111111111111101010', '11111111111111111110100', '11111111111111111111101011', '111111111111111111111100110', '11111111111111111111101100', '11111111111111111111101101', '111111111111111111111100111', '111111111111111111111101000', '111111111111111111111101001', '111111111111111111111101010', '111111111111111111111101011', '1111111111111111111111111110', '111111111111111111111101100', '111111111111111111111101101', '111111111111111111111101110', '111111111111111111111101111', '111111111111111111111110000', '11111111111111111111101110', '111111111111111111111111111111']); // ### String literal representation ###\n//\n// Literal **strings** can represent header names or header values. There's two variant of the\n// string encoding:\n//\n// String literal with Huffman encoding:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 1 |  Value Length Prefix (7)  |\n//     +---+---+---+---+---+---+---+---+\n//     |   Value Length (0-N bytes)    |\n//     +---+---+---+---+---+---+---+---+\n//     ...\n//     +---+---+---+---+---+---+---+---+\n//     | Huffman Encoded Data  |Padding|\n//     +---+---+---+---+---+---+---+---+\n//\n// String literal without Huffman encoding:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 |  Value Length Prefix (7)  |\n//     +---+---+---+---+---+---+---+---+\n//     |   Value Length (0-N bytes)    |\n//     +---+---+---+---+---+---+---+---+\n//     ...\n//     +---+---+---+---+---+---+---+---+\n//     |  Field Bytes Without Encoding |\n//     +---+---+---+---+---+---+---+---+\n\nHeaderSetCompressor.string = function writeString(str) {\n  str = new Buffer(str, 'utf8');\n  var huffman = HuffmanTable.huffmanTable.encode(str);\n\n  if (huffman.length < str.length) {\n    var length = HeaderSetCompressor.integer(huffman.length, 7);\n    length[0][0] |= 128;\n    return length.concat(huffman);\n  } else {\n    length = HeaderSetCompressor.integer(str.length, 7);\n    return length.concat(str);\n  }\n};\n\nHeaderSetDecompressor.string = function readString(buffer) {\n  var huffman = buffer[buffer.cursor] & 128;\n  var length = HeaderSetDecompressor.integer(buffer, 7);\n  var encoded = buffer.slice(buffer.cursor, buffer.cursor + length);\n  buffer.cursor += length;\n  return (huffman ? HuffmanTable.huffmanTable.decode(encoded) : encoded).toString('utf8');\n}; // ### Header represenations ###\n// The JavaScript object representation is described near the\n// `HeaderSetDecompressor.prototype._execute()` method definition.\n//\n// **All binary header representations** start with a prefix signaling the representation type and\n// an index represented using prefix coded integers:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 1 |        Index (7+)         |  Indexed Representation\n//     +---+---------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 1 |      Index (6+)       |\n//     +---+---+---+-------------------+  Literal w/ Indexing\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 1 |           0           |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal w/ Indexing\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 0 |  Index (4+)   |\n//     +---+---+---+-------------------+  Literal w/o Incremental Indexing\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 0 |       0       |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal w/o Incremental Indexing\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 1 |  Index (4+)   |\n//     +---+---+---+-------------------+  Literal never indexed\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 1 |       0       |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal never indexed\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n// The **Indexed Representation** consists of the 1-bit prefix and the Index that is represented as\n// a 7-bit prefix coded integer and nothing else.\n//\n// After the first bits, **all literal representations** specify the header name, either as a\n// pointer to the Header Table (Index) or a string literal. When the string literal representation\n// is used, the Index is set to 0 and the string literal starts at the second byte.\n//\n// For **all literal representations**, the specification of the header value comes next. It is\n// always represented as a string.\n\n\nvar representations = {\n  indexed: {\n    prefix: 7,\n    pattern: 0x80\n  },\n  literalIncremental: {\n    prefix: 6,\n    pattern: 0x40\n  },\n  contextUpdate: {\n    prefix: 0,\n    pattern: 0x20\n  },\n  literalNeverIndexed: {\n    prefix: 4,\n    pattern: 0x10\n  },\n  literal: {\n    prefix: 4,\n    pattern: 0x00\n  }\n};\n\nHeaderSetCompressor.header = function writeHeader(header) {\n  var representation,\n      buffers = [];\n\n  if (header.contextUpdate) {\n    representation = representations.contextUpdate;\n  } else if (typeof header.value === 'number') {\n    representation = representations.indexed;\n  } else if (header.index) {\n    representation = representations.literalIncremental;\n  } else if (header.mustNeverIndex) {\n    representation = representations.literalNeverIndexed;\n  } else {\n    representation = representations.literal;\n  }\n\n  if (representation === representations.contextUpdate) {\n    buffers.push(HeaderSetCompressor.integer(header.newMaxSize, 5));\n  } else if (representation === representations.indexed) {\n    buffers.push(HeaderSetCompressor.integer(header.value + 1, representation.prefix));\n  } else {\n    if (typeof header.name === 'number') {\n      buffers.push(HeaderSetCompressor.integer(header.name + 1, representation.prefix));\n    } else {\n      buffers.push(HeaderSetCompressor.integer(0, representation.prefix));\n      buffers.push(HeaderSetCompressor.string(header.name));\n    }\n\n    buffers.push(HeaderSetCompressor.string(header.value));\n  }\n\n  buffers[0][0][0] |= representation.pattern;\n  return Array.prototype.concat.apply([], buffers); // array of arrays of buffers -> array of buffers\n};\n\nHeaderSetDecompressor.header = function readHeader(buffer) {\n  var representation,\n      header = {};\n  var firstByte = buffer[buffer.cursor];\n\n  if (firstByte & 0x80) {\n    representation = representations.indexed;\n  } else if (firstByte & 0x40) {\n    representation = representations.literalIncremental;\n  } else if (firstByte & 0x20) {\n    representation = representations.contextUpdate;\n  } else if (firstByte & 0x10) {\n    representation = representations.literalNeverIndexed;\n  } else {\n    representation = representations.literal;\n  }\n\n  header.value = header.name = -1;\n  header.index = false;\n  header.contextUpdate = false;\n  header.newMaxSize = 0;\n  header.mustNeverIndex = false;\n\n  if (representation === representations.contextUpdate) {\n    header.contextUpdate = true;\n    header.newMaxSize = HeaderSetDecompressor.integer(buffer, 5);\n  } else if (representation === representations.indexed) {\n    header.value = header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;\n  } else {\n    header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;\n\n    if (header.name === -1) {\n      header.name = HeaderSetDecompressor.string(buffer);\n    }\n\n    header.value = HeaderSetDecompressor.string(buffer);\n    header.index = representation === representations.literalIncremental;\n    header.mustNeverIndex = representation === representations.literalNeverIndexed;\n  }\n\n  return header;\n}; // Integration with HTTP/2\n// =======================\n// This section describes the interaction between the compressor/decompressor and the rest of the\n// HTTP/2 implementation. The `Compressor` and the `Decompressor` makes up a layer between the\n// [framer](framer.html) and the [connection handling component](connection.html). They let most\n// frames pass through, except HEADERS and PUSH_PROMISE frames. They convert the frames between\n// these two representations:\n//\n//     {                                   {\n//      type: 'HEADERS',                    type: 'HEADERS',\n//      flags: {},                          flags: {},\n//      stream: 1,               <===>      stream: 1,\n//      headers: {                          data: Buffer\n//       N1: 'V1',                         }\n//       N2: ['V1', 'V2', ...],\n//       // ...\n//      }\n//     }\n//\n// There are possibly several binary frame that belong to a single non-binary frame.\n\n\nvar MAX_HTTP_PAYLOAD_SIZE = 16384; // The Compressor class\n// --------------------\n// The Compressor transform stream is basically stateless.\n\nutil.inherits(Compressor, TransformStream);\n\nfunction Compressor(log, type) {\n  TransformStream.call(this, {\n    objectMode: true\n  });\n  this._log = log.child({\n    component: 'compressor'\n  });\n  assert(type === 'REQUEST' || type === 'RESPONSE');\n  this._table = new HeaderTable(this._log);\n  this.tableSizeChangePending = false;\n  this.lowestTableSizePending = 0;\n  this.tableSizeSetting = DEFAULT_HEADER_TABLE_LIMIT;\n} // Changing the header table size\n\n\nCompressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {\n  this._table.setSizeLimit(size);\n\n  if (!this.tableSizeChangePending || size < this.lowestTableSizePending) {\n    this.lowestTableSizePending = size;\n  }\n\n  this.tableSizeSetting = size;\n  this.tableSizeChangePending = true;\n}; // `compress` takes a header set, and compresses it using a new `HeaderSetCompressor` stream\n// instance. This means that from now on, the advantages of streaming header encoding are lost,\n// but the API becomes simpler.\n\n\nCompressor.prototype.compress = function compress(headers) {\n  var compressor = new HeaderSetCompressor(this._log, this._table);\n\n  if (this.tableSizeChangePending) {\n    if (this.lowestTableSizePending < this.tableSizeSetting) {\n      compressor.send({\n        contextUpdate: true,\n        newMaxSize: this.lowestTableSizePending,\n        name: \"\",\n        value: \"\",\n        index: 0\n      });\n    }\n\n    compressor.send({\n      contextUpdate: true,\n      newMaxSize: this.tableSizeSetting,\n      name: \"\",\n      value: \"\",\n      index: 0\n    });\n    this.tableSizeChangePending = false;\n  }\n\n  var colonHeaders = [];\n  var nonColonHeaders = []; // To ensure we send colon headers first\n\n  for (var name in headers) {\n    if (name.trim()[0] === ':') {\n      colonHeaders.push(name);\n    } else {\n      nonColonHeaders.push(name);\n    }\n  }\n\n  function compressHeader(name) {\n    var value = headers[name];\n    name = String(name).toLowerCase(); // * To allow for better compression efficiency, the Cookie header field MAY be split into\n    //   separate header fields, each with one or more cookie-pairs.\n\n    if (name == 'cookie') {\n      if (!(value instanceof Array)) {\n        value = [value];\n      }\n\n      value = Array.prototype.concat.apply([], value.map(function (cookie) {\n        return String(cookie).split(';').map(trim);\n      }));\n    }\n\n    if (value instanceof Array) {\n      for (var i = 0; i < value.length; i++) {\n        compressor.write([name, String(value[i])]);\n      }\n    } else {\n      compressor.write([name, String(value)]);\n    }\n  }\n\n  colonHeaders.forEach(compressHeader);\n  nonColonHeaders.forEach(compressHeader);\n  compressor.end();\n  var chunk,\n      chunks = [];\n\n  while (chunk = compressor.read()) {\n    chunks.push(chunk);\n  }\n\n  return concat(chunks);\n}; // When a `frame` arrives\n\n\nCompressor.prototype._transform = function _transform(frame, encoding, done) {\n  // * and it is a HEADERS or PUSH_PROMISE frame\n  //   * it generates a header block using the compress method\n  //   * cuts the header block into `chunks` that are not larger than `MAX_HTTP_PAYLOAD_SIZE`\n  //   * for each chunk, it pushes out a chunk frame that is identical to the original, except\n  //     the `data` property which holds the given chunk, the type of the frame which is always\n  //     CONTINUATION except for the first frame, and the END_HEADERS/END_PUSH_STREAM flag that\n  //     marks the last frame and the END_STREAM flag which is always false before the end\n  if (frame.type === 'HEADERS' || frame.type === 'PUSH_PROMISE') {\n    var buffer = this.compress(frame.headers); // This will result in CONTINUATIONs from a PUSH_PROMISE being 4 bytes shorter than they could\n    // be, but that's not the end of the world, and it prevents us from going over MAX_HTTP_PAYLOAD_SIZE\n    // on the initial PUSH_PROMISE frame.\n\n    var adjustment = frame.type === 'PUSH_PROMISE' ? 4 : 0;\n    var chunks = cut(buffer, MAX_HTTP_PAYLOAD_SIZE - adjustment);\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunkFrame;\n      var first = i === 0;\n      var last = i === chunks.length - 1;\n\n      if (first) {\n        chunkFrame = util._extend({}, frame);\n        chunkFrame.flags = util._extend({}, frame.flags);\n        chunkFrame.flags['END_' + frame.type] = last;\n      } else {\n        chunkFrame = {\n          type: 'CONTINUATION',\n          flags: {\n            END_HEADERS: last\n          },\n          stream: frame.stream\n        };\n      }\n\n      chunkFrame.data = chunks[i];\n      this.push(chunkFrame);\n    }\n  } // * otherwise, the frame is forwarded without taking any action\n  else {\n    this.push(frame);\n  }\n\n  done();\n}; // The Decompressor class\n// ----------------------\n// The Decompressor is a stateful transform stream, since it has to collect multiple frames first,\n// and the decoding comes after unifying the payload of those frames.\n//\n// If there's a frame in progress, `this._inProgress` is `true`. The frames are collected in\n// `this._frames`, and the type of the frame and the stream identifier is stored in `this._type`\n// and `this._stream` respectively.\n\n\nutil.inherits(Decompressor, TransformStream);\n\nfunction Decompressor(log, type) {\n  TransformStream.call(this, {\n    objectMode: true\n  });\n  this._log = log.child({\n    component: 'compressor'\n  });\n  assert(type === 'REQUEST' || type === 'RESPONSE');\n  this._table = new HeaderTable(this._log);\n  this._inProgress = false;\n  this._base = undefined;\n} // Changing the header table size\n\n\nDecompressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {\n  this._table.setSizeLimit(size);\n}; // `decompress` takes a full header block, and decompresses it using a new `HeaderSetDecompressor`\n// stream instance. This means that from now on, the advantages of streaming header decoding are\n// lost, but the API becomes simpler.\n\n\nDecompressor.prototype.decompress = function decompress(block) {\n  var decompressor = new HeaderSetDecompressor(this._log, this._table);\n  decompressor.end(block);\n  var seenNonColonHeader = false;\n  var headers = {};\n  var pair;\n\n  while (pair = decompressor.read()) {\n    var name = pair[0];\n    var value = pair[1];\n    var isColonHeader = name.trim()[0] === ':';\n\n    if (seenNonColonHeader && isColonHeader) {\n      this.emit('error', 'PROTOCOL_ERROR');\n      return headers;\n    }\n\n    seenNonColonHeader = !isColonHeader;\n\n    if (name in headers) {\n      if (headers[name] instanceof Array) {\n        headers[name].push(value);\n      } else {\n        headers[name] = [headers[name], value];\n      }\n    } else {\n      headers[name] = value;\n    }\n  } // * If there are multiple Cookie header fields after decompression, these MUST be concatenated\n  //   into a single octet string using the two octet delimiter of 0x3B, 0x20 (the ASCII\n  //   string \"; \").\n\n\n  if ('cookie' in headers && headers['cookie'] instanceof Array) {\n    headers['cookie'] = headers['cookie'].join('; ');\n  }\n\n  return headers;\n}; // When a `frame` arrives\n\n\nDecompressor.prototype._transform = function _transform(frame, encoding, done) {\n  // * and the collection process is already `_inProgress`, the frame is simply stored, except if\n  //   it's an illegal frame\n  if (this._inProgress) {\n    if (frame.type !== 'CONTINUATION' || frame.stream !== this._base.stream) {\n      this._log.error('A series of HEADER frames were not continuous');\n\n      this.emit('error', 'PROTOCOL_ERROR');\n      return;\n    }\n\n    this._frames.push(frame);\n  } // * and the collection process is not `_inProgress`, but the new frame's type is HEADERS or\n  //   PUSH_PROMISE, a new collection process begins\n  else if (frame.type === 'HEADERS' || frame.type === 'PUSH_PROMISE') {\n    this._inProgress = true;\n    this._base = util._extend({}, frame);\n    this._frames = [frame];\n  } // * otherwise, the frame is forwarded without taking any action\n  else {\n    this.push(frame);\n  } // * When the frame signals that it's the last in the series, the header block chunks are\n  //   concatenated, the headers are decompressed, and a new frame gets pushed out with the\n  //   decompressed headers.\n\n\n  if (this._inProgress && (frame.flags.END_HEADERS || frame.flags.END_PUSH_PROMISE)) {\n    var buffer = concat(this._frames.map(function (frame) {\n      return frame.data;\n    }));\n\n    try {\n      var headers = this.decompress(buffer);\n    } catch (error) {\n      this._log.error({\n        err: error\n      }, 'Header decompression error');\n\n      this.emit('error', 'COMPRESSION_ERROR');\n      return;\n    }\n\n    this.push(util._extend(this._base, {\n      headers: headers\n    }));\n    this._inProgress = false;\n  }\n\n  done();\n}; // Helper functions\n// ================\n// Concatenate an array of buffers into a new buffer\n\n\nfunction concat(buffers) {\n  var size = 0;\n\n  for (var i = 0; i < buffers.length; i++) {\n    size += buffers[i].length;\n  }\n\n  var concatenated = new Buffer(size);\n\n  for (var cursor = 0, j = 0; j < buffers.length; cursor += buffers[j].length, j++) {\n    buffers[j].copy(concatenated, cursor);\n  }\n\n  return concatenated;\n} // Cut `buffer` into chunks not larger than `size`\n\n\nfunction cut(buffer, size) {\n  var chunks = [];\n  var cursor = 0;\n\n  do {\n    var chunkSize = Math.min(size, buffer.length - cursor);\n    chunks.push(buffer.slice(cursor, cursor + chunkSize));\n    cursor += chunkSize;\n  } while (cursor < buffer.length);\n\n  return chunks;\n}\n\nfunction trim(string) {\n  return string.trim();\n}","map":{"version":3,"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/http2/lib/protocol/compressor.js"],"names":["exports","HeaderTable","HuffmanTable","HeaderSetCompressor","HeaderSetDecompressor","Compressor","Decompressor","TransformStream","require","Transform","assert","util","log","limit","self","staticTable","map","entryFromPair","_log","_limit","DEFAULT_HEADER_TABLE_LIMIT","_staticLength","length","_size","_enforceLimit","prototype","add","setSizeLimit","pair","entry","slice","size","Buffer","droppedEntries","dropped","pop","unshift","splice","inherits","table","call","objectMode","child","component","_table","_chunks","_transform","chunk","encoding","callback","push","_execute","rep","trace","key","name","value","index","contextUpdate","newMaxSize","_flush","buffer","concat","cursor","header","bind","send","chunks","forEach","toLowerCase","nameMatch","fullMatch","droppedIndex","mustNeverIndex","indexing","integer","writeInteger","I","N","Math","pow","bytes","Q","R","floor","readInteger","M","createTree","codes","position","indexOf","zero","one","i","string","tree","bits","parseInt","lengths","encode","result","space","data","byte","code","shift","msb","decode","subtree","j","bit","huffmanTable","writeString","str","huffman","readString","encoded","toString","representations","indexed","prefix","pattern","literalIncremental","literalNeverIndexed","literal","writeHeader","representation","buffers","Array","apply","readHeader","firstByte","MAX_HTTP_PAYLOAD_SIZE","type","tableSizeChangePending","lowestTableSizePending","tableSizeSetting","setTableSizeLimit","compress","headers","compressor","colonHeaders","nonColonHeaders","trim","compressHeader","String","cookie","split","write","end","read","frame","done","adjustment","cut","chunkFrame","first","last","_extend","flags","END_HEADERS","stream","_inProgress","_base","undefined","decompress","block","decompressor","seenNonColonHeader","isColonHeader","emit","join","error","_frames","END_PUSH_PROMISE","err","concatenated","copy","chunkSize","min"],"mappings":"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","sourcesContent":["// The implementation of the [HTTP/2 Header Compression][http2-compression] spec is separated from\n// the 'integration' part which handles HEADERS and PUSH_PROMISE frames. The compression itself is\n// implemented in the first part of the file, and consists of three classes: `HeaderTable`,\n// `HeaderSetDecompressor` and `HeaderSetCompressor`. The two latter classes are\n// [Transform Stream][node-transform] subclasses that operate in [object mode][node-objectmode].\n// These transform chunks of binary data into `[name, value]` pairs and vice versa, and store their\n// state in `HeaderTable` instances.\n//\n// The 'integration' part is also implemented by two [Transform Stream][node-transform] subclasses\n// that operate in [object mode][node-objectmode]: the `Compressor` and the `Decompressor`. These\n// provide a layer between the [framer](framer.html) and the\n// [connection handling component](connection.html).\n//\n// [node-transform]: https://nodejs.org/api/stream.html#stream_class_stream_transform\n// [node-objectmode]: https://nodejs.org/api/stream.html#stream_new_stream_readable_options\n// [http2-compression]: https://tools.ietf.org/html/rfc7541\n\nexports.HeaderTable = HeaderTable;\nexports.HuffmanTable = HuffmanTable;\nexports.HeaderSetCompressor = HeaderSetCompressor;\nexports.HeaderSetDecompressor = HeaderSetDecompressor;\nexports.Compressor = Compressor;\nexports.Decompressor = Decompressor;\n\nvar TransformStream = require('stream').Transform;\nvar assert = require('assert');\nvar util = require('util');\n\n// Header compression\n// ==================\n\n// The HeaderTable class\n// ---------------------\n\n// The [Header Table] is a component used to associate headers to index values. It is basically an\n// ordered list of `[name, value]` pairs, so it's implemented as a subclass of `Array`.\n// In this implementation, the Header Table and the [Static Table] are handled as a single table.\n// [Header Table]: https://tools.ietf.org/html/rfc7541#section-2.3.2\n// [Static Table]: https://tools.ietf.org/html/rfc7541#section-2.3.1\nfunction HeaderTable(log, limit) {\n  var self = HeaderTable.staticTable.map(entryFromPair);\n  self._log = log;\n  self._limit = limit || DEFAULT_HEADER_TABLE_LIMIT;\n  self._staticLength = self.length;\n  self._size = 0;\n  self._enforceLimit = HeaderTable.prototype._enforceLimit;\n  self.add = HeaderTable.prototype.add;\n  self.setSizeLimit = HeaderTable.prototype.setSizeLimit;\n  return self;\n}\n\nfunction entryFromPair(pair) {\n  var entry = pair.slice();\n  entry._size = size(entry);\n  return entry;\n}\n\n// The encoder decides how to update the header table and as such can control how much memory is\n// used by the header table.  To limit the memory requirements on the decoder side, the header table\n// size is bounded.\n//\n// * The default header table size limit is 4096 bytes.\n// * The size of an entry is defined as follows: the size of an entry is the sum of its name's\n//   length in bytes, of its value's length in bytes and of 32 bytes.\n// * The size of a header table is the sum of the size of its entries.\nvar DEFAULT_HEADER_TABLE_LIMIT = 4096;\n\nfunction size(entry) {\n  return (new Buffer(entry[0] + entry[1], 'utf8')).length + 32;\n}\n\n// The `add(index, entry)` can be used to [manage the header table][tablemgmt]:\n// [tablemgmt]: https://tools.ietf.org/html/rfc7541#section-4\n//\n// * it pushes the new `entry` at the beggining of the table\n// * before doing such a modification, it has to be ensured that the header table size will stay\n//   lower than or equal to the header table size limit. To achieve this, entries are evicted from\n//   the end of the header table until the size of the header table is less than or equal to\n//   `(this._limit - entry.size)`, or until the table is empty.\n//\n//              <----------  Index Address Space ---------->\n//              <-- Static  Table -->  <-- Header  Table -->\n//              +---+-----------+---+  +---+-----------+---+\n//              | 0 |    ...    | k |  |k+1|    ...    | n |\n//              +---+-----------+---+  +---+-----------+---+\n//                                     ^                   |\n//                                     |                   V\n//                              Insertion Point       Drop Point\n\nHeaderTable.prototype._enforceLimit = function _enforceLimit(limit) {\n  var droppedEntries = [];\n  while ((this._size > 0) && (this._size > limit)) {\n    var dropped = this.pop();\n    this._size -= dropped._size;\n    droppedEntries.unshift(dropped);\n  }\n  return droppedEntries;\n};\n\nHeaderTable.prototype.add = function(entry) {\n  var limit = this._limit - entry._size;\n  var droppedEntries = this._enforceLimit(limit);\n\n  if (this._size <= limit) {\n    this.splice(this._staticLength, 0, entry);\n    this._size += entry._size;\n  }\n\n  return droppedEntries;\n};\n\n// The table size limit can be changed externally. In this case, the same eviction algorithm is used\nHeaderTable.prototype.setSizeLimit = function setSizeLimit(limit) {\n  this._limit = limit;\n  this._enforceLimit(this._limit);\n};\n\n// [The Static Table](https://tools.ietf.org/html/rfc7541#section-2.3.1)\n// ------------------\n\n// The table is generated with feeding the table from the spec to the following sed command:\n//\n//     sed -re \"s/\\s*\\| [0-9]+\\s*\\| ([^ ]*)/  [ '\\1'/g\" -e \"s/\\|\\s([^ ]*)/, '\\1'/g\" -e 's/ \\|/],/g'\n\nHeaderTable.staticTable  = [\n  [ ':authority'                  , ''            ],\n  [ ':method'                     , 'GET'         ],\n  [ ':method'                     , 'POST'        ],\n  [ ':path'                       , '/'           ],\n  [ ':path'                       , '/index.html' ],\n  [ ':scheme'                     , 'http'        ],\n  [ ':scheme'                     , 'https'       ],\n  [ ':status'                     , '200'         ],\n  [ ':status'                     , '204'         ],\n  [ ':status'                     , '206'         ],\n  [ ':status'                     , '304'         ],\n  [ ':status'                     , '400'         ],\n  [ ':status'                     , '404'         ],\n  [ ':status'                     , '500'         ],\n  [ 'accept-charset'              , ''            ],\n  [ 'accept-encoding'             , 'gzip, deflate'],\n  [ 'accept-language'             , ''            ],\n  [ 'accept-ranges'               , ''            ],\n  [ 'accept'                      , ''            ],\n  [ 'access-control-allow-origin' , ''            ],\n  [ 'age'                         , ''            ],\n  [ 'allow'                       , ''            ],\n  [ 'authorization'               , ''            ],\n  [ 'cache-control'               , ''            ],\n  [ 'content-disposition'         , ''            ],\n  [ 'content-encoding'            , ''            ],\n  [ 'content-language'            , ''            ],\n  [ 'content-length'              , ''            ],\n  [ 'content-location'            , ''            ],\n  [ 'content-range'               , ''            ],\n  [ 'content-type'                , ''            ],\n  [ 'cookie'                      , ''            ],\n  [ 'date'                        , ''            ],\n  [ 'etag'                        , ''            ],\n  [ 'expect'                      , ''            ],\n  [ 'expires'                     , ''            ],\n  [ 'from'                        , ''            ],\n  [ 'host'                        , ''            ],\n  [ 'if-match'                    , ''            ],\n  [ 'if-modified-since'           , ''            ],\n  [ 'if-none-match'               , ''            ],\n  [ 'if-range'                    , ''            ],\n  [ 'if-unmodified-since'         , ''            ],\n  [ 'last-modified'               , ''            ],\n  [ 'link'                        , ''            ],\n  [ 'location'                    , ''            ],\n  [ 'max-forwards'                , ''            ],\n  [ 'proxy-authenticate'          , ''            ],\n  [ 'proxy-authorization'         , ''            ],\n  [ 'range'                       , ''            ],\n  [ 'referer'                     , ''            ],\n  [ 'refresh'                     , ''            ],\n  [ 'retry-after'                 , ''            ],\n  [ 'server'                      , ''            ],\n  [ 'set-cookie'                  , ''            ],\n  [ 'strict-transport-security'   , ''            ],\n  [ 'transfer-encoding'           , ''            ],\n  [ 'user-agent'                  , ''            ],\n  [ 'vary'                        , ''            ],\n  [ 'via'                         , ''            ],\n  [ 'www-authenticate'            , ''            ]\n];\n\n// The HeaderSetDecompressor class\n// -------------------------------\n\n// A `HeaderSetDecompressor` instance is a transform stream that can be used to *decompress a\n// single header set*. Its input is a stream of binary data chunks and its output is a stream of\n// `[name, value]` pairs.\n//\n// Currently, it is not a proper streaming decompressor implementation, since it buffer its input\n// until the end os the stream, and then processes the whole header block at once.\n\nutil.inherits(HeaderSetDecompressor, TransformStream);\nfunction HeaderSetDecompressor(log, table) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n  this._table = table;\n  this._chunks = [];\n}\n\n// `_transform` is the implementation of the [corresponding virtual function][_transform] of the\n// TransformStream class. It collects the data chunks for later processing.\n// [_transform]: https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback\nHeaderSetDecompressor.prototype._transform = function _transform(chunk, encoding, callback) {\n  this._chunks.push(chunk);\n  callback();\n};\n\n// `execute(rep)` executes the given [header representation][representation].\n// [representation]: https://tools.ietf.org/html/rfc7541#section-6\n\n// The *JavaScript object representation* of a header representation:\n//\n//     {\n//       name: String || Integer,  // string literal or index\n//       value: String || Integer, // string literal or index\n//       index: Boolean            // with or without indexing\n//     }\n//\n// *Important:* to ease the indexing of the header table, indexes start at 0 instead of 1.\n//\n// Examples:\n//\n//     Indexed:\n//     { name: 2  , value: 2  , index: false }\n//     Literal:\n//     { name: 2  , value: 'X', index: false } // without indexing\n//     { name: 2  , value: 'Y', index: true  } // with indexing\n//     { name: 'A', value: 'Z', index: true  } // with indexing, literal name\nHeaderSetDecompressor.prototype._execute = function _execute(rep) {\n  this._log.trace({ key: rep.name, value: rep.value, index: rep.index },\n                  'Executing header representation');\n\n  var entry, pair;\n\n  if (rep.contextUpdate) {\n    this._table.setSizeLimit(rep.newMaxSize);\n  }\n\n  // * An _indexed representation_ entails the following actions:\n  //   * The header field corresponding to the referenced entry is emitted\n  else if (typeof rep.value === 'number') {\n    var index = rep.value;\n    entry = this._table[index];\n\n    pair = entry.slice();\n    this.push(pair);\n  }\n\n  // * A _literal representation_ that is _not added_ to the header table entails the following\n  //   action:\n  //   * The header is emitted.\n  // * A _literal representation_ that is _added_ to the header table entails the following further\n  //   actions:\n  //   * The header is added to the header table.\n  //   * The header is emitted.\n  else {\n    if (typeof rep.name === 'number') {\n      pair = [this._table[rep.name][0], rep.value];\n    } else {\n      pair = [rep.name, rep.value];\n    }\n\n    if (rep.index) {\n      entry = entryFromPair(pair);\n      this._table.add(entry);\n    }\n\n    this.push(pair);\n  }\n};\n\n// `_flush` is the implementation of the [corresponding virtual function][_flush] of the\n// TransformStream class. The whole decompressing process is done in `_flush`. It gets called when\n// the input stream is over.\n// [_flush]: https://nodejs.org/api/stream.html#stream_transform_flush_callback\nHeaderSetDecompressor.prototype._flush = function _flush(callback) {\n  var buffer = concat(this._chunks);\n\n  // * processes the header representations\n  buffer.cursor = 0;\n  while (buffer.cursor < buffer.length) {\n    this._execute(HeaderSetDecompressor.header(buffer));\n  }\n\n  callback();\n};\n\n// The HeaderSetCompressor class\n// -----------------------------\n\n// A `HeaderSetCompressor` instance is a transform stream that can be used to *compress a single\n// header set*. Its input is a stream of `[name, value]` pairs and its output is a stream of\n// binary data chunks.\n//\n// It is a real streaming compressor, since it does not wait until the header set is complete.\n//\n// The compression algorithm is (intentionally) not specified by the spec. Therefore, the current\n// compression algorithm can probably be improved in the future.\n\nutil.inherits(HeaderSetCompressor, TransformStream);\nfunction HeaderSetCompressor(log, table) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n  this._table = table;\n  this.push = TransformStream.prototype.push.bind(this);\n}\n\nHeaderSetCompressor.prototype.send = function send(rep) {\n  this._log.trace({ key: rep.name, value: rep.value, index: rep.index },\n                  'Emitting header representation');\n\n  if (!rep.chunks) {\n    rep.chunks = HeaderSetCompressor.header(rep);\n  }\n  rep.chunks.forEach(this.push);\n};\n\n// `_transform` is the implementation of the [corresponding virtual function][_transform] of the\n// TransformStream class. It processes the input headers one by one:\n// [_transform]: https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback\nHeaderSetCompressor.prototype._transform = function _transform(pair, encoding, callback) {\n  var name = pair[0].toLowerCase();\n  var value = pair[1];\n  var entry, rep;\n\n  // * tries to find full (name, value) or name match in the header table\n  var nameMatch = -1, fullMatch = -1;\n  for (var droppedIndex = 0; droppedIndex < this._table.length; droppedIndex++) {\n    entry = this._table[droppedIndex];\n    if (entry[0] === name) {\n      if (entry[1] === value) {\n        fullMatch = droppedIndex;\n        break;\n      } else if (nameMatch === -1) {\n        nameMatch = droppedIndex;\n      }\n    }\n  }\n\n  var mustNeverIndex = ((name === 'cookie' && value.length < 20) ||\n                        (name === 'set-cookie' && value.length < 20) ||\n                        name === 'authorization');\n\n  if (fullMatch !== -1 && !mustNeverIndex) {\n    this.send({ name: fullMatch, value: fullMatch, index: false });\n  }\n\n  // * otherwise, it will be a literal representation (with a name index if there's a name match)\n  else {\n    entry = entryFromPair(pair);\n\n    var indexing = (entry._size < this._table._limit / 2) && !mustNeverIndex;\n\n    if (indexing) {\n      this._table.add(entry);\n    }\n\n    this.send({ name: (nameMatch !== -1) ? nameMatch : name, value: value, index: indexing, mustNeverIndex: mustNeverIndex, contextUpdate: false });\n  }\n\n  callback();\n};\n\n// `_flush` is the implementation of the [corresponding virtual function][_flush] of the\n// TransformStream class. It gets called when there's no more header to compress. The final step:\n// [_flush]: https://nodejs.org/api/stream.html#stream_transform_flush_callback\nHeaderSetCompressor.prototype._flush = function _flush(callback) {\n  callback();\n};\n\n// [Detailed Format](https://tools.ietf.org/html/rfc7541#section-5)\n// -----------------\n\n// ### Integer representation ###\n//\n// The algorithm to represent an integer I is as follows:\n//\n// 1. If I < 2^N - 1, encode I on N bits\n// 2. Else, encode 2^N - 1 on N bits and do the following steps:\n//    1. Set I to (I - (2^N - 1)) and Q to 1\n//    2. While Q > 0\n//       1. Compute Q and R, quotient and remainder of I divided by 2^7\n//       2. If Q is strictly greater than 0, write one 1 bit; otherwise, write one 0 bit\n//       3. Encode R on the next 7 bits\n//       4. I = Q\n\nHeaderSetCompressor.integer = function writeInteger(I, N) {\n  var limit = Math.pow(2,N) - 1;\n  if (I < limit) {\n    return [new Buffer([I])];\n  }\n\n  var bytes = [];\n  if (N !== 0) {\n    bytes.push(limit);\n  }\n  I -= limit;\n\n  var Q = 1, R;\n  while (Q > 0) {\n    Q = Math.floor(I / 128);\n    R = I % 128;\n\n    if (Q > 0) {\n      R += 128;\n    }\n    bytes.push(R);\n\n    I = Q;\n  }\n\n  return [new Buffer(bytes)];\n};\n\n// The inverse algorithm:\n//\n// 1. Set I to the number coded on the lower N bits of the first byte\n// 2. If I is smaller than 2^N - 1 then return I\n// 2. Else the number is encoded on more than one byte, so do the following steps:\n//    1. Set M to 0\n//    2. While returning with I\n//       1. Let B be the next byte (the first byte if N is 0)\n//       2. Read out the lower 7 bits of B and multiply it with 2^M\n//       3. Increase I with this number\n//       4. Increase M by 7\n//       5. Return I if the most significant bit of B is 0\n\nHeaderSetDecompressor.integer = function readInteger(buffer, N) {\n  var limit = Math.pow(2,N) - 1;\n\n  var I = buffer[buffer.cursor] & limit;\n  if (N !== 0) {\n    buffer.cursor += 1;\n  }\n\n  if (I === limit) {\n    var M = 0;\n    do {\n      I += (buffer[buffer.cursor] & 127) << M;\n      M += 7;\n      buffer.cursor += 1;\n    } while (buffer[buffer.cursor - 1] & 128);\n  }\n\n  return I;\n};\n\n// ### Huffman Encoding ###\n\nfunction HuffmanTable(table) {\n  function createTree(codes, position) {\n    if (codes.length === 1) {\n      return [table.indexOf(codes[0])];\n    }\n\n    else {\n      position = position || 0;\n      var zero = [];\n      var one = [];\n      for (var i = 0; i < codes.length; i++) {\n        var string = codes[i];\n        if (string[position] === '0') {\n          zero.push(string);\n        } else {\n          one.push(string);\n        }\n      }\n      return [createTree(zero, position + 1), createTree(one, position + 1)];\n    }\n  }\n\n  this.tree = createTree(table);\n\n  this.codes = table.map(function(bits) {\n    return parseInt(bits, 2);\n  });\n  this.lengths = table.map(function(bits) {\n    return bits.length;\n  });\n}\n\nHuffmanTable.prototype.encode = function encode(buffer) {\n  var result = [];\n  var space = 8;\n\n  function add(data) {\n    if (space === 8) {\n      result.push(data);\n    } else {\n      result[result.length - 1] |= data;\n    }\n  }\n\n  for (var i = 0; i < buffer.length; i++) {\n    var byte = buffer[i];\n    var code = this.codes[byte];\n    var length = this.lengths[byte];\n\n    while (length !== 0) {\n      if (space >= length) {\n        add(code << (space - length));\n        code = 0;\n        space -= length;\n        length = 0;\n      } else {\n        var shift = length - space;\n        var msb = code >> shift;\n        add(msb);\n        code -= msb << shift;\n        length -= space;\n        space = 0;\n      }\n\n      if (space === 0) {\n        space = 8;\n      }\n    }\n  }\n\n  if (space !== 8) {\n    add(this.codes[256] >> (this.lengths[256] - space));\n  }\n\n  return new Buffer(result);\n};\n\nHuffmanTable.prototype.decode = function decode(buffer) {\n  var result = [];\n  var subtree = this.tree;\n\n  for (var i = 0; i < buffer.length; i++) {\n    var byte = buffer[i];\n\n    for (var j = 0; j < 8; j++) {\n      var bit = (byte & 128) ? 1 : 0;\n      byte = byte << 1;\n\n      subtree = subtree[bit];\n      if (subtree.length === 1) {\n        result.push(subtree[0]);\n        subtree = this.tree;\n      }\n    }\n  }\n\n  return new Buffer(result);\n};\n\n// The initializer arrays for the Huffman tables are generated with feeding the tables from the\n// spec to this sed command:\n//\n//     sed -e \"s/^.* [|]//g\" -e \"s/|//g\" -e \"s/ .*//g\" -e \"s/^/  '/g\" -e \"s/$/',/g\"\n\nHuffmanTable.huffmanTable = new HuffmanTable([\n  '1111111111000',\n  '11111111111111111011000',\n  '1111111111111111111111100010',\n  '1111111111111111111111100011',\n  '1111111111111111111111100100',\n  '1111111111111111111111100101',\n  '1111111111111111111111100110',\n  '1111111111111111111111100111',\n  '1111111111111111111111101000',\n  '111111111111111111101010',\n  '111111111111111111111111111100',\n  '1111111111111111111111101001',\n  '1111111111111111111111101010',\n  '111111111111111111111111111101',\n  '1111111111111111111111101011',\n  '1111111111111111111111101100',\n  '1111111111111111111111101101',\n  '1111111111111111111111101110',\n  '1111111111111111111111101111',\n  '1111111111111111111111110000',\n  '1111111111111111111111110001',\n  '1111111111111111111111110010',\n  '111111111111111111111111111110',\n  '1111111111111111111111110011',\n  '1111111111111111111111110100',\n  '1111111111111111111111110101',\n  '1111111111111111111111110110',\n  '1111111111111111111111110111',\n  '1111111111111111111111111000',\n  '1111111111111111111111111001',\n  '1111111111111111111111111010',\n  '1111111111111111111111111011',\n  '010100',\n  '1111111000',\n  '1111111001',\n  '111111111010',\n  '1111111111001',\n  '010101',\n  '11111000',\n  '11111111010',\n  '1111111010',\n  '1111111011',\n  '11111001',\n  '11111111011',\n  '11111010',\n  '010110',\n  '010111',\n  '011000',\n  '00000',\n  '00001',\n  '00010',\n  '011001',\n  '011010',\n  '011011',\n  '011100',\n  '011101',\n  '011110',\n  '011111',\n  '1011100',\n  '11111011',\n  '111111111111100',\n  '100000',\n  '111111111011',\n  '1111111100',\n  '1111111111010',\n  '100001',\n  '1011101',\n  '1011110',\n  '1011111',\n  '1100000',\n  '1100001',\n  '1100010',\n  '1100011',\n  '1100100',\n  '1100101',\n  '1100110',\n  '1100111',\n  '1101000',\n  '1101001',\n  '1101010',\n  '1101011',\n  '1101100',\n  '1101101',\n  '1101110',\n  '1101111',\n  '1110000',\n  '1110001',\n  '1110010',\n  '11111100',\n  '1110011',\n  '11111101',\n  '1111111111011',\n  '1111111111111110000',\n  '1111111111100',\n  '11111111111100',\n  '100010',\n  '111111111111101',\n  '00011',\n  '100011',\n  '00100',\n  '100100',\n  '00101',\n  '100101',\n  '100110',\n  '100111',\n  '00110',\n  '1110100',\n  '1110101',\n  '101000',\n  '101001',\n  '101010',\n  '00111',\n  '101011',\n  '1110110',\n  '101100',\n  '01000',\n  '01001',\n  '101101',\n  '1110111',\n  '1111000',\n  '1111001',\n  '1111010',\n  '1111011',\n  '111111111111110',\n  '11111111100',\n  '11111111111101',\n  '1111111111101',\n  '1111111111111111111111111100',\n  '11111111111111100110',\n  '1111111111111111010010',\n  '11111111111111100111',\n  '11111111111111101000',\n  '1111111111111111010011',\n  '1111111111111111010100',\n  '1111111111111111010101',\n  '11111111111111111011001',\n  '1111111111111111010110',\n  '11111111111111111011010',\n  '11111111111111111011011',\n  '11111111111111111011100',\n  '11111111111111111011101',\n  '11111111111111111011110',\n  '111111111111111111101011',\n  '11111111111111111011111',\n  '111111111111111111101100',\n  '111111111111111111101101',\n  '1111111111111111010111',\n  '11111111111111111100000',\n  '111111111111111111101110',\n  '11111111111111111100001',\n  '11111111111111111100010',\n  '11111111111111111100011',\n  '11111111111111111100100',\n  '111111111111111011100',\n  '1111111111111111011000',\n  '11111111111111111100101',\n  '1111111111111111011001',\n  '11111111111111111100110',\n  '11111111111111111100111',\n  '111111111111111111101111',\n  '1111111111111111011010',\n  '111111111111111011101',\n  '11111111111111101001',\n  '1111111111111111011011',\n  '1111111111111111011100',\n  '11111111111111111101000',\n  '11111111111111111101001',\n  '111111111111111011110',\n  '11111111111111111101010',\n  '1111111111111111011101',\n  '1111111111111111011110',\n  '111111111111111111110000',\n  '111111111111111011111',\n  '1111111111111111011111',\n  '11111111111111111101011',\n  '11111111111111111101100',\n  '111111111111111100000',\n  '111111111111111100001',\n  '1111111111111111100000',\n  '111111111111111100010',\n  '11111111111111111101101',\n  '1111111111111111100001',\n  '11111111111111111101110',\n  '11111111111111111101111',\n  '11111111111111101010',\n  '1111111111111111100010',\n  '1111111111111111100011',\n  '1111111111111111100100',\n  '11111111111111111110000',\n  '1111111111111111100101',\n  '1111111111111111100110',\n  '11111111111111111110001',\n  '11111111111111111111100000',\n  '11111111111111111111100001',\n  '11111111111111101011',\n  '1111111111111110001',\n  '1111111111111111100111',\n  '11111111111111111110010',\n  '1111111111111111101000',\n  '1111111111111111111101100',\n  '11111111111111111111100010',\n  '11111111111111111111100011',\n  '11111111111111111111100100',\n  '111111111111111111111011110',\n  '111111111111111111111011111',\n  '11111111111111111111100101',\n  '111111111111111111110001',\n  '1111111111111111111101101',\n  '1111111111111110010',\n  '111111111111111100011',\n  '11111111111111111111100110',\n  '111111111111111111111100000',\n  '111111111111111111111100001',\n  '11111111111111111111100111',\n  '111111111111111111111100010',\n  '111111111111111111110010',\n  '111111111111111100100',\n  '111111111111111100101',\n  '11111111111111111111101000',\n  '11111111111111111111101001',\n  '1111111111111111111111111101',\n  '111111111111111111111100011',\n  '111111111111111111111100100',\n  '111111111111111111111100101',\n  '11111111111111101100',\n  '111111111111111111110011',\n  '11111111111111101101',\n  '111111111111111100110',\n  '1111111111111111101001',\n  '111111111111111100111',\n  '111111111111111101000',\n  '11111111111111111110011',\n  '1111111111111111101010',\n  '1111111111111111101011',\n  '1111111111111111111101110',\n  '1111111111111111111101111',\n  '111111111111111111110100',\n  '111111111111111111110101',\n  '11111111111111111111101010',\n  '11111111111111111110100',\n  '11111111111111111111101011',\n  '111111111111111111111100110',\n  '11111111111111111111101100',\n  '11111111111111111111101101',\n  '111111111111111111111100111',\n  '111111111111111111111101000',\n  '111111111111111111111101001',\n  '111111111111111111111101010',\n  '111111111111111111111101011',\n  '1111111111111111111111111110',\n  '111111111111111111111101100',\n  '111111111111111111111101101',\n  '111111111111111111111101110',\n  '111111111111111111111101111',\n  '111111111111111111111110000',\n  '11111111111111111111101110',\n  '111111111111111111111111111111'\n]);\n\n// ### String literal representation ###\n//\n// Literal **strings** can represent header names or header values. There's two variant of the\n// string encoding:\n//\n// String literal with Huffman encoding:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 1 |  Value Length Prefix (7)  |\n//     +---+---+---+---+---+---+---+---+\n//     |   Value Length (0-N bytes)    |\n//     +---+---+---+---+---+---+---+---+\n//     ...\n//     +---+---+---+---+---+---+---+---+\n//     | Huffman Encoded Data  |Padding|\n//     +---+---+---+---+---+---+---+---+\n//\n// String literal without Huffman encoding:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 |  Value Length Prefix (7)  |\n//     +---+---+---+---+---+---+---+---+\n//     |   Value Length (0-N bytes)    |\n//     +---+---+---+---+---+---+---+---+\n//     ...\n//     +---+---+---+---+---+---+---+---+\n//     |  Field Bytes Without Encoding |\n//     +---+---+---+---+---+---+---+---+\n\nHeaderSetCompressor.string = function writeString(str) {\n  str = new Buffer(str, 'utf8');\n\n  var huffman = HuffmanTable.huffmanTable.encode(str);\n  if (huffman.length < str.length) {\n    var length = HeaderSetCompressor.integer(huffman.length, 7);\n    length[0][0] |= 128;\n    return length.concat(huffman);\n  }\n\n  else {\n    length = HeaderSetCompressor.integer(str.length, 7);\n    return length.concat(str);\n  }\n};\n\nHeaderSetDecompressor.string = function readString(buffer) {\n  var huffman = buffer[buffer.cursor] & 128;\n  var length = HeaderSetDecompressor.integer(buffer, 7);\n  var encoded = buffer.slice(buffer.cursor, buffer.cursor + length);\n  buffer.cursor += length;\n  return (huffman ? HuffmanTable.huffmanTable.decode(encoded) : encoded).toString('utf8');\n};\n\n// ### Header represenations ###\n\n// The JavaScript object representation is described near the\n// `HeaderSetDecompressor.prototype._execute()` method definition.\n//\n// **All binary header representations** start with a prefix signaling the representation type and\n// an index represented using prefix coded integers:\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 1 |        Index (7+)         |  Indexed Representation\n//     +---+---------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 1 |      Index (6+)       |\n//     +---+---+---+-------------------+  Literal w/ Indexing\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 1 |           0           |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal w/ Indexing\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 0 |  Index (4+)   |\n//     +---+---+---+-------------------+  Literal w/o Incremental Indexing\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 0 |       0       |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal w/o Incremental Indexing\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 1 |  Index (4+)   |\n//     +---+---+---+-------------------+  Literal never indexed\n//     |       Value Length (8+)       |\n//     +-------------------------------+  w/ Indexed Name\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n//       0   1   2   3   4   5   6   7\n//     +---+---+---+---+---+---+---+---+\n//     | 0 | 0 | 0 | 1 |       0       |\n//     +---+---+---+-------------------+\n//     |       Name Length (8+)        |\n//     +-------------------------------+  Literal never indexed\n//     |  Name String (Length octets)  |\n//     +-------------------------------+  w/ New Name\n//     |       Value Length (8+)       |\n//     +-------------------------------+\n//     | Value String (Length octets)  |\n//     +-------------------------------+\n//\n// The **Indexed Representation** consists of the 1-bit prefix and the Index that is represented as\n// a 7-bit prefix coded integer and nothing else.\n//\n// After the first bits, **all literal representations** specify the header name, either as a\n// pointer to the Header Table (Index) or a string literal. When the string literal representation\n// is used, the Index is set to 0 and the string literal starts at the second byte.\n//\n// For **all literal representations**, the specification of the header value comes next. It is\n// always represented as a string.\n\nvar representations = {\n  indexed             : { prefix: 7, pattern: 0x80 },\n  literalIncremental  : { prefix: 6, pattern: 0x40 },\n  contextUpdate       : { prefix: 0, pattern: 0x20 },\n  literalNeverIndexed : { prefix: 4, pattern: 0x10 },\n  literal             : { prefix: 4, pattern: 0x00 }\n};\n\nHeaderSetCompressor.header = function writeHeader(header) {\n  var representation, buffers = [];\n\n  if (header.contextUpdate) {\n    representation = representations.contextUpdate;\n  } else if (typeof header.value === 'number') {\n    representation = representations.indexed;\n  } else if (header.index) {\n    representation = representations.literalIncremental;\n  } else if (header.mustNeverIndex) {\n    representation = representations.literalNeverIndexed;\n  } else {\n    representation = representations.literal;\n  }\n\n  if (representation === representations.contextUpdate) {\n    buffers.push(HeaderSetCompressor.integer(header.newMaxSize, 5));\n  }\n\n  else if (representation === representations.indexed) {\n    buffers.push(HeaderSetCompressor.integer(header.value + 1, representation.prefix));\n  }\n\n  else {\n    if (typeof header.name === 'number') {\n      buffers.push(HeaderSetCompressor.integer(header.name + 1, representation.prefix));\n    } else {\n      buffers.push(HeaderSetCompressor.integer(0, representation.prefix));\n      buffers.push(HeaderSetCompressor.string(header.name));\n    }\n    buffers.push(HeaderSetCompressor.string(header.value));\n  }\n\n  buffers[0][0][0] |= representation.pattern;\n\n  return Array.prototype.concat.apply([], buffers); // array of arrays of buffers -> array of buffers\n};\n\nHeaderSetDecompressor.header = function readHeader(buffer) {\n  var representation, header = {};\n\n  var firstByte = buffer[buffer.cursor];\n  if (firstByte & 0x80) {\n    representation = representations.indexed;\n  } else if (firstByte & 0x40) {\n    representation = representations.literalIncremental;\n  } else if (firstByte & 0x20) {\n    representation = representations.contextUpdate;\n  } else if (firstByte & 0x10) {\n    representation = representations.literalNeverIndexed;\n  } else {\n    representation = representations.literal;\n  }\n\n  header.value = header.name = -1;\n  header.index = false;\n  header.contextUpdate = false;\n  header.newMaxSize = 0;\n  header.mustNeverIndex = false;\n\n  if (representation === representations.contextUpdate) {\n    header.contextUpdate = true;\n    header.newMaxSize = HeaderSetDecompressor.integer(buffer, 5);\n  }\n\n  else if (representation === representations.indexed) {\n    header.value = header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;\n  }\n\n  else {\n    header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;\n    if (header.name === -1) {\n      header.name = HeaderSetDecompressor.string(buffer);\n    }\n    header.value = HeaderSetDecompressor.string(buffer);\n    header.index = (representation === representations.literalIncremental);\n    header.mustNeverIndex = (representation === representations.literalNeverIndexed);\n  }\n\n  return header;\n};\n\n// Integration with HTTP/2\n// =======================\n\n// This section describes the interaction between the compressor/decompressor and the rest of the\n// HTTP/2 implementation. The `Compressor` and the `Decompressor` makes up a layer between the\n// [framer](framer.html) and the [connection handling component](connection.html). They let most\n// frames pass through, except HEADERS and PUSH_PROMISE frames. They convert the frames between\n// these two representations:\n//\n//     {                                   {\n//      type: 'HEADERS',                    type: 'HEADERS',\n//      flags: {},                          flags: {},\n//      stream: 1,               <===>      stream: 1,\n//      headers: {                          data: Buffer\n//       N1: 'V1',                         }\n//       N2: ['V1', 'V2', ...],\n//       // ...\n//      }\n//     }\n//\n// There are possibly several binary frame that belong to a single non-binary frame.\n\nvar MAX_HTTP_PAYLOAD_SIZE = 16384;\n\n// The Compressor class\n// --------------------\n\n// The Compressor transform stream is basically stateless.\nutil.inherits(Compressor, TransformStream);\nfunction Compressor(log, type) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n\n  assert((type === 'REQUEST') || (type === 'RESPONSE'));\n  this._table = new HeaderTable(this._log);\n\n  this.tableSizeChangePending = false;\n  this.lowestTableSizePending = 0;\n  this.tableSizeSetting = DEFAULT_HEADER_TABLE_LIMIT;\n}\n\n// Changing the header table size\nCompressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {\n  this._table.setSizeLimit(size);\n  if (!this.tableSizeChangePending || size < this.lowestTableSizePending) {\n    this.lowestTableSizePending = size;\n  }\n  this.tableSizeSetting = size;\n  this.tableSizeChangePending = true;\n};\n\n// `compress` takes a header set, and compresses it using a new `HeaderSetCompressor` stream\n// instance. This means that from now on, the advantages of streaming header encoding are lost,\n// but the API becomes simpler.\nCompressor.prototype.compress = function compress(headers) {\n  var compressor = new HeaderSetCompressor(this._log, this._table);\n\n  if (this.tableSizeChangePending) {\n    if (this.lowestTableSizePending < this.tableSizeSetting) {\n      compressor.send({contextUpdate: true, newMaxSize: this.lowestTableSizePending,\n                       name: \"\", value: \"\", index: 0});\n    }\n    compressor.send({contextUpdate: true, newMaxSize: this.tableSizeSetting,\n                     name: \"\", value: \"\", index: 0});\n    this.tableSizeChangePending = false;\n  }\n  var colonHeaders = [];\n  var nonColonHeaders = [];\n\n  // To ensure we send colon headers first\n  for (var name in headers) {\n    if (name.trim()[0] === ':') {\n      colonHeaders.push(name);\n    } else {\n      nonColonHeaders.push(name);\n    }\n  }\n\n  function compressHeader(name) {\n    var value = headers[name];\n    name = String(name).toLowerCase();\n\n    // * To allow for better compression efficiency, the Cookie header field MAY be split into\n    //   separate header fields, each with one or more cookie-pairs.\n    if (name == 'cookie') {\n      if (!(value instanceof Array)) {\n        value = [value];\n      }\n      value = Array.prototype.concat.apply([], value.map(function(cookie) {\n        return String(cookie).split(';').map(trim);\n      }));\n    }\n\n    if (value instanceof Array) {\n      for (var i = 0; i < value.length; i++) {\n        compressor.write([name, String(value[i])]);\n      }\n    } else {\n      compressor.write([name, String(value)]);\n    }\n  }\n\n  colonHeaders.forEach(compressHeader);\n  nonColonHeaders.forEach(compressHeader);\n\n  compressor.end();\n\n  var chunk, chunks = [];\n  while (chunk = compressor.read()) {\n    chunks.push(chunk);\n  }\n  return concat(chunks);\n};\n\n// When a `frame` arrives\nCompressor.prototype._transform = function _transform(frame, encoding, done) {\n  // * and it is a HEADERS or PUSH_PROMISE frame\n  //   * it generates a header block using the compress method\n  //   * cuts the header block into `chunks` that are not larger than `MAX_HTTP_PAYLOAD_SIZE`\n  //   * for each chunk, it pushes out a chunk frame that is identical to the original, except\n  //     the `data` property which holds the given chunk, the type of the frame which is always\n  //     CONTINUATION except for the first frame, and the END_HEADERS/END_PUSH_STREAM flag that\n  //     marks the last frame and the END_STREAM flag which is always false before the end\n  if (frame.type === 'HEADERS' || frame.type === 'PUSH_PROMISE') {\n    var buffer = this.compress(frame.headers);\n\n    // This will result in CONTINUATIONs from a PUSH_PROMISE being 4 bytes shorter than they could\n    // be, but that's not the end of the world, and it prevents us from going over MAX_HTTP_PAYLOAD_SIZE\n    // on the initial PUSH_PROMISE frame.\n    var adjustment = frame.type === 'PUSH_PROMISE' ? 4 : 0;\n    var chunks = cut(buffer, MAX_HTTP_PAYLOAD_SIZE - adjustment);\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunkFrame;\n      var first = (i === 0);\n      var last = (i === chunks.length - 1);\n\n      if (first) {\n        chunkFrame = util._extend({}, frame);\n        chunkFrame.flags = util._extend({}, frame.flags);\n        chunkFrame.flags['END_' + frame.type] = last;\n      } else {\n        chunkFrame = {\n          type: 'CONTINUATION',\n          flags: { END_HEADERS: last },\n          stream: frame.stream\n        };\n      }\n      chunkFrame.data = chunks[i];\n\n      this.push(chunkFrame);\n    }\n  }\n\n  // * otherwise, the frame is forwarded without taking any action\n  else {\n    this.push(frame);\n  }\n\n  done();\n};\n\n// The Decompressor class\n// ----------------------\n\n// The Decompressor is a stateful transform stream, since it has to collect multiple frames first,\n// and the decoding comes after unifying the payload of those frames.\n//\n// If there's a frame in progress, `this._inProgress` is `true`. The frames are collected in\n// `this._frames`, and the type of the frame and the stream identifier is stored in `this._type`\n// and `this._stream` respectively.\nutil.inherits(Decompressor, TransformStream);\nfunction Decompressor(log, type) {\n  TransformStream.call(this, { objectMode: true });\n\n  this._log = log.child({ component: 'compressor' });\n\n  assert((type === 'REQUEST') || (type === 'RESPONSE'));\n  this._table = new HeaderTable(this._log);\n\n  this._inProgress = false;\n  this._base = undefined;\n}\n\n// Changing the header table size\nDecompressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {\n  this._table.setSizeLimit(size);\n};\n\n// `decompress` takes a full header block, and decompresses it using a new `HeaderSetDecompressor`\n// stream instance. This means that from now on, the advantages of streaming header decoding are\n// lost, but the API becomes simpler.\nDecompressor.prototype.decompress = function decompress(block) {\n  var decompressor = new HeaderSetDecompressor(this._log, this._table);\n  decompressor.end(block);\n\n  var seenNonColonHeader = false;\n  var headers = {};\n  var pair;\n  while (pair = decompressor.read()) {\n    var name = pair[0];\n    var value = pair[1];\n    var isColonHeader = (name.trim()[0] === ':');\n    if (seenNonColonHeader && isColonHeader) {\n        this.emit('error', 'PROTOCOL_ERROR');\n        return headers;\n    }\n    seenNonColonHeader = !isColonHeader;\n    if (name in headers) {\n      if (headers[name] instanceof Array) {\n        headers[name].push(value);\n      } else {\n        headers[name] = [headers[name], value];\n      }\n    } else {\n      headers[name] = value;\n    }\n  }\n\n  // * If there are multiple Cookie header fields after decompression, these MUST be concatenated\n  //   into a single octet string using the two octet delimiter of 0x3B, 0x20 (the ASCII\n  //   string \"; \").\n  if (('cookie' in headers) && (headers['cookie'] instanceof Array)) {\n    headers['cookie'] = headers['cookie'].join('; ');\n  }\n\n  return headers;\n};\n\n// When a `frame` arrives\nDecompressor.prototype._transform = function _transform(frame, encoding, done) {\n  // * and the collection process is already `_inProgress`, the frame is simply stored, except if\n  //   it's an illegal frame\n  if (this._inProgress) {\n    if ((frame.type !== 'CONTINUATION') || (frame.stream !== this._base.stream)) {\n      this._log.error('A series of HEADER frames were not continuous');\n      this.emit('error', 'PROTOCOL_ERROR');\n      return;\n    }\n    this._frames.push(frame);\n  }\n\n  // * and the collection process is not `_inProgress`, but the new frame's type is HEADERS or\n  //   PUSH_PROMISE, a new collection process begins\n  else if ((frame.type === 'HEADERS') || (frame.type === 'PUSH_PROMISE')) {\n    this._inProgress = true;\n    this._base = util._extend({}, frame);\n    this._frames = [frame];\n  }\n\n  // * otherwise, the frame is forwarded without taking any action\n  else {\n    this.push(frame);\n  }\n\n  // * When the frame signals that it's the last in the series, the header block chunks are\n  //   concatenated, the headers are decompressed, and a new frame gets pushed out with the\n  //   decompressed headers.\n  if (this._inProgress && (frame.flags.END_HEADERS || frame.flags.END_PUSH_PROMISE)) {\n    var buffer = concat(this._frames.map(function(frame) {\n      return frame.data;\n    }));\n    try {\n      var headers = this.decompress(buffer);\n    } catch(error) {\n      this._log.error({ err: error }, 'Header decompression error');\n      this.emit('error', 'COMPRESSION_ERROR');\n      return;\n    }\n    this.push(util._extend(this._base, { headers: headers }));\n    this._inProgress = false;\n  }\n\n  done();\n};\n\n// Helper functions\n// ================\n\n// Concatenate an array of buffers into a new buffer\nfunction concat(buffers) {\n  var size = 0;\n  for (var i = 0; i < buffers.length; i++) {\n    size += buffers[i].length;\n  }\n\n  var concatenated = new Buffer(size);\n  for (var cursor = 0, j = 0; j < buffers.length; cursor += buffers[j].length, j++) {\n    buffers[j].copy(concatenated, cursor);\n  }\n\n  return concatenated;\n}\n\n// Cut `buffer` into chunks not larger than `size`\nfunction cut(buffer, size) {\n  var chunks = [];\n  var cursor = 0;\n  do {\n    var chunkSize = Math.min(size, buffer.length - cursor);\n    chunks.push(buffer.slice(cursor, cursor + chunkSize));\n    cursor += chunkSize;\n  } while(cursor < buffer.length);\n  return chunks;\n}\n\nfunction trim(string) {\n  return string.trim();\n}\n"]},"metadata":{},"sourceType":"script"}