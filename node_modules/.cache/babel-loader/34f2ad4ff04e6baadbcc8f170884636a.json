{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\n\nconst metadata_1 = require(\"./metadata\");\n\nconst constants_1 = require(\"./constants\");\n\nvar PickResultType;\n\n(function (PickResultType) {\n  PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n  PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n  PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n  PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType = exports.PickResultType || (exports.PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */\n\n\nclass UnavailablePicker {\n  constructor(status) {\n    if (status !== undefined) {\n      this.status = status;\n    } else {\n      this.status = {\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'No connection established',\n        metadata: new metadata_1.Metadata()\n      };\n    }\n  }\n\n  pick(pickArgs) {\n    return {\n      pickResultType: PickResultType.TRANSIENT_FAILURE,\n      subchannel: null,\n      status: this.status,\n      extraFilterFactories: [],\n      onCallStarted: null\n    };\n  }\n\n}\n\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */\n\nclass QueuePicker {\n  // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n  constructor(loadBalancer) {\n    this.loadBalancer = loadBalancer;\n    this.calledExitIdle = false;\n  }\n\n  pick(pickArgs) {\n    if (!this.calledExitIdle) {\n      process.nextTick(() => {\n        this.loadBalancer.exitIdle();\n      });\n      this.calledExitIdle = true;\n    }\n\n    return {\n      pickResultType: PickResultType.QUEUE,\n      subchannel: null,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null\n    };\n  }\n\n}\n\nexports.QueuePicker = QueuePicker;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;AAmBA;;AACA;;AAKA,IAAYA,cAAZ;;AAAA,WAAYA,cAAZ,EAA0B;AACxBA;AACAA;AACAA;AACAA;AACD,CALD,EAAYA,cAAc,GAAdC,oDAAc,EAAd,CAAZ;AA2EA;;;;;;AAIA,MAAaC,iBAAb,CAA8B;AAE5BC,cAAYC,MAAZ,EAAiC;AAC/B,QAAIA,MAAM,KAAKC,SAAf,EAA0B;AACxB,WAAKD,MAAL,GAAcA,MAAd;AACD,KAFD,MAEO;AACL,WAAKA,MAAL,GAAc;AACZE,YAAI,EAAEC,mBAAOC,WADD;AAEZC,eAAO,EAAE,2BAFG;AAGZC,gBAAQ,EAAE,IAAIC,mBAAJ;AAHE,OAAd;AAKD;AACF;;AACDC,MAAI,CAACC,QAAD,EAAmB;AACrB,WAAO;AACLC,oBAAc,EAAEd,cAAc,CAACe,iBAD1B;AAELC,gBAAU,EAAE,IAFP;AAGLZ,YAAM,EAAE,KAAKA,MAHR;AAILa,0BAAoB,EAAE,EAJjB;AAKLC,mBAAa,EAAE;AALV,KAAP;AAOD;;AArB2B;;AAA9BjB;AAwBA;;;;;;;;AAOA,MAAakB,WAAb,CAAwB;AAEtB;AACAhB,cAAoBiB,YAApB,EAA8C;AAA1B;AAFZ,0BAAiB,KAAjB;AAE0C;;AAElDR,MAAI,CAACC,QAAD,EAAmB;AACrB,QAAI,CAAC,KAAKQ,cAAV,EAA0B;AACxBC,aAAO,CAACC,QAAR,CAAiB,MAAK;AACpB,aAAKH,YAAL,CAAkBI,QAAlB;AACD,OAFD;AAGA,WAAKH,cAAL,GAAsB,IAAtB;AACD;;AACD,WAAO;AACLP,oBAAc,EAAEd,cAAc,CAACyB,KAD1B;AAELT,gBAAU,EAAE,IAFP;AAGLZ,YAAM,EAAE,IAHH;AAILa,0BAAoB,EAAE,EAJjB;AAKLC,mBAAa,EAAE;AALV,KAAP;AAOD;;AAnBqB;;AAAxBjB","names":["PickResultType","exports","UnavailablePicker","constructor","status","undefined","code","constants_1","UNAVAILABLE","details","metadata","metadata_1","pick","pickArgs","pickResultType","TRANSIENT_FAILURE","subchannel","extraFilterFactories","onCallStarted","QueuePicker","loadBalancer","calledExitIdle","process","nextTick","exitIdle","QUEUE"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/picker.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Subchannel } from './subchannel';\nimport { StatusObject } from './call-stream';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { LoadBalancer } from './load-balancer';\nimport { FilterFactory, Filter } from './filter';\nimport { SubchannelInterface } from './subchannel-interface';\n\nexport enum PickResultType {\n  COMPLETE,\n  QUEUE,\n  TRANSIENT_FAILURE,\n  DROP,\n}\n\nexport interface PickResult {\n  pickResultType: PickResultType;\n  /**\n   * The subchannel to use as the transport for the call. Only meaningful if\n   * `pickResultType` is COMPLETE. If null, indicates that the call should be\n   * dropped.\n   */\n  subchannel: SubchannelInterface | null;\n  /**\n   * The status object to end the call with. Populated if and only if\n   * `pickResultType` is TRANSIENT_FAILURE.\n   */\n  status: StatusObject | null;\n  /**\n   * Extra FilterFactory (can be multiple encapsulated in a FilterStackFactory)\n   * provided by the load balancer to be used with the call. For technical\n   * reasons filters from this factory will not see sendMetadata events.\n   */\n  extraFilterFactories: FilterFactory<Filter>[];\n  onCallStarted: (() => void) | null;\n}\n\nexport interface CompletePickResult extends PickResult {\n  pickResultType: PickResultType.COMPLETE;\n  subchannel: SubchannelInterface | null;\n  status: null;\n  extraFilterFactories: FilterFactory<Filter>[];\n  onCallStarted: (() => void) | null;\n}\n\nexport interface QueuePickResult extends PickResult {\n  pickResultType: PickResultType.QUEUE;\n  subchannel: null;\n  status: null;\n  extraFilterFactories: [];\n  onCallStarted: null;\n}\n\nexport interface TransientFailurePickResult extends PickResult {\n  pickResultType: PickResultType.TRANSIENT_FAILURE;\n  subchannel: null;\n  status: StatusObject;\n  extraFilterFactories: [];\n  onCallStarted: null;\n}\n\nexport interface DropCallPickResult extends PickResult {\n  pickResultType: PickResultType.DROP;\n  subchannel: null;\n  status: StatusObject;\n  extraFilterFactories: [];\n  onCallStarted: null;\n}\n\nexport interface PickArgs {\n  metadata: Metadata;\n  extraPickInfo: { [key: string]: string };\n}\n\n/**\n * A proxy object representing the momentary state of a load balancer. Picks\n * subchannels or returns other information based on that state. Should be\n * replaced every time the load balancer changes state.\n */\nexport interface Picker {\n  pick(pickArgs: PickArgs): PickResult;\n}\n\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */\nexport class UnavailablePicker implements Picker {\n  private status: StatusObject;\n  constructor(status?: StatusObject) {\n    if (status !== undefined) {\n      this.status = status;\n    } else {\n      this.status = {\n        code: Status.UNAVAILABLE,\n        details: 'No connection established',\n        metadata: new Metadata(),\n      };\n    }\n  }\n  pick(pickArgs: PickArgs): TransientFailurePickResult {\n    return {\n      pickResultType: PickResultType.TRANSIENT_FAILURE,\n      subchannel: null,\n      status: this.status,\n      extraFilterFactories: [],\n      onCallStarted: null,\n    };\n  }\n}\n\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */\nexport class QueuePicker {\n  private calledExitIdle = false;\n  // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n  constructor(private loadBalancer: LoadBalancer) {}\n\n  pick(pickArgs: PickArgs): QueuePickResult {\n    if (!this.calledExitIdle) {\n      process.nextTick(() => {\n        this.loadBalancer.exitIdle();\n      });\n      this.calledExitIdle = true;\n    }\n    return {\n      pickResultType: PickResultType.QUEUE,\n      subchannel: null,\n      status: null,\n      extraFilterFactories: [],\n      onCallStarted: null,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}