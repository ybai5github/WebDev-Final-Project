{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\n\nconst events_1 = require(\"events\");\n\nconst http2 = require(\"http2\");\n\nconst stream_1 = require(\"stream\");\n\nconst zlib = require(\"zlib\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst logging = require(\"./logging\");\n\nconst TRACER_NAME = 'server_call';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\n\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n}\n\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\n\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n}\n\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\n\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n  _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.emit('error', err);\n    }\n\n    callback();\n  }\n\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n\n}\n\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\n\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n\n}\n\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final; // Internal class that wraps the HTTP2 request.\n\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = setTimeout(() => {}, 0);\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      this.cancelled = true;\n      this.emit('cancelled', 'cancelled');\n      this.emit('streamEnd', false);\n      this.sendStatus({\n        code: constants_1.Status.CANCELLED,\n        details: 'Cancelled by client',\n        metadata: new metadata_1.Metadata()\n      });\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    } // Clear noop timer\n\n\n    clearTimeout(this.deadlineTimer);\n  }\n\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n\n    return this.cancelled;\n  }\n\n  getDecompressedMessage(message, encoding) {\n    switch (encoding) {\n      case 'deflate':\n        {\n          return new Promise((resolve, reject) => {\n            zlib.inflate(message.slice(5), (err, output) => {\n              if (err) {\n                this.sendError({\n                  code: constants_1.Status.INTERNAL,\n                  details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n                });\n                resolve();\n              } else {\n                resolve(output);\n              }\n            });\n          });\n        }\n\n      case 'gzip':\n        {\n          return new Promise((resolve, reject) => {\n            zlib.unzip(message.slice(5), (err, output) => {\n              if (err) {\n                this.sendError({\n                  code: constants_1.Status.INTERNAL,\n                  details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n                });\n                resolve();\n              } else {\n                resolve(output);\n              }\n            });\n          });\n        }\n\n      case 'identity':\n        {\n          return Promise.resolve(message.slice(5));\n        }\n\n      default:\n        {\n          this.sendError({\n            code: constants_1.Status.UNIMPLEMENTED,\n            details: `Received message compressed with unsupported encoding \"${encoding}\"`\n          });\n          return Promise.resolve();\n        }\n    }\n  }\n\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null; // TODO(cjihrig): Include compression headers.\n\n    const headers = Object.assign({}, defaultResponseHeaders, custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers); // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    } // Remove several headers that should not be propagated to the application\n\n\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  receiveUnaryMessage(encoding) {\n    return new Promise((resolve, reject) => {\n      const stream = this.stream;\n      const chunks = [];\n      let totalLength = 0;\n      stream.on('data', data => {\n        chunks.push(data);\n        totalLength += data.byteLength;\n      });\n      stream.once('end', async () => {\n        try {\n          const requestBytes = Buffer.concat(chunks, totalLength);\n\n          if (this.maxReceiveMessageSize !== -1 && requestBytes.length > this.maxReceiveMessageSize) {\n            this.sendError({\n              code: constants_1.Status.RESOURCE_EXHAUSTED,\n              details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`\n            });\n            resolve();\n          }\n\n          this.emit('receiveMessage');\n          const compressed = requestBytes.readUInt8(0) === 1;\n          const compressedMessageEncoding = compressed ? encoding : 'identity';\n          const decompressedMessage = await this.getDecompressedMessage(requestBytes, compressedMessageEncoding); // Encountered an error with decompression; it'll already have been propogated back\n          // Just return early\n\n          if (!decompressedMessage) {\n            resolve();\n          } else {\n            resolve(this.deserializeMessage(decompressedMessage));\n          }\n        } catch (err) {\n          err.code = constants_1.Status.INTERNAL;\n          this.sendError(err);\n          resolve();\n        }\n      });\n    });\n  }\n\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value); // TODO(cjihrig): Call compression aware serializeMessage().\n\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes) {\n    return this.handler.deserialize(bytes);\n  }\n\n  async sendUnaryMessage(err, value, metadata, flags) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (!metadata) {\n      metadata = new metadata_1.Metadata();\n    }\n\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {\n        err.metadata = metadata;\n      }\n\n      this.sendError(err);\n      return;\n    }\n\n    try {\n      const response = this.serializeMessage(value);\n      this.write(response);\n      this.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata\n      });\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.sendError(err);\n    }\n  }\n\n  sendStatus(statusObj) {\n    var _a;\n\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    clearTimeout(this.deadlineTimer);\n\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        const trailersToSend = Object.assign({\n          [GRPC_STATUS_HEADER]: statusObj.code,\n          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n        }, statusObj.metadata.toHttp2Headers());\n        this.stream.sendTrailers(trailersToSend);\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n\n  sendError(error) {\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : new metadata_1.Metadata()\n    };\n\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n  }\n\n  setupReadable(readable, encoding) {\n    const decoder = new stream_decoder_1.StreamDecoder();\n    let readsDone = false;\n    let pendingMessageProcessing = false;\n    let pushedEnd = false;\n\n    const maybePushEnd = () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        this.pushOrBufferMessage(readable, null);\n      }\n    };\n\n    this.stream.on('data', async data => {\n      const messages = decoder.write(data);\n      pendingMessageProcessing = true;\n      this.stream.pause();\n\n      for (const message of messages) {\n        if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n          this.sendError({\n            code: constants_1.Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n          });\n          return;\n        }\n\n        this.emit('receiveMessage');\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding); // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n\n        if (!decompressedMessage) return;\n        this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      maybePushEnd();\n    });\n    this.stream.once('end', () => {\n      readsDone = true;\n      maybePushEnd();\n    });\n  }\n\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  async pushMessage(readable, messageBytes) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n\n      return;\n    }\n\n    trace('Received message of length ' + messageBytes.length);\n    this.isPushPending = true;\n\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n\n      if (!('code' in error && typeof error.code === 'number' && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n        // The error code is not a valid gRPC code so its being overwritten.\n        error.code = constants_1.Status.INTERNAL;\n      }\n\n      readable.emit('error', error);\n    }\n\n    this.isPushPending = false;\n\n    if (this.bufferedMessages.length > 0) {\n      this.pushMessage(readable, this.bufferedMessages.shift());\n    }\n  }\n\n  getPeer() {\n    const socket = this.stream.session.socket;\n\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline() {\n    return this.deadline;\n  }\n\n}\n\nexports.Http2ServerCallStream = Http2ServerCallStream;\n\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;AAiBA;;AACA;;AACA;;AACA;;AAGA;;AAOA;;AACA;;AAGA;;AAEA,MAAMA,WAAW,GAAG,aAApB;;AAEA,SAASC,KAAT,CAAeC,IAAf,EAA2B;AACzBC,SAAO,CAACF,KAAR,CAAcG,yBAAaC,KAA3B,EAAkCL,WAAlC,EAA+CE,IAA/C;AACD;;AAMD,MAAMI,2BAA2B,GAAG,sBAApC;AACA,MAAMC,oBAAoB,GAAG,eAA7B;AACA,MAAMC,mBAAmB,GAAG,cAA5B;AACA,MAAMC,kBAAkB,GAAG,aAA3B;AACA,MAAMC,mBAAmB,GAAG,cAA5B;AACA,MAAMC,cAAc,GAAG,wBAAvB;AACA,MAAMC,iBAAiB,GAA+B;AACpDC,GAAC,EAAE,OADiD;AAEpDC,GAAC,EAAE,KAFiD;AAGpDC,GAAC,EAAE,IAHiD;AAIpDC,GAAC,EAAE,CAJiD;AAKpDC,GAAC,EAAE,KALiD;AAMpDC,GAAC,EAAE;AANiD,CAAtD;AAQA,MAAMC,sBAAsB,GAAG;AAC7B;AACA;AACA,GAACb,2BAAD,GAA+B,uBAHF;AAI7B,GAACC,oBAAD,GAAwB,UAJK;AAK7B,GAACa,KAAK,CAACC,SAAN,CAAgBC,mBAAjB,GAAuCF,KAAK,CAACC,SAAN,CAAgBE,cAL1B;AAM7B,GAACH,KAAK,CAACC,SAAN,CAAgBG,yBAAjB,GAA6C;AANhB,CAA/B;AAQA,MAAMC,sBAAsB,GAAG;AAC7BC,iBAAe,EAAE;AADY,CAA/B;;AAmCA,MAAaC,mBAAb,SACUC,qBADV,CACsB;AAIpBC,cACUC,IADV,EAESC,QAFT,EAGSC,OAHT,EAG6B;AAE3B;AAJQ;AACD;AACA;AAGP,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKH,IAAL,CAAUI,gBAAV,CAA2B,IAA3B;AACD;;AAEDC,SAAO;AACL,WAAO,KAAKL,IAAL,CAAUK,OAAV,EAAP;AACD;;AAEDC,cAAY,CAACC,gBAAD,EAA2B;AACrC,SAAKP,IAAL,CAAUM,YAAV,CAAuBC,gBAAvB;AACD;;AAEDC,aAAW;AACT,WAAO,KAAKR,IAAL,CAAUQ,WAAV,EAAP;AACD;;AAxBmB;;AADtBC;;AA4BA,MAAaC,wBAAb,SACUC,iBADV,CACkB;AAIhBZ,cACUC,IADV,EAESC,QAFT,EAGSW,WAHT,EAIEC,QAJF,EAIkB;AAEhB,UAAM;AAAEC,gBAAU,EAAE;AAAd,KAAN;AALQ;AACD;AACA;AAIP,SAAKX,SAAL,GAAiB,KAAjB;AACA,SAAKH,IAAL,CAAUI,gBAAV,CAA2B,IAA3B;AACA,SAAKJ,IAAL,CAAUe,aAAV,CAAwB,IAAxB,EAA8BF,QAA9B;AACD;;AAEDG,OAAK,CAACC,IAAD,EAAa;AAChB,QAAI,CAAC,KAAKjB,IAAL,CAAUkB,uBAAV,CAAkC,IAAlC,CAAL,EAA8C;AAC5C;AACD;;AAED,SAAKlB,IAAL,CAAUmB,MAAV;AACD;;AAEDd,SAAO;AACL,WAAO,KAAKL,IAAL,CAAUK,OAAV,EAAP;AACD;;AAEDC,cAAY,CAACC,gBAAD,EAA2B;AACrC,SAAKP,IAAL,CAAUM,YAAV,CAAuBC,gBAAvB;AACD;;AAEDC,aAAW;AACT,WAAO,KAAKR,IAAL,CAAUQ,WAAV,EAAP;AACD;;AAlCe;;AADlBC;;AAsCA,MAAaW,wBAAb,SACUT,iBADV,CACkB;AAKhBZ,cACUC,IADV,EAESC,QAFT,EAGSoB,SAHT,EAISnB,OAJT,EAI6B;AAE3B,UAAM;AAAEY,gBAAU,EAAE;AAAd,KAAN;AALQ;AACD;AACA;AACA;AAGP,SAAKX,SAAL,GAAiB,KAAjB;AACA,SAAKmB,gBAAL,GAAwB,IAAIC,mBAAJ,EAAxB;AACA,SAAKvB,IAAL,CAAUI,gBAAV,CAA2B,IAA3B;AAEA,SAAKoB,EAAL,CAAQ,OAAR,EAAkBC,GAAD,IAAQ;AACvB,WAAKzB,IAAL,CAAU0B,SAAV,CAAoBD,GAApB;AACA,WAAKE,GAAL;AACD,KAHD;AAID;;AAEDtB,SAAO;AACL,WAAO,KAAKL,IAAL,CAAUK,OAAV,EAAP;AACD;;AAEDC,cAAY,CAACC,gBAAD,EAA2B;AACrC,SAAKP,IAAL,CAAUM,YAAV,CAAuBC,gBAAvB;AACD;;AAEDC,aAAW;AACT,WAAO,KAAKR,IAAL,CAAUQ,WAAV,EAAP;AACD;;AAEDoB,QAAM,CACJC,KADI,EAEJhB,QAFI,EAGJ;AACAiB,UAJI,EAI8B;AAElC,QAAI;AACF,YAAMC,QAAQ,GAAG,KAAK/B,IAAL,CAAUgC,gBAAV,CAA2BH,KAA3B,CAAjB;;AAEA,UAAI,CAAC,KAAK7B,IAAL,CAAUiC,KAAV,CAAgBF,QAAhB,CAAL,EAAgC;AAC9B,aAAK/B,IAAL,CAAUkC,IAAV,CAAe,OAAf,EAAwBJ,QAAxB;AACA;AACD;AACF,KAPD,CAOE,OAAOL,GAAP,EAAY;AACZA,SAAG,CAACU,IAAJ,GAAW7D,mBAAO8D,QAAlB;AACA,WAAKC,IAAL,CAAU,OAAV,EAAmBZ,GAAnB;AACD;;AAEDK,YAAQ;AACT;;AAEDQ,QAAM,CAACR,QAAD,EAAmB;AACvB,SAAK9B,IAAL,CAAUuC,UAAV,CAAqB;AACnBJ,UAAI,EAAE7D,mBAAOkE,EADM;AAEnBC,aAAO,EAAE,IAFU;AAGnBxC,cAAQ,EAAE,KAAKqB;AAHI,KAArB;AAKAQ,YAAQ,CAAC,IAAD,CAAR;AACD,GA9De,CAgEhB;;;AACAH,KAAG,CAAC1B,QAAD,EAAe;AAChB,QAAIA,QAAJ,EAAc;AACZ,WAAKqB,gBAAL,GAAwBrB,QAAxB;AACD;;AAED,WAAO,MAAM0B,GAAN,EAAP;AACD;;AAvEe;;AADlBlB;;AA2EA,MAAaiC,sBAAb,SACU/B,eADV,CACgB;AAKdZ,cACUC,IADV,EAESC,QAFT,EAGSoB,SAHT,EAIST,WAJT,EAKEC,QALF,EAKkB;AAEhB,UAAM;AAAEC,gBAAU,EAAE;AAAd,KAAN;AANQ;AACD;AACA;AACA;AAIP,SAAKX,SAAL,GAAiB,KAAjB;AACA,SAAKmB,gBAAL,GAAwB,IAAIC,mBAAJ,EAAxB;AACA,SAAKvB,IAAL,CAAUI,gBAAV,CAA2B,IAA3B;AACA,SAAKJ,IAAL,CAAUe,aAAV,CAAwB,IAAxB,EAA8BF,QAA9B;AAEA,SAAKW,EAAL,CAAQ,OAAR,EAAkBC,GAAD,IAAQ;AACvB,WAAKzB,IAAL,CAAU0B,SAAV,CAAoBD,GAApB;AACA,WAAKE,GAAL;AACD,KAHD;AAID;;AAEDtB,SAAO;AACL,WAAO,KAAKL,IAAL,CAAUK,OAAV,EAAP;AACD;;AAEDC,cAAY,CAACC,gBAAD,EAA2B;AACrC,SAAKP,IAAL,CAAUM,YAAV,CAAuBC,gBAAvB;AACD;;AAEDC,aAAW;AACT,WAAO,KAAKR,IAAL,CAAUQ,WAAV,EAAP;AACD,GAlCa,CAoCd;;;AACAmB,KAAG,CAAC1B,QAAD,EAAe;AAChB,QAAIA,QAAJ,EAAc;AACZ,WAAKqB,gBAAL,GAAwBrB,QAAxB;AACD;;AAED,WAAO,MAAM0B,GAAN,EAAP;AACD;;AA3Ca;;AADhBlB;AA+CAiC,sBAAsB,CAACC,SAAvB,CAAiC3B,KAAjC,GACEN,wBAAwB,CAACiC,SAAzB,CAAmC3B,KADrC;AAEA0B,sBAAsB,CAACC,SAAvB,CAAiCf,MAAjC,GACER,wBAAwB,CAACuB,SAAzB,CAAmCf,MADrC;AAEAc,sBAAsB,CAACC,SAAvB,CAAiCL,MAAjC,GACElB,wBAAwB,CAACuB,SAAzB,CAAmCL,MADrC,C,CA+EA;;AACA,MAAaM,qBAAb,SAGU9C,qBAHV,CAGsB;AAapBC,cACU8C,MADV,EAEUC,OAFV,EAGUC,OAHV,EAGiC;AAE/B;AAJQ;AACA;AACA;AAfV,qBAAY,KAAZ;AACA,yBAA8BC,UAAU,CAAC,MAAK,CAAG,CAAT,EAAW,CAAX,CAAxC;AACQ,oBAAqBC,QAArB;AACA,wBAAe,KAAf;AACA,wBAAe,KAAf;AACA,mBAAU,KAAV;AACA,yBAAgB,KAAhB;AACA,4BAAyC,EAAzC;AACA,0BAA4C,EAA5C;AACA,8BAA6B3E,2CAA7B;AACA,iCAAgCA,8CAAhC;AASN,SAAKuE,MAAL,CAAYX,IAAZ,CAAiB,OAAjB,EAA2BT,GAAD,IAA6B;AACrD;;;;;AAKD,KAND;AAQA,SAAKoB,MAAL,CAAYX,IAAZ,CAAiB,OAAjB,EAA0B,MAAK;;;AAC7B/D,WAAK,CACH,wBAAoB,MAClB,KAAK2E,OADa,MACN,IADM,IACNI,aADM,GACN,MADM,GACNA,GAAEC,IADhB,IAEE,8BAFF,GAGE,KAAKN,MAAL,CAAYO,OAJX,CAAL;AAMA,WAAKjD,SAAL,GAAiB,IAAjB;AACA,WAAKkC,IAAL,CAAU,WAAV,EAAuB,WAAvB;AACA,WAAKA,IAAL,CAAU,WAAV,EAAuB,KAAvB;AACA,WAAKE,UAAL,CAAgB;AAACJ,YAAI,EAAE7D,mBAAO+E,SAAd;AAAyBZ,eAAO,EAAE,qBAAlC;AAAyDxC,gBAAQ,EAAE,IAAIsB,mBAAJ;AAAnE,OAAhB;AACD,KAXD;AAaA,SAAKsB,MAAL,CAAYrB,EAAZ,CAAe,OAAf,EAAwB,MAAK;AAC3B,WAAKa,IAAL,CAAU,OAAV;AACD,KAFD;;AAIA,QAAI,kCAAkCU,OAAtC,EAA+C;AAC7C,WAAKO,kBAAL,GAA0BP,OAAO,CAAC,8BAAD,CAAjC;AACD;;AACD,QAAI,qCAAqCA,OAAzC,EAAkD;AAChD,WAAKQ,qBAAL,GAA6BR,OAAO,CAAC,iCAAD,CAApC;AACD,KAlC8B,CAoC/B;;;AACAS,gBAAY,CAAC,KAAKC,aAAN,CAAZ;AACD;;AAEOC,gBAAc;AACpB;;AAEA,QAAI,KAAKb,MAAL,CAAYc,SAAZ,IAAyB,KAAKd,MAAL,CAAYe,MAAzC,EAAiD;AAC/C,WAAKzD,SAAL,GAAiB,IAAjB;AACD;;AACD,WAAO,KAAKA,SAAZ;AACD;;AAEO0D,wBAAsB,CAACC,OAAD,EAAkBjD,QAAlB,EAAkC;AAC9D,YAAQA,QAAR;AACE,WAAK,SAAL;AAAgB;AACd,iBAAO,IAAIkD,OAAJ,CAAgC,CAACC,OAAD,EAAUC,MAAV,KAAoB;AACzDC,gBAAI,CAACC,OAAL,CAAaL,OAAO,CAACM,KAAR,CAAc,CAAd,CAAb,EAA+B,CAAC3C,GAAD,EAAM4C,MAAN,KAAgB;AAC7C,kBAAI5C,GAAJ,EAAS;AACP,qBAAKC,SAAL,CAAe;AACbS,sBAAI,EAAE7D,mBAAO8D,QADA;AAEbK,yBAAO,EAAE,oCAAoC5B,QAAQ,SAASA,QAAQ;AAFzD,iBAAf;AAIAmD,uBAAO;AACR,eAND,MAMO;AACLA,uBAAO,CAACK,MAAD,CAAP;AACD;AACF,aAVD;AAWD,WAZM,CAAP;AAaD;;AAED,WAAK,MAAL;AAAa;AACX,iBAAO,IAAIN,OAAJ,CAAgC,CAACC,OAAD,EAAUC,MAAV,KAAoB;AACzDC,gBAAI,CAACI,KAAL,CAAWR,OAAO,CAACM,KAAR,CAAc,CAAd,CAAX,EAA6B,CAAC3C,GAAD,EAAM4C,MAAN,KAAgB;AAC3C,kBAAI5C,GAAJ,EAAS;AACP,qBAAKC,SAAL,CAAe;AACbS,sBAAI,EAAE7D,mBAAO8D,QADA;AAEbK,yBAAO,EAAE,oCAAoC5B,QAAQ,SAASA,QAAQ;AAFzD,iBAAf;AAIAmD,uBAAO;AACR,eAND,MAMO;AACLA,uBAAO,CAACK,MAAD,CAAP;AACD;AACF,aAVD;AAWD,WAZM,CAAP;AAaD;;AAED,WAAK,UAAL;AAAiB;AACf,iBAAON,OAAO,CAACC,OAAR,CAAgBF,OAAO,CAACM,KAAR,CAAc,CAAd,CAAhB,CAAP;AACD;;AAED;AAAS;AACP,eAAK1C,SAAL,CAAe;AACbS,gBAAI,EAAE7D,mBAAOiG,aADA;AAEb9B,mBAAO,EAAE,0DAA0D5B,QAAQ;AAF9D,WAAf;AAIA,iBAAOkD,OAAO,CAACC,OAAR,EAAP;AACD;AA3CH;AA6CD;;AAED1D,cAAY,CAACkE,cAAD,EAA0B;AACpC,QAAI,KAAKd,cAAL,EAAJ,EAA2B;AACzB;AACD;;AAED,QAAI,KAAKe,YAAT,EAAuB;AACrB;AACD;;AAED,SAAKA,YAAL,GAAoB,IAApB;AACA,UAAMC,MAAM,GAAGF,cAAc,GAAGA,cAAc,CAACG,cAAf,EAAH,GAAqC,IAAlE,CAVoC,CAWpC;;AACA,UAAMC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBzF,sBAAlB,EAA0CqF,MAA1C,CAAhB;AACA,SAAK7B,MAAL,CAAYkC,OAAZ,CAAoBH,OAApB,EAA6BjF,sBAA7B;AACD;;AAEDqF,iBAAe,CAACJ,OAAD,EAAmC;AAChD,UAAM3E,QAAQ,GAAGsB,oBAAS0D,gBAAT,CAA0BL,OAA1B,CAAjB,CADgD,CAGhD;;AAEA,UAAMM,aAAa,GAAGjF,QAAQ,CAACkF,GAAT,CAAavG,mBAAb,CAAtB;;AAEA,QAAIsG,aAAa,CAACE,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,YAAMC,KAAK,GAAGH,aAAa,CAAC,CAAD,CAAb,CAAiBI,QAAjB,GAA4BD,KAA5B,CAAkCxG,cAAlC,CAAd;;AAEA,UAAIwG,KAAK,KAAK,IAAd,EAAoB;AAClB,cAAM5D,GAAG,GAAG,IAAI8D,KAAJ,CAAU,kBAAV,CAAZ;AACA9D,WAAG,CAACU,IAAJ,GAAW7D,mBAAOkH,YAAlB;AACA,aAAK9D,SAAL,CAAeD,GAAf;AACA,eAAOxB,QAAP;AACD;;AAED,YAAMwF,OAAO,GAAI,CAACJ,KAAK,CAAC,CAAD,CAAN,GAAYvG,iBAAiB,CAACuG,KAAK,CAAC,CAAD,CAAN,CAA9B,GAA4C,CAA5D;AAEA,YAAMK,GAAG,GAAG,IAAIC,IAAJ,EAAZ;AACA,WAAKC,QAAL,GAAgBF,GAAG,CAACG,eAAJ,CAAoBH,GAAG,CAACI,eAAJ,KAAwBL,OAA5C,CAAhB;AACA,WAAKhC,aAAL,GAAqBT,UAAU,CAAC+C,qBAAD,EAAwBN,OAAxB,EAAiC,IAAjC,CAA/B;AACAxF,cAAQ,CAAC+F,MAAT,CAAgBpH,mBAAhB;AACD,KAvB+C,CAyBhD;;;AACAqB,YAAQ,CAAC+F,MAAT,CAAgB1G,KAAK,CAACC,SAAN,CAAgB0G,4BAAhC;AACAhG,YAAQ,CAAC+F,MAAT,CAAgB1G,KAAK,CAACC,SAAN,CAAgB2G,eAAhC;AACAjG,YAAQ,CAAC+F,MAAT,CAAgB1G,KAAK,CAACC,SAAN,CAAgBG,yBAAhC;AACAO,YAAQ,CAAC+F,MAAT,CAAgB,sBAAhB;AAEA,WAAO/F,QAAP;AACD;;AAEDkG,qBAAmB,CAACtF,QAAD,EAAiB;AAClC,WAAO,IAAIkD,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;AACrC,YAAMpB,MAAM,GAAG,KAAKA,MAApB;AACA,YAAMuD,MAAM,GAAa,EAAzB;AACA,UAAIC,WAAW,GAAG,CAAlB;AAEAxD,YAAM,CAACrB,EAAP,CAAU,MAAV,EAAmB8E,IAAD,IAAiB;AACjCF,cAAM,CAACG,IAAP,CAAYD,IAAZ;AACAD,mBAAW,IAAIC,IAAI,CAACE,UAApB;AACD,OAHD;AAKA3D,YAAM,CAACX,IAAP,CAAY,KAAZ,EAAmB,YAAW;AAC5B,YAAI;AACF,gBAAMuE,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAcP,MAAd,EAAsBC,WAAtB,CAArB;;AACA,cACE,KAAK9C,qBAAL,KAA+B,CAAC,CAAhC,IACAkD,YAAY,CAACrB,MAAb,GAAsB,KAAK7B,qBAF7B,EAGE;AACA,iBAAK7B,SAAL,CAAe;AACbS,kBAAI,EAAE7D,mBAAOsI,kBADA;AAEbnE,qBAAO,EAAE,qCAAqCgE,YAAY,CAACrB,MAAM,QAAQ,KAAK7B,qBAAqB;AAFtF,aAAf;AAIAS,mBAAO;AACR;;AAED,eAAK3B,IAAL,CAAU,gBAAV;AAEA,gBAAMwE,UAAU,GAAGJ,YAAY,CAACK,SAAb,CAAuB,CAAvB,MAA8B,CAAjD;AACA,gBAAMC,yBAAyB,GAAGF,UAAU,GAAGhG,QAAH,GAAc,UAA1D;AACA,gBAAMmG,mBAAmB,GAAG,MAAM,KAAKnD,sBAAL,CAA4B4C,YAA5B,EAA0CM,yBAA1C,CAAlC,CAjBE,CAmBF;AACA;;AACA,cAAI,CAACC,mBAAL,EAA0B;AACxBhD,mBAAO;AACR,WAFD,MAGK;AACHA,mBAAO,CAAC,KAAKiD,kBAAL,CAAwBD,mBAAxB,CAAD,CAAP;AACD;AACF,SA3BD,CA2BE,OAAOvF,GAAP,EAAY;AACZA,aAAG,CAACU,IAAJ,GAAW7D,mBAAO8D,QAAlB;AACA,eAAKV,SAAL,CAAeD,GAAf;AACAuC,iBAAO;AACR;AACF,OAjCD;AAkCD,KA5CM,CAAP;AA6CD;;AAEDhC,kBAAgB,CAACkF,KAAD,EAAoB;AAClC,UAAMC,aAAa,GAAG,KAAKrE,OAAL,CAAazB,SAAb,CAAuB6F,KAAvB,CAAtB,CADkC,CAGlC;;AACA,UAAMV,UAAU,GAAGW,aAAa,CAACX,UAAjC;AACA,UAAMnC,MAAM,GAAGqC,MAAM,CAACU,WAAP,CAAmBZ,UAAU,GAAG,CAAhC,CAAf;AACAnC,UAAM,CAACgD,UAAP,CAAkB,CAAlB,EAAqB,CAArB;AACAhD,UAAM,CAACiD,aAAP,CAAqBd,UAArB,EAAiC,CAAjC;AACAW,iBAAa,CAACI,IAAd,CAAmBlD,MAAnB,EAA2B,CAA3B;AACA,WAAOA,MAAP;AACD;;AAED4C,oBAAkB,CAACO,KAAD,EAAc;AAC9B,WAAO,KAAK1E,OAAL,CAAalC,WAAb,CAAyB4G,KAAzB,CAAP;AACD;;AAEqB,QAAhBC,gBAAgB,CACpBhG,GADoB,EAEpByF,KAFoB,EAGpBjH,QAHoB,EAIpByH,KAJoB,EAIN;AAEd,QAAI,KAAKhE,cAAL,EAAJ,EAA2B;AACzB;AACD;;AACD,QAAI,CAACzD,QAAL,EAAe;AACbA,cAAQ,GAAG,IAAIsB,mBAAJ,EAAX;AACD;;AAED,QAAIE,GAAJ,EAAS;AACP,UAAI,CAACoD,MAAM,CAAClC,SAAP,CAAiBgF,cAAjB,CAAgC3H,IAAhC,CAAqCyB,GAArC,EAA0C,UAA1C,CAAL,EAA4D;AAC1DA,WAAG,CAACxB,QAAJ,GAAeA,QAAf;AACD;;AACD,WAAKyB,SAAL,CAAeD,GAAf;AACA;AACD;;AAED,QAAI;AACF,YAAMM,QAAQ,GAAG,KAAKC,gBAAL,CAAsBkF,KAAtB,CAAjB;AAEA,WAAKjF,KAAL,CAAWF,QAAX;AACA,WAAKQ,UAAL,CAAgB;AAAEJ,YAAI,EAAE7D,mBAAOkE,EAAf;AAAmBC,eAAO,EAAE,IAA5B;AAAkCxC;AAAlC,OAAhB;AACD,KALD,CAKE,OAAOwB,GAAP,EAAY;AACZA,SAAG,CAACU,IAAJ,GAAW7D,mBAAO8D,QAAlB;AACA,WAAKV,SAAL,CAAeD,GAAf;AACD;AACF;;AAEDc,YAAU,CAACqF,SAAD,EAAwB;;;AAChC,SAAKvF,IAAL,CAAU,SAAV,EAAqBuF,SAAS,CAACzF,IAA/B;AACA,SAAKE,IAAL,CAAU,WAAV,EAAuBuF,SAAS,CAACzF,IAAV,KAAmB7D,mBAAOkE,EAAjD;;AACA,QAAI,KAAKkB,cAAL,EAAJ,EAA2B;AACzB;AACD;;AAEDvF,SAAK,CACH,wBAAoB,MAClB,KAAK2E,OADa,MACN,IADM,IACNI,aADM,GACN,MADM,GACNA,GAAEC,IADhB,IAEE,2BAFF,GAGE7E,mBAAOsJ,SAAS,CAACzF,IAAjB,CAHF,GAIE,YAJF,GAKEyF,SAAS,CAACnF,OANT,CAAL;AASAe,gBAAY,CAAC,KAAKC,aAAN,CAAZ;;AAEA,QAAI,CAAC,KAAKoE,YAAV,EAAwB;AACtB,WAAKA,YAAL,GAAoB,IAApB;AACA,WAAKhF,MAAL,CAAYX,IAAZ,CAAiB,cAAjB,EAAiC,MAAK;AACpC,cAAM4F,cAAc,GAAGjD,MAAM,CAACC,MAAP,CACrB;AACE,WAACnG,kBAAD,GAAsBiJ,SAAS,CAACzF,IADlC;AAEE,WAACzD,mBAAD,GAAuBqJ,SAAS,CAACH,SAAS,CAACnF,OAAX;AAFlC,SADqB,EAKrBmF,SAAS,CAAC3H,QAAV,CAAmB0E,cAAnB,EALqB,CAAvB;AAQA,aAAK9B,MAAL,CAAYmF,YAAZ,CAAyBF,cAAzB;AACD,OAVD;AAWA,WAAKxH,YAAL;AACA,WAAKuC,MAAL,CAAYlB,GAAZ;AACD;AACF;;AAEDD,WAAS,CAACuG,KAAD,EAAkD;AACzD,UAAMC,MAAM,GAAiB;AAC3B/F,UAAI,EAAE7D,mBAAO6J,OADc;AAE3B1F,aAAO,EAAE,aAAawF,KAAb,GAAqBA,KAAK,CAACnE,OAA3B,GAAqC,eAFnB;AAG3B7D,cAAQ,EACN,cAAcgI,KAAd,IAAuBA,KAAK,CAAChI,QAAN,KAAmBmI,SAA1C,GACIH,KAAK,CAAChI,QADV,GAEI,IAAIsB,mBAAJ;AANqB,KAA7B;;AASA,QACE,UAAU0G,KAAV,IACA,OAAOA,KAAK,CAAC9F,IAAb,KAAsB,QADtB,IAEAkG,MAAM,CAACC,SAAP,CAAiBL,KAAK,CAAC9F,IAAvB,CAHF,EAIE;AACA+F,YAAM,CAAC/F,IAAP,GAAc8F,KAAK,CAAC9F,IAApB;;AAEA,UAAI,aAAa8F,KAAb,IAAsB,OAAOA,KAAK,CAACxF,OAAb,KAAyB,QAAnD,EAA6D;AAC3DyF,cAAM,CAACzF,OAAP,GAAiBwF,KAAK,CAACxF,OAAvB;AACD;AACF;;AAED,SAAKF,UAAL,CAAgB2F,MAAhB;AACD;;AAEDjG,OAAK,CAACJ,KAAD,EAAc;AACjB,QAAI,KAAK6B,cAAL,EAAJ,EAA2B;AACzB;AACD;;AAED,QACE,KAAKJ,kBAAL,KAA4B,CAAC,CAA7B,IACAzB,KAAK,CAACuD,MAAN,GAAe,KAAK9B,kBAFtB,EAGE;AACA,WAAK5B,SAAL,CAAe;AACbS,YAAI,EAAE7D,mBAAOsI,kBADA;AAEbnE,eAAO,EAAE,iCAAiCZ,KAAK,CAACuD,MAAM,QAAQ,KAAK9B,kBAAkB;AAFxE,OAAf;AAIA;AACD;;AAED,SAAKhD,YAAL;AACA,SAAK+B,IAAL,CAAU,aAAV;AACA,WAAO,KAAKQ,MAAL,CAAYZ,KAAZ,CAAkBJ,KAAlB,CAAP;AACD;;AAEDV,QAAM;AACJ,SAAK0B,MAAL,CAAY1B,MAAZ;AACD;;AAEDf,kBAAgB,CAACJ,IAAD,EAAwB;AACtC,SAAKkC,IAAL,CAAU,WAAV,EAAwBqG,MAAD,IAAW;AAChCvI,UAAI,CAACG,SAAL,GAAiB,IAAjB;AACAH,UAAI,CAACqC,IAAL,CAAU,WAAV,EAAuBkG,MAAvB;AACD,KAHD;AAID;;AAEDxH,eAAa,CACXyH,QADW,EAIX3H,QAJW,EAIK;AAEhB,UAAM4H,OAAO,GAAG,IAAIC,8BAAJ,EAAhB;AAEA,QAAIC,SAAS,GAAG,KAAhB;AAEA,QAAIC,wBAAwB,GAAG,KAA/B;AAEA,QAAIC,SAAS,GAAG,KAAhB;;AAEA,UAAMC,YAAY,GAAG,MAAK;AACxB,UAAI,CAACD,SAAD,IAAcF,SAAd,IAA2B,CAACC,wBAAhC,EAA0D;AACxDC,iBAAS,GAAG,IAAZ;AACA,aAAKE,mBAAL,CAAyBP,QAAzB,EAAmC,IAAnC;AACD;AACF,KALD;;AAOA,SAAK3F,MAAL,CAAYrB,EAAZ,CAAe,MAAf,EAAuB,MAAO8E,IAAP,IAAuB;AAC5C,YAAM0C,QAAQ,GAAGP,OAAO,CAACxG,KAAR,CAAcqE,IAAd,CAAjB;AAEAsC,8BAAwB,GAAG,IAA3B;AACA,WAAK/F,MAAL,CAAYoG,KAAZ;;AACA,WAAK,MAAMnF,OAAX,IAAsBkF,QAAtB,EAAgC;AAC9B,YACE,KAAKzF,qBAAL,KAA+B,CAAC,CAAhC,IACAO,OAAO,CAACsB,MAAR,GAAiB,KAAK7B,qBAFxB,EAGE;AACA,eAAK7B,SAAL,CAAe;AACbS,gBAAI,EAAE7D,mBAAOsI,kBADA;AAEbnE,mBAAO,EAAE,qCAAqCqB,OAAO,CAACsB,MAAM,QAAQ,KAAK7B,qBAAqB;AAFjF,WAAf;AAIA;AACD;;AACD,aAAKlB,IAAL,CAAU,gBAAV;AAEA,cAAMwE,UAAU,GAAG/C,OAAO,CAACgD,SAAR,CAAkB,CAAlB,MAAyB,CAA5C;AACA,cAAMC,yBAAyB,GAAGF,UAAU,GAAGhG,QAAH,GAAc,UAA1D;AACA,cAAMmG,mBAAmB,GAAG,MAAM,KAAKnD,sBAAL,CAA4BC,OAA5B,EAAqCiD,yBAArC,CAAlC,CAf8B,CAiB9B;AACA;;AACA,YAAI,CAACC,mBAAL,EAA0B;AAE1B,aAAK+B,mBAAL,CAAyBP,QAAzB,EAAmCxB,mBAAnC;AACD;;AACD4B,8BAAwB,GAAG,KAA3B;AACA,WAAK/F,MAAL,CAAY1B,MAAZ;AACA2H,kBAAY;AACb,KA/BD;AAiCA,SAAKjG,MAAL,CAAYX,IAAZ,CAAiB,KAAjB,EAAwB,MAAK;AAC3ByG,eAAS,GAAG,IAAZ;AACAG,kBAAY;AACb,KAHD;AAID;;AAED5H,yBAAuB,CACrBsH,QADqB,EAG4B;AAEjD,SAAKU,OAAL,GAAe,IAAf;;AAEA,WAAO,KAAKC,cAAL,CAAoB/D,MAApB,GAA6B,CAApC,EAAuC;AACrC,YAAMgE,WAAW,GAAG,KAAKD,cAAL,CAAoBE,KAApB,EAApB;AACA,YAAMH,OAAO,GAAGV,QAAQ,CAACjC,IAAT,CAAc6C,WAAd,CAAhB;;AAEA,UAAIA,WAAW,KAAK,IAAhB,IAAwBF,OAAO,KAAK,KAAxC,EAA+C;AAC7C,aAAKA,OAAL,GAAe,KAAf;AACA;AACD;AACF;;AAED,WAAO,KAAKA,OAAZ;AACD;;AAEOH,qBAAmB,CACzBP,QADyB,EAIzBc,YAJyB,EAIE;AAE3B,QAAI,KAAKC,aAAT,EAAwB;AACtB,WAAKC,gBAAL,CAAsBjD,IAAtB,CAA2B+C,YAA3B;AACD,KAFD,MAEO;AACL,WAAKG,WAAL,CAAiBjB,QAAjB,EAA2Bc,YAA3B;AACD;AACF;;AAEwB,QAAXG,WAAW,CACvBjB,QADuB,EAIvBc,YAJuB,EAII;AAE3B,QAAIA,YAAY,KAAK,IAArB,EAA2B;AACzBnL,WAAK,CAAC,wBAAD,CAAL;;AACA,UAAI,KAAK+K,OAAT,EAAkB;AAChBV,gBAAQ,CAACjC,IAAT,CAAc,IAAd;AACD,OAFD,MAEO;AACL,aAAK4C,cAAL,CAAoB5C,IAApB,CAAyB,IAAzB;AACD;;AAED;AACD;;AAEDpI,SAAK,CAAC,gCAAgCmL,YAAY,CAAClE,MAA9C,CAAL;AAEA,SAAKmE,aAAL,GAAqB,IAArB;;AAEA,QAAI;AACF,YAAMG,YAAY,GAAG,MAAM,KAAKzC,kBAAL,CAAwBqC,YAAxB,CAA3B;;AAEA,UAAI,KAAKJ,OAAT,EAAkB;AAChB,YAAI,CAACV,QAAQ,CAACjC,IAAT,CAAcmD,YAAd,CAAL,EAAkC;AAChC,eAAKR,OAAL,GAAe,KAAf;AACA,eAAKrG,MAAL,CAAYoG,KAAZ;AACD;AACF,OALD,MAKO;AACL,aAAKE,cAAL,CAAoB5C,IAApB,CAAyBmD,YAAzB;AACD;AACF,KAXD,CAWE,OAAOzB,KAAP,EAAc;AACd;AACA,WAAKuB,gBAAL,CAAsBpE,MAAtB,GAA+B,CAA/B;;AAEA,UACE,EACE,UAAU6C,KAAV,IACA,OAAOA,KAAK,CAAC9F,IAAb,KAAsB,QADtB,IAEAkG,MAAM,CAACC,SAAP,CAAiBL,KAAK,CAAC9F,IAAvB,CAFA,IAGA8F,KAAK,CAAC9F,IAAN,IAAc7D,mBAAOkE,EAHrB,IAIAyF,KAAK,CAAC9F,IAAN,IAAc7D,mBAAOqL,eALvB,CADF,EAQE;AACA;AACA1B,aAAK,CAAC9F,IAAN,GAAa7D,mBAAO8D,QAApB;AACD;;AAEDoG,cAAQ,CAACnG,IAAT,CAAc,OAAd,EAAuB4F,KAAvB;AACD;;AAED,SAAKsB,aAAL,GAAqB,KAArB;;AAEA,QAAI,KAAKC,gBAAL,CAAsBpE,MAAtB,GAA+B,CAAnC,EAAsC;AACpC,WAAKqE,WAAL,CACEjB,QADF,EAEE,KAAKgB,gBAAL,CAAsBH,KAAtB,EAFF;AAID;AACF;;AAEDhJ,SAAO;AACL,UAAMuJ,MAAM,GAAG,KAAK/G,MAAL,CAAYgH,OAAZ,CAAoBD,MAAnC;;AACA,QAAIA,MAAM,CAACE,aAAX,EAA0B;AACxB,UAAIF,MAAM,CAACG,UAAX,EAAuB;AACrB,eAAO,GAAGH,MAAM,CAACE,aAAa,IAAIF,MAAM,CAACG,UAAU,EAAnD;AACD,OAFD,MAEO;AACL,eAAOH,MAAM,CAACE,aAAd;AACD;AACF,KAND,MAMO;AACL,aAAO,SAAP;AACD;AACF;;AAEDtJ,aAAW;AACT,WAAO,KAAKoF,QAAZ;AACD;;AA1gBmB;;AAHtBnF;;AAmhBA,SAASsF,qBAAT,CAA+B/F,IAA/B,EAAsD;AACpD,QAAMyB,GAAG,GAAG,IAAI8D,KAAJ,CAAU,mBAAV,CAAZ;AACA9D,KAAG,CAACU,IAAJ,GAAW7D,mBAAO0L,iBAAlB;AAEAhK,MAAI,CAAC0B,SAAL,CAAeD,GAAf;AACAzB,MAAI,CAACG,SAAL,GAAiB,IAAjB;AACAH,MAAI,CAACqC,IAAL,CAAU,WAAV,EAAuB,UAAvB;AACD","names":["TRACER_NAME","trace","text","logging","constants_1","DEBUG","GRPC_ACCEPT_ENCODING_HEADER","GRPC_ENCODING_HEADER","GRPC_MESSAGE_HEADER","GRPC_STATUS_HEADER","GRPC_TIMEOUT_HEADER","DEADLINE_REGEX","deadlineUnitsToMs","H","M","S","m","u","n","defaultResponseHeaders","http2","constants","HTTP2_HEADER_STATUS","HTTP_STATUS_OK","HTTP2_HEADER_CONTENT_TYPE","defaultResponseOptions","waitForTrailers","ServerUnaryCallImpl","events_1","constructor","call","metadata","request","cancelled","setupSurfaceCall","getPeer","sendMetadata","responseMetadata","getDeadline","exports","ServerReadableStreamImpl","stream_1","deserialize","encoding","objectMode","setupReadable","_read","size","consumeUnpushedMessages","resume","ServerWritableStreamImpl","serialize","trailingMetadata","metadata_1","on","err","sendError","end","_write","chunk","callback","response","serializeMessage","write","once","code","INTERNAL","emit","_final","sendStatus","OK","details","ServerDuplexStreamImpl","prototype","Http2ServerCallStream","stream","handler","options","setTimeout","Infinity","_a","path","rstCode","CANCELLED","maxSendMessageSize","maxReceiveMessageSize","clearTimeout","deadlineTimer","checkCancelled","destroyed","closed","getDecompressedMessage","message","Promise","resolve","reject","zlib","inflate","slice","output","unzip","UNIMPLEMENTED","customMetadata","metadataSent","custom","toHttp2Headers","headers","Object","assign","respond","receiveMetadata","fromHttp2Headers","timeoutHeader","get","length","match","toString","Error","OUT_OF_RANGE","timeout","now","Date","deadline","setMilliseconds","getMilliseconds","handleExpiredDeadline","remove","HTTP2_HEADER_ACCEPT_ENCODING","HTTP2_HEADER_TE","receiveUnaryMessage","chunks","totalLength","data","push","byteLength","requestBytes","Buffer","concat","RESOURCE_EXHAUSTED","compressed","readUInt8","compressedMessageEncoding","decompressedMessage","deserializeMessage","value","messageBuffer","allocUnsafe","writeUInt8","writeUInt32BE","copy","bytes","sendUnaryMessage","flags","hasOwnProperty","statusObj","wantTrailers","trailersToSend","encodeURI","sendTrailers","error","status","UNKNOWN","undefined","Number","isInteger","reason","readable","decoder","stream_decoder_1","readsDone","pendingMessageProcessing","pushedEnd","maybePushEnd","pushOrBufferMessage","messages","pause","canPush","messagesToPush","nextMessage","shift","messageBytes","isPushPending","bufferedMessages","pushMessage","deserialized","UNAUTHENTICATED","socket","session","remoteAddress","remotePort","DEADLINE_EXCEEDED"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/server-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { EventEmitter } from 'events';\nimport * as http2 from 'http2';\nimport { Duplex, Readable, Writable } from 'stream';\nimport * as zlib from 'zlib';\n\nimport { Deadline, StatusObject } from './call-stream';\nimport {\n  Status,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n  LogVerbosity,\n} from './constants';\nimport { Deserialize, Serialize } from './make-client';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport { ObjectReadable, ObjectWritable } from './object-stream';\nimport { ChannelOptions } from './channel-options';\nimport * as logging from './logging';\n\nconst TRACER_NAME = 'server_call';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface DeadlineUnitIndexSignature {\n  [name: string]: number;\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs: DeadlineUnitIndexSignature = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001,\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true,\n} as http2.ServerStreamResponseOptions;\n\nexport type ServerStatusResponse = Partial<StatusObject>;\n\nexport type ServerErrorResponse = ServerStatusResponse & Error;\n\nexport type ServerSurfaceCall = {\n  cancelled: boolean;\n  readonly metadata: Metadata;\n  getPeer(): string;\n  sendMetadata(responseMetadata: Metadata): void;\n  getDeadline(): Deadline;\n} & EventEmitter;\n\nexport type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & {\n  request: RequestType;\n};\nexport type ServerReadableStream<\n  RequestType,\n  ResponseType\n> = ServerSurfaceCall & ObjectReadable<RequestType>;\nexport type ServerWritableStream<\n  RequestType,\n  ResponseType\n> = ServerSurfaceCall &\n  ObjectWritable<ResponseType> & {\n    request: RequestType;\n    end: (metadata?: Metadata) => void;\n  };\nexport type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall &\n  ObjectReadable<RequestType> &\n  ObjectWritable<ResponseType> & { end: (metadata?: Metadata) => void };\n\nexport class ServerUnaryCallImpl<RequestType, ResponseType>\n  extends EventEmitter\n  implements ServerUnaryCall<RequestType, ResponseType> {\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public request: RequestType\n  ) {\n    super();\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n}\n\nexport class ServerReadableStreamImpl<RequestType, ResponseType>\n  extends Readable\n  implements ServerReadableStream<RequestType, ResponseType> {\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n\n  _read(size: number) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n}\n\nexport class ServerWritableStreamImpl<RequestType, ResponseType>\n  extends Writable\n  implements ServerWritableStream<RequestType, ResponseType> {\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public request: RequestType\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  _write(\n    chunk: ResponseType,\n    encoding: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (...args: any[]) => void\n  ) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = Status.INTERNAL;\n      this.emit('error', err);\n    }\n\n    callback();\n  }\n\n  _final(callback: Function): void {\n    this.call.sendStatus({\n      code: Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata,\n    });\n    callback(null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nexport class ServerDuplexStreamImpl<RequestType, ResponseType>\n  extends Duplex\n  implements ServerDuplexStream<RequestType, ResponseType> {\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nServerDuplexStreamImpl.prototype._read =\n  ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n  ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n  ServerWritableStreamImpl.prototype._final;\n\n// Unary response callback signature.\nexport type sendUnaryData<ResponseType> = (\n  error: ServerErrorResponse | ServerStatusResponse | null,\n  value?: ResponseType | null,\n  trailer?: Metadata,\n  flags?: number\n) => void;\n\n// User provided handler for unary calls.\nexport type handleUnaryCall<RequestType, ResponseType> = (\n  call: ServerUnaryCall<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for client streaming calls.\nexport type handleClientStreamingCall<RequestType, ResponseType> = (\n  call: ServerReadableStream<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for server streaming calls.\nexport type handleServerStreamingCall<RequestType, ResponseType> = (\n  call: ServerWritableStream<RequestType, ResponseType>\n) => void;\n\n// User provided handler for bidirectional streaming calls.\nexport type handleBidiStreamingCall<RequestType, ResponseType> = (\n  call: ServerDuplexStream<RequestType, ResponseType>\n) => void;\n\nexport type HandleCall<RequestType, ResponseType> =\n  | handleUnaryCall<RequestType, ResponseType>\n  | handleClientStreamingCall<RequestType, ResponseType>\n  | handleServerStreamingCall<RequestType, ResponseType>\n  | handleBidiStreamingCall<RequestType, ResponseType>;\n\nexport interface UnaryHandler<RequestType, ResponseType> {\n  func: handleUnaryCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ClientStreamingHandler<RequestType, ResponseType> {\n  func: handleClientStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ServerStreamingHandler<RequestType, ResponseType> {\n  func: handleServerStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface BidiStreamingHandler<RequestType, ResponseType> {\n  func: handleBidiStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport type Handler<RequestType, ResponseType> =\n  | UnaryHandler<RequestType, ResponseType>\n  | ClientStreamingHandler<RequestType, ResponseType>\n  | ServerStreamingHandler<RequestType, ResponseType>\n  | BidiStreamingHandler<RequestType, ResponseType>;\n\nexport type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';\n\n// Internal class that wraps the HTTP2 request.\nexport class Http2ServerCallStream<\n  RequestType,\n  ResponseType\n> extends EventEmitter {\n  cancelled = false;\n  deadlineTimer: NodeJS.Timer = setTimeout(() => {}, 0);\n  private deadline: Deadline = Infinity;\n  private wantTrailers = false;\n  private metadataSent = false;\n  private canPush = false;\n  private isPushPending = false;\n  private bufferedMessages: Array<Buffer | null> = [];\n  private messagesToPush: Array<RequestType | null> = [];\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n  constructor(\n    private stream: http2.ServerHttp2Stream,\n    private handler: Handler<RequestType, ResponseType>,\n    private options: ChannelOptions\n  ) {\n    super();\n\n    this.stream.once('error', (err: ServerErrorResponse) => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n\n    this.stream.once('close', () => {\n      trace(\n        'Request to method ' +\n          this.handler?.path +\n          ' stream closed with rstCode ' +\n          this.stream.rstCode\n      );\n      this.cancelled = true;\n      this.emit('cancelled', 'cancelled');\n      this.emit('streamEnd', false);\n      this.sendStatus({code: Status.CANCELLED, details: 'Cancelled by client', metadata: new Metadata()});\n    });\n\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n\n    // Clear noop timer\n    clearTimeout(this.deadlineTimer);\n  }\n\n  private checkCancelled(): boolean {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n\n  private getDecompressedMessage(message: Buffer, encoding: string) {\n    switch (encoding) {\n      case 'deflate': {\n        return new Promise<Buffer | undefined>((resolve, reject) => {\n          zlib.inflate(message.slice(5), (err, output) => {\n            if (err) {\n              this.sendError({\n                code: Status.INTERNAL,\n                details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n              });\n              resolve();\n            } else {\n              resolve(output);\n            }\n          });\n        });\n      }\n  \n      case 'gzip': {\n        return new Promise<Buffer | undefined>((resolve, reject) => {\n          zlib.unzip(message.slice(5), (err, output) => {\n            if (err) {\n              this.sendError({\n                code: Status.INTERNAL,\n                details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n              });\n              resolve();\n            } else {\n              resolve(output);\n            }\n          });\n        });\n      }\n\n      case 'identity': {\n        return Promise.resolve(message.slice(5));\n      }\n  \n      default: {\n        this.sendError({\n          code: Status.UNIMPLEMENTED,\n          details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n        });\n        return Promise.resolve();\n      }\n    }\n  }\n\n  sendMetadata(customMetadata?: Metadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = Object.assign({}, defaultResponseHeaders, custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers: http2.IncomingHttpHeaders) {\n    const metadata = Metadata.fromHttp2Headers(headers);\n\n    // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline') as ServerErrorResponse;\n        err.code = Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n\n      const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n\n    return metadata;\n  }\n\n  receiveUnaryMessage(encoding: string): Promise<RequestType> {\n    return new Promise((resolve, reject) => {\n      const stream = this.stream;\n      const chunks: Buffer[] = [];\n      let totalLength = 0;\n\n      stream.on('data', (data: Buffer) => {\n        chunks.push(data);\n        totalLength += data.byteLength;\n      });\n\n      stream.once('end', async () => {\n        try {\n          const requestBytes = Buffer.concat(chunks, totalLength);\n          if (\n            this.maxReceiveMessageSize !== -1 &&\n            requestBytes.length > this.maxReceiveMessageSize\n          ) {\n            this.sendError({\n              code: Status.RESOURCE_EXHAUSTED,\n              details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`,\n            });\n            resolve();\n          }\n\n          this.emit('receiveMessage');\n\n          const compressed = requestBytes.readUInt8(0) === 1;\n          const compressedMessageEncoding = compressed ? encoding : 'identity';\n          const decompressedMessage = await this.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n\n          // Encountered an error with decompression; it'll already have been propogated back\n          // Just return early\n          if (!decompressedMessage) {\n            resolve();\n          }\n          else {\n            resolve(this.deserializeMessage(decompressedMessage));\n          }\n        } catch (err) {\n          err.code = Status.INTERNAL;\n          this.sendError(err);\n          resolve();\n        }\n      });\n    });\n  }\n\n  serializeMessage(value: ResponseType) {\n    const messageBuffer = this.handler.serialize(value);\n\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes: Buffer) {\n    return this.handler.deserialize(bytes);\n  }\n\n  async sendUnaryMessage(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    metadata?: Metadata,\n    flags?: number\n  ) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (!metadata) {\n      metadata = new Metadata();\n    }\n\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata')) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n\n    try {\n      const response = this.serializeMessage(value!);\n\n      this.write(response);\n      this.sendStatus({ code: Status.OK, details: 'OK', metadata });\n    } catch (err) {\n      err.code = Status.INTERNAL;\n      this.sendError(err);\n    }\n  }\n\n  sendStatus(statusObj: StatusObject) {\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace(\n      'Request to method ' +\n        this.handler?.path +\n        ' ended with status code: ' +\n        Status[statusObj.code] +\n        ' details: ' +\n        statusObj.details\n    );\n\n    clearTimeout(this.deadlineTimer);\n\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        const trailersToSend = Object.assign(\n          {\n            [GRPC_STATUS_HEADER]: statusObj.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details as string),\n          },\n          statusObj.metadata.toHttp2Headers()\n        );\n\n        this.stream.sendTrailers(trailersToSend);\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n\n  sendError(error: ServerErrorResponse | ServerStatusResponse) {\n    const status: StatusObject = {\n      code: Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata:\n        'metadata' in error && error.metadata !== undefined\n          ? error.metadata\n          : new Metadata(),\n    };\n\n    if (\n      'code' in error &&\n      typeof error.code === 'number' &&\n      Number.isInteger(error.code)\n    ) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details!;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk: Buffer) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (\n      this.maxSendMessageSize !== -1 &&\n      chunk.length > this.maxSendMessageSize\n    ) {\n      this.sendError({\n        code: Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call: ServerSurfaceCall) {\n    this.once('cancelled', (reason) => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n  }\n\n  setupReadable(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    encoding: string\n  ) {\n    const decoder = new StreamDecoder();\n\n    let readsDone = false;\n\n    let pendingMessageProcessing = false;\n\n    let pushedEnd = false;\n\n    const maybePushEnd = () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        this.pushOrBufferMessage(readable, null);\n      }\n    }\n\n    this.stream.on('data', async (data: Buffer) => {\n      const messages = decoder.write(data);\n\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        if (\n          this.maxReceiveMessageSize !== -1 &&\n          message.length > this.maxReceiveMessageSize\n        ) {\n          this.sendError({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n          });\n          return;\n        }\n        this.emit('receiveMessage');\n\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n         \n        this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      maybePushEnd();\n    });\n\n    this.stream.once('end', () => {\n      readsDone = true;\n      maybePushEnd();\n    });\n  }\n\n  consumeUnpushedMessages(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>\n  ): boolean {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  private pushOrBufferMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ): void {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  private async pushMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n\n      return;\n    }\n\n    trace('Received message of length ' + messageBytes.length);\n\n    this.isPushPending = true;\n\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n\n      if (\n        !(\n          'code' in error &&\n          typeof error.code === 'number' &&\n          Number.isInteger(error.code) &&\n          error.code >= Status.OK &&\n          error.code <= Status.UNAUTHENTICATED\n        )\n      ) {\n        // The error code is not a valid gRPC code so its being overwritten.\n        error.code = Status.INTERNAL;\n      }\n\n      readable.emit('error', error);\n    }\n\n    this.isPushPending = false;\n\n    if (this.bufferedMessages.length > 0) {\n      this.pushMessage(\n        readable,\n        this.bufferedMessages.shift() as Buffer | null\n      );\n    }\n  }\n\n  getPeer(): string {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline(): Deadline {\n    return this.deadline;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedServerCall = Http2ServerCallStream<any, any>;\n\nfunction handleExpiredDeadline(call: UntypedServerCall) {\n  const err = new Error('Deadline exceeded') as ServerErrorResponse;\n  err.code = Status.DEADLINE_EXCEEDED;\n\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}\n"]},"metadata":{},"sourceType":"script"}