{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamDecoder = void 0;\nvar ReadState;\n\n(function (ReadState) {\n  ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n  ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n  ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\n\nclass StreamDecoder {\n  constructor() {\n    this.readState = ReadState.NO_DATA;\n    this.readCompressFlag = Buffer.alloc(1);\n    this.readPartialSize = Buffer.alloc(4);\n    this.readSizeRemaining = 4;\n    this.readMessageSize = 0;\n    this.readPartialMessage = [];\n    this.readMessageRemaining = 0;\n  }\n\n  write(data) {\n    let readHead = 0;\n    let toRead;\n    const result = [];\n\n    while (readHead < data.length) {\n      switch (this.readState) {\n        case ReadState.NO_DATA:\n          this.readCompressFlag = data.slice(readHead, readHead + 1);\n          readHead += 1;\n          this.readState = ReadState.READING_SIZE;\n          this.readPartialSize.fill(0);\n          this.readSizeRemaining = 4;\n          this.readMessageSize = 0;\n          this.readMessageRemaining = 0;\n          this.readPartialMessage = [];\n          break;\n\n        case ReadState.READING_SIZE:\n          toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n          data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n          this.readSizeRemaining -= toRead;\n          readHead += toRead; // readSizeRemaining >=0 here\n\n          if (this.readSizeRemaining === 0) {\n            this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n            this.readMessageRemaining = this.readMessageSize;\n\n            if (this.readMessageRemaining > 0) {\n              this.readState = ReadState.READING_MESSAGE;\n            } else {\n              const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n              this.readState = ReadState.NO_DATA;\n              result.push(message);\n            }\n          }\n\n          break;\n\n        case ReadState.READING_MESSAGE:\n          toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n          this.readMessageRemaining -= toRead;\n          readHead += toRead; // readMessageRemaining >=0 here\n\n          if (this.readMessageRemaining === 0) {\n            // At this point, we have read a full message\n            const framedMessageBuffers = [this.readCompressFlag, this.readPartialSize].concat(this.readPartialMessage);\n            const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n            this.readState = ReadState.NO_DATA;\n            result.push(framedMessage);\n          }\n\n          break;\n\n        default:\n          throw new Error('Unexpected read state');\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.StreamDecoder = StreamDecoder;","map":{"version":3,"mappings":"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","names":["ReadState","StreamDecoder","constructor","NO_DATA","Buffer","alloc","write","data","readHead","toRead","result","length","readState","readCompressFlag","slice","READING_SIZE","readPartialSize","fill","readSizeRemaining","readMessageSize","readMessageRemaining","readPartialMessage","Math","min","copy","readUInt32BE","READING_MESSAGE","message","concat","push","framedMessageBuffers","framedMessage","Error","exports"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/stream-decoder.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nenum ReadState {\n  NO_DATA,\n  READING_SIZE,\n  READING_MESSAGE,\n}\n\nexport class StreamDecoder {\n  private readState: ReadState = ReadState.NO_DATA;\n  private readCompressFlag: Buffer = Buffer.alloc(1);\n  private readPartialSize: Buffer = Buffer.alloc(4);\n  private readSizeRemaining = 4;\n  private readMessageSize = 0;\n  private readPartialMessage: Buffer[] = [];\n  private readMessageRemaining = 0;\n\n  write(data: Buffer): Buffer[] {\n    let readHead = 0;\n    let toRead: number;\n    const result: Buffer[] = [];\n\n    while (readHead < data.length) {\n      switch (this.readState) {\n        case ReadState.NO_DATA:\n          this.readCompressFlag = data.slice(readHead, readHead + 1);\n          readHead += 1;\n          this.readState = ReadState.READING_SIZE;\n          this.readPartialSize.fill(0);\n          this.readSizeRemaining = 4;\n          this.readMessageSize = 0;\n          this.readMessageRemaining = 0;\n          this.readPartialMessage = [];\n          break;\n        case ReadState.READING_SIZE:\n          toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n          data.copy(\n            this.readPartialSize,\n            4 - this.readSizeRemaining,\n            readHead,\n            readHead + toRead\n          );\n          this.readSizeRemaining -= toRead;\n          readHead += toRead;\n          // readSizeRemaining >=0 here\n          if (this.readSizeRemaining === 0) {\n            this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n            this.readMessageRemaining = this.readMessageSize;\n            if (this.readMessageRemaining > 0) {\n              this.readState = ReadState.READING_MESSAGE;\n            } else {\n              const message = Buffer.concat(\n                [this.readCompressFlag, this.readPartialSize],\n                5\n              );\n\n              this.readState = ReadState.NO_DATA;\n              result.push(message);\n            }\n          }\n          break;\n        case ReadState.READING_MESSAGE:\n          toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n          this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n          this.readMessageRemaining -= toRead;\n          readHead += toRead;\n          // readMessageRemaining >=0 here\n          if (this.readMessageRemaining === 0) {\n            // At this point, we have read a full message\n            const framedMessageBuffers = [\n              this.readCompressFlag,\n              this.readPartialSize,\n            ].concat(this.readPartialMessage);\n            const framedMessage = Buffer.concat(\n              framedMessageBuffers,\n              this.readMessageSize + 5\n            );\n\n            this.readState = ReadState.NO_DATA;\n            result.push(framedMessage);\n          }\n          break;\n        default:\n          throw new Error('Unexpected read state');\n      }\n    }\n\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}