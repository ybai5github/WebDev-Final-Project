{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst Protobuf = require(\"protobufjs\");\n\nconst descriptor = require(\"protobufjs/ext/descriptor\");\n\nconst camelCase = require(\"lodash.camelcase\");\n\nconst descriptorOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  defaults: true,\n  oneofs: true,\n  json: true\n};\n\nfunction joinName(baseName, name) {\n  if (baseName === '') {\n    return name;\n  } else {\n    return baseName + '.' + name;\n  }\n}\n\nfunction isHandledReflectionObject(obj) {\n  return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\n\nfunction isNamespaceBase(obj) {\n  return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\n\nfunction getAllHandledReflectionObjects(obj, parentName) {\n  const objName = joinName(parentName, obj.name);\n\n  if (isHandledReflectionObject(obj)) {\n    return [[objName, obj]];\n  } else {\n    if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n      return Object.keys(obj.nested).map(name => {\n        return getAllHandledReflectionObjects(obj.nested[name], objName);\n      }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n    }\n  }\n\n  return [];\n}\n\nfunction createDeserializer(cls, options) {\n  return function deserialize(argBuf) {\n    return cls.toObject(cls.decode(argBuf), options);\n  };\n}\n\nfunction createSerializer(cls) {\n  return function serialize(arg) {\n    const message = cls.fromObject(arg);\n    return cls.encode(message).finish();\n  };\n}\n\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n  /* This is only ever called after the corresponding root.resolveAll(), so we\n   * can assume that the resolved request and response types are non-null */\n  const requestType = method.resolvedRequestType;\n  const responseType = method.resolvedResponseType;\n  return {\n    path: '/' + serviceName + '/' + method.name,\n    requestStream: !!method.requestStream,\n    responseStream: !!method.responseStream,\n    requestSerialize: createSerializer(requestType),\n    requestDeserialize: createDeserializer(requestType, options),\n    responseSerialize: createSerializer(responseType),\n    responseDeserialize: createDeserializer(responseType, options),\n    // TODO(murgatroid99): Find a better way to handle this\n    originalName: camelCase(method.name),\n    requestType: createMessageDefinition(requestType, fileDescriptors),\n    responseType: createMessageDefinition(responseType, fileDescriptors)\n  };\n}\n\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n  const def = {};\n\n  for (const method of service.methodsArray) {\n    def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n  }\n\n  return def;\n}\n\nfunction createMessageDefinition(message, fileDescriptors) {\n  const messageDescriptor = message.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 DescriptorProto',\n    type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\n\nfunction createEnumDefinition(enumType, fileDescriptors) {\n  const enumDescriptor = enumType.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 EnumDescriptorProto',\n    type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\n\n\nfunction createDefinition(obj, name, options, fileDescriptors) {\n  if (obj instanceof Protobuf.Service) {\n    return createServiceDefinition(obj, name, options, fileDescriptors);\n  } else if (obj instanceof Protobuf.Type) {\n    return createMessageDefinition(obj, fileDescriptors);\n  } else if (obj instanceof Protobuf.Enum) {\n    return createEnumDefinition(obj, fileDescriptors);\n  } else {\n    throw new Error('Type mismatch in reflection object handling');\n  }\n}\n\nfunction createPackageDefinition(root, options) {\n  const def = {};\n  root.resolveAll();\n  const descriptorList = root.toDescriptor('proto3').file;\n  const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n\n  for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n    def[name] = createDefinition(obj, name, options, bufferList);\n  }\n\n  return def;\n}\n\nfunction addIncludePathResolver(root, includePaths) {\n  const originalResolvePath = root.resolvePath;\n\n  root.resolvePath = (origin, target) => {\n    if (path.isAbsolute(target)) {\n      return target;\n    }\n\n    for (const directory of includePaths) {\n      const fullPath = path.join(directory, target);\n\n      try {\n        fs.accessSync(fullPath, fs.constants.R_OK);\n        return fullPath;\n      } catch (err) {\n        continue;\n      }\n    }\n\n    process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n    return originalResolvePath(origin, target);\n  };\n}\n\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n  options = options || {};\n  const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n  root.resolveAll();\n  return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\n\n\nfunction load(filename, options) {\n  const root = new Protobuf.Root();\n  options = options || {};\n\n  if (!!options.includeDirs) {\n    if (!Array.isArray(options.includeDirs)) {\n      return Promise.reject(new Error('The includeDirs option must be an array'));\n    }\n\n    addIncludePathResolver(root, options.includeDirs);\n  }\n\n  return root.load(filename, options).then(loadedRoot => {\n    loadedRoot.resolveAll();\n    return createPackageDefinition(root, options);\n  });\n}\n\nexports.load = load;\n\nfunction loadSync(filename, options) {\n  const root = new Protobuf.Root();\n  options = options || {};\n\n  if (!!options.includeDirs) {\n    if (!Array.isArray(options.includeDirs)) {\n      throw new Error('The includeDirs option must be an array');\n    }\n\n    addIncludePathResolver(root, options.includeDirs);\n  }\n\n  const loadedRoot = root.loadSync(filename, options);\n  loadedRoot.resolveAll();\n  return createPackageDefinition(root, options);\n}\n\nexports.loadSync = loadSync;\n\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\n\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\n\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\n\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject; // Load Google's well-known proto files that aren't exposed by Protobuf.js.\n// Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n// and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n// Using constant strings for compatibility with tools like Webpack\n\nconst apiDescriptor = require('protobufjs/google/protobuf/api.json');\n\nconst descriptorDescriptor = require('protobufjs/google/protobuf/descriptor.json');\n\nconst sourceContextDescriptor = require('protobufjs/google/protobuf/source_context.json');\n\nconst typeDescriptor = require('protobufjs/google/protobuf/type.json');\n\nProtobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);","map":{"version":3,"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/proto-loader/build/src/index.js"],"names":["Object","defineProperty","exports","value","fs","require","path","Protobuf","descriptor","camelCase","descriptorOptions","longs","String","enums","bytes","defaults","oneofs","json","joinName","baseName","name","isHandledReflectionObject","obj","Service","Type","Enum","isNamespaceBase","Namespace","Root","getAllHandledReflectionObjects","parentName","objName","nested","keys","map","reduce","accumulator","currentValue","concat","createDeserializer","cls","options","deserialize","argBuf","toObject","decode","createSerializer","serialize","arg","message","fromObject","encode","finish","createMethodDefinition","method","serviceName","fileDescriptors","requestType","resolvedRequestType","responseType","resolvedResponseType","requestStream","responseStream","requestSerialize","requestDeserialize","responseSerialize","responseDeserialize","originalName","createMessageDefinition","createServiceDefinition","service","def","methodsArray","messageDescriptor","toDescriptor","format","type","$type","fileDescriptorProtos","createEnumDefinition","enumType","enumDescriptor","createDefinition","Error","createPackageDefinition","root","resolveAll","descriptorList","file","bufferList","Buffer","from","FileDescriptorProto","addIncludePathResolver","includePaths","originalResolvePath","resolvePath","origin","target","isAbsolute","directory","fullPath","join","accessSync","constants","R_OK","err","process","emitWarning","createPackageDefinitionFromDescriptorSet","decodedDescriptorSet","fromDescriptor","load","filename","includeDirs","Array","isArray","Promise","reject","then","loadedRoot","loadSync","loadFileDescriptorSetFromBuffer","descriptorSet","FileDescriptorSet","loadFileDescriptorSetFromObject","apiDescriptor","descriptorDescriptor","sourceContextDescriptor","typeDescriptor","common","google","protobuf"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst Protobuf = require(\"protobufjs\");\nconst descriptor = require(\"protobufjs/ext/descriptor\");\nconst camelCase = require(\"lodash.camelcase\");\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    return root.load(filename, options).then(loadedRoot => {\n        loadedRoot.resolveAll();\n        return createPackageDefinition(root, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(root, options);\n}\nexports.loadSync = loadSync;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n// Load Google's well-known proto files that aren't exposed by Protobuf.js.\n// Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n// and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n// Using constant strings for compatibility with tools like Webpack\nconst apiDescriptor = require('protobufjs/google/protobuf/api.json');\nconst descriptorDescriptor = require('protobufjs/google/protobuf/descriptor.json');\nconst sourceContextDescriptor = require('protobufjs/google/protobuf/source_context.json');\nconst typeDescriptor = require('protobufjs/google/protobuf/type.json');\nProtobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}