{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\n\nconst metadata_1 = require(\"./metadata\");\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\n\n\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n\n}\n\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\n\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n\n}\n\nexports.ListenerBuilder = ListenerBuilder;\n\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n\n}\n\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\n\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\n\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\n\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n\n    this.nextCall = nextCall;\n    /**\n     * Indicates that metadata has been passed to the requester's start\n     * method but it has not been passed to the corresponding next callback\n     */\n\n    this.processingMetadata = false;\n    /**\n     * Message context for a pending message that is waiting for\n     */\n\n    this.pendingMessageContext = null;\n    /**\n     * Indicates that a message has been passed to the requester's sendMessage\n     * method but it has not been passed to the corresponding next callback\n     */\n\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n\n    this.pendingHalfClose = false;\n\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n\n      this.processingMetadata = false;\n      let finalInterceptingListener;\n\n      if (call_stream_1.isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n\n  startRead() {\n    this.nextCall.startRead();\n  }\n\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n\n  setCredentials(credentials) {\n    this.nextCall.setCredentials(credentials);\n  }\n\n}\n\nexports.InterceptingCall = InterceptingCall;\n\nfunction getCall(channel, path, options) {\n  var _a, _b;\n\n  const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n  const host = options.host;\n  const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\n\n\nclass BaseInterceptingCall {\n  constructor(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  setCredentials(credentials) {\n    this.call.setCredentials(credentials);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessageWithContext(context, message) {\n    let serialized;\n\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n      return;\n    }\n\n    this.call.sendMessageWithContext(context, serialized);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n        let deserialized;\n\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n\n  startRead() {\n    this.call.startRead();\n  }\n\n  halfClose() {\n    this.call.halfClose();\n  }\n\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\n\n\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n\n  start(metadata, listener) {\n    var _a, _b;\n\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: message => {\n        var _a;\n\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\n\n\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {}\n\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n\n  let interceptors = []; // Interceptors passed to the call override interceptors passed to the client constructor\n\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor); // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor); // Filter out falsy values when providers return nothing\n  }\n\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\n\nexports.getInterceptingCall = getInterceptingCall;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;AAiBA;;AACA;;AAaA;AAMA;;;;;;AAIA,MAAaA,6BAAb,SAAmDC,KAAnD,CAAwD;AACtDC,cAAYC,OAAZ,EAA2B;AACzB,UAAMA,OAAN;AACA,SAAKC,IAAL,GAAY,+BAAZ;AACAH,SAAK,CAACI,iBAAN,CAAwB,IAAxB,EAA8BL,6BAA9B;AACD;;AALqD;;AAAxDM;;AA4CA,MAAaC,eAAb,CAA4B;AAA5BL;AACU,oBAAyCM,SAAzC;AACA,mBAAuCA,SAAvC;AACA,kBAAqCA,SAArC;AAwBT;;AAtBCC,uBAAqB,CAACC,iBAAD,EAAoC;AACvD,SAAKC,QAAL,GAAgBD,iBAAhB;AACA,WAAO,IAAP;AACD;;AAEDE,sBAAoB,CAACC,gBAAD,EAAkC;AACpD,SAAKV,OAAL,GAAeU,gBAAf;AACA,WAAO,IAAP;AACD;;AAEDC,qBAAmB,CAACC,eAAD,EAAgC;AACjD,SAAKC,MAAL,GAAcD,eAAd;AACA,WAAO,IAAP;AACD;;AAEDE,OAAK;AACH,WAAO;AACLP,uBAAiB,EAAE,KAAKC,QADnB;AAELE,sBAAgB,EAAE,KAAKV,OAFlB;AAGLY,qBAAe,EAAE,KAAKC;AAHjB,KAAP;AAKD;;AA1ByB;;AAA5BV;;AA6BA,MAAaY,gBAAb,CAA6B;AAA7BhB;AACU,iBAAuCM,SAAvC;AACA,mBAAwCA,SAAxC;AACA,qBAAwCA,SAAxC;AACA,kBAAsCA,SAAtC;AA8BT;;AA5BCW,WAAS,CAACC,KAAD,EAAyB;AAChC,SAAKA,KAAL,GAAaA,KAAb;AACA,WAAO,IAAP;AACD;;AAEDC,iBAAe,CAACC,WAAD,EAA8B;AAC3C,SAAKnB,OAAL,GAAemB,WAAf;AACA,WAAO,IAAP;AACD;;AAEDC,eAAa,CAACC,SAAD,EAA0B;AACrC,SAAKA,SAAL,GAAiBA,SAAjB;AACA,WAAO,IAAP;AACD;;AAEDC,YAAU,CAACC,MAAD,EAAwB;AAChC,SAAKA,MAAL,GAAcA,MAAd;AACA,WAAO,IAAP;AACD;;AAEDT,OAAK;AACH,WAAO;AACLG,WAAK,EAAE,KAAKA,KADP;AAELE,iBAAW,EAAE,KAAKnB,OAFb;AAGLqB,eAAS,EAAE,KAAKA,SAHX;AAILE,YAAM,EAAE,KAAKA;AAJR,KAAP;AAMD;;AAjC0B;;AAA7BpB;AAoCA;;;;;AAIA,MAAMqB,eAAe,GAAiB;AACpCjB,mBAAiB,EAAE,CAACC,QAAD,EAAWiB,IAAX,KAAmB;AACpCA,QAAI,CAACjB,QAAD,CAAJ;AACD,GAHmC;AAIpCE,kBAAgB,EAAE,CAACV,OAAD,EAAUyB,IAAV,KAAkB;AAClCA,QAAI,CAACzB,OAAD,CAAJ;AACD,GANmC;AAOpCY,iBAAe,EAAE,CAACC,MAAD,EAASY,IAAT,KAAiB;AAChCA,QAAI,CAACZ,MAAD,CAAJ;AACD;AATmC,CAAtC;AAYA;;;;;AAIA,MAAMa,gBAAgB,GAAkB;AACtCT,OAAK,EAAE,CAACT,QAAD,EAAWmB,QAAX,EAAqBF,IAArB,KAA6B;AAClCA,QAAI,CAACjB,QAAD,EAAWmB,QAAX,CAAJ;AACD,GAHqC;AAItCR,aAAW,EAAE,CAACnB,OAAD,EAAUyB,IAAV,KAAkB;AAC7BA,QAAI,CAACzB,OAAD,CAAJ;AACD,GANqC;AAOtCqB,WAAS,EAAGI,IAAD,IAAS;AAClBA,QAAI;AACL,GATqC;AAUtCF,QAAM,EAAGE,IAAD,IAAS;AACfA,QAAI;AACL;AAZqC,CAAxC;;AAkCA,MAAaG,gBAAb,CAA6B;AAyB3B7B,cACU8B,QADV,EAEEC,SAFF,EAEuB;;;AADb;AArBV;;;;;AAIQ,8BAAqB,KAArB;AACR;;;;AAGQ,iCAA+C,IAA/C;AAER;;;;;AAIQ,6BAAoB,KAApB;AACR;;;;;AAIQ,4BAAmB,KAAnB;;AAKN,QAAIA,SAAJ,EAAe;AACb,WAAKA,SAAL,GAAiB;AACfb,aAAK,QAAEa,SAAS,CAACb,KAAZ,MAAiB,IAAjB,IAAiBc,aAAjB,GAAiBA,EAAjB,GAAqBL,gBAAgB,CAACT,KAD5B;AAEfE,mBAAW,QAAEW,SAAS,CAACX,WAAZ,MAAuB,IAAvB,IAAuBa,aAAvB,GAAuBA,EAAvB,GAA2BN,gBAAgB,CAACP,WAFxC;AAGfE,iBAAS,QAAES,SAAS,CAACT,SAAZ,MAAqB,IAArB,IAAqBY,aAArB,GAAqBA,EAArB,GAAyBP,gBAAgB,CAACL,SAHpC;AAIfE,cAAM,QAAEO,SAAS,CAACP,MAAZ,MAAkB,IAAlB,IAAkBW,aAAlB,GAAkBA,EAAlB,GAAsBR,gBAAgB,CAACH;AAJ9B,OAAjB;AAMD,KAPD,MAOO;AACL,WAAKO,SAAL,GAAiBJ,gBAAjB;AACD;AACF;;AAEDS,kBAAgB,CAACtB,MAAD,EAAiBuB,OAAjB,EAAgC;AAC9C,SAAKN,SAAL,CAAeP,MAAf,CAAsB,MAAK;AACzB,WAAKM,QAAL,CAAcM,gBAAd,CAA+BtB,MAA/B,EAAuCuB,OAAvC;AACD,KAFD;AAGD;;AAEDC,SAAO;AACL,WAAO,KAAKR,QAAL,CAAcQ,OAAd,EAAP;AACD;;AAEOC,uBAAqB;AAC3B,QAAI,KAAKC,qBAAT,EAAgC;AAC9B,WAAKV,QAAL,CAAcW,sBAAd,CAAqC,KAAKD,qBAA1C,EAAiE,KAAKE,cAAtE;AACA,WAAKF,qBAAL,GAA6B,IAA7B;AACA,WAAKE,cAAL,GAAsB,IAAtB;AACD;AACF;;AAEOC,yBAAuB;AAC7B,QAAI,KAAKC,gBAAT,EAA2B;AACzB,WAAKd,QAAL,CAAcR,SAAd;AACD;AACF;;AAEDJ,OAAK,CACHT,QADG,EAEHoC,oBAFG,EAEiD;;;AAEpD,UAAMC,wBAAwB,GAAyB;AACrDtC,uBAAiB,cACfqC,oBAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAErC,iBADP,MACwB,IADxB,IACwBwB,aADxB,GACwB,MADxB,GACwBA,GAAEe,IAAF,CAAOF,oBAAP,CADxB,MACmD,IADnD,IACmDZ,aADnD,GACmDA,EADnD,GAEbxB,QAAD,IAAa,CAAG,CAHkC;AAIrDE,sBAAgB,cACdkC,oBAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAElC,gBADR,MACwB,IADxB,IACwBuB,aADxB,GACwB,MADxB,GACwBA,GAAEa,IAAF,CAAOF,oBAAP,CADxB,MACmD,IADnD,IACmDV,aADnD,GACmDA,EADnD,GAEZlC,OAAD,IAAY,CAAG,CANmC;AAOrDY,qBAAe,cACbgC,oBAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAEhC,eADT,MACwB,IADxB,IACwBmC,aADxB,GACwB,MADxB,GACwBA,GAAED,IAAF,CAAOF,oBAAP,CADxB,MACmD,IADnD,IACmDI,aADnD,GACmDA,EADnD,GAEXnC,MAAD,IAAW,CAAG;AAToC,KAAvD;AAWA,SAAKoC,kBAAL,GAA0B,IAA1B;AACA,SAAKnB,SAAL,CAAeb,KAAf,CAAqBT,QAArB,EAA+BqC,wBAA/B,EAAyD,CAACK,EAAD,EAAKvB,QAAL,KAAiB;;;AACxE,WAAKsB,kBAAL,GAA0B,KAA1B;AACA,UAAIE,yBAAJ;;AACA,UAAIC,qCAAuBzB,QAAvB,CAAJ,EAAsC;AACpCwB,iCAAyB,GAAGxB,QAA5B;AACD,OAFD,MAEO;AACL,cAAM0B,YAAY,GAAiB;AACjC9C,2BAAiB,QACfoB,QAAQ,CAACpB,iBADM,MACW,IADX,IACWwB,aADX,GACWA,EADX,GACeP,eAAe,CAACjB,iBAFf;AAGjCG,0BAAgB,QACdiB,QAAQ,CAACjB,gBADK,MACW,IADX,IACWsB,aADX,GACWA,EADX,GACeR,eAAe,CAACd,gBAJd;AAKjCE,yBAAe,QACbe,QAAQ,CAACf,eADI,MACW,IADX,IACWqB,aADX,GACWA,EADX,GACeT,eAAe,CAACZ;AANb,SAAnC;AAQAuC,iCAAyB,GAAG,IAAIC,sCAAJ,CAC1BC,YAD0B,EAE1BR,wBAF0B,CAA5B;AAID;;AACD,WAAKhB,QAAL,CAAcZ,KAAd,CAAoBiC,EAApB,EAAwBC,yBAAxB;AACA,WAAKb,qBAAL;AACA,WAAKI,uBAAL;AACD,KAtBD;AAuBD,GAxG0B,CAyG3B;;;AACAF,wBAAsB,CAACc,OAAD,EAA0BtD,OAA1B,EAAsC;AAC1D,SAAKuD,iBAAL,GAAyB,IAAzB;AACA,SAAKzB,SAAL,CAAeX,WAAf,CAA2BnB,OAA3B,EAAqCwD,YAAD,IAAiB;AACnD,WAAKD,iBAAL,GAAyB,KAAzB;;AACA,UAAI,KAAKN,kBAAT,EAA6B;AAC3B,aAAKV,qBAAL,GAA6Be,OAA7B;AACA,aAAKb,cAAL,GAAsBzC,OAAtB;AACD,OAHD,MAGO;AACL,aAAK6B,QAAL,CAAcW,sBAAd,CAAqCc,OAArC,EAA8CE,YAA9C;AACA,aAAKd,uBAAL;AACD;AACF,KATD;AAUD,GAtH0B,CAuH3B;;;AACAvB,aAAW,CAACnB,OAAD,EAAa;AACtB,SAAKwC,sBAAL,CAA4B,EAA5B,EAAgCxC,OAAhC;AACD;;AACDyD,WAAS;AACP,SAAK5B,QAAL,CAAc4B,SAAd;AACD;;AACDpC,WAAS;AACP,SAAKS,SAAL,CAAeT,SAAf,CAAyB,MAAK;AAC5B,UAAI,KAAK4B,kBAAL,IAA2B,KAAKM,iBAApC,EAAuD;AACrD,aAAKZ,gBAAL,GAAwB,IAAxB;AACD,OAFD,MAEO;AACL,aAAKd,QAAL,CAAcR,SAAd;AACD;AACF,KAND;AAOD;;AACDqC,gBAAc,CAACC,WAAD,EAA6B;AACzC,SAAK9B,QAAL,CAAc6B,cAAd,CAA6BC,WAA7B;AACD;;AAzI0B;;AAA7BxD;;AA4IA,SAASyD,OAAT,CAAiBC,OAAjB,EAAmCC,IAAnC,EAAiDC,OAAjD,EAAqE;;;AACnE,QAAMC,QAAQ,SAAGD,OAAO,CAACC,QAAX,MAAmB,IAAnB,IAAmBjC,aAAnB,GAAmBA,EAAnB,GAAuBkC,QAArC;AACA,QAAMC,IAAI,GAAGH,OAAO,CAACG,IAArB;AACA,QAAMC,MAAM,SAAGJ,OAAO,CAACI,MAAX,MAAiB,IAAjB,IAAiBnC,aAAjB,GAAiBA,EAAjB,GAAqB,IAAjC;AACA,QAAMoC,cAAc,GAAGL,OAAO,CAACM,eAA/B;AACA,QAAMV,WAAW,GAAGI,OAAO,CAACJ,WAA5B;AACA,QAAMW,IAAI,GAAGT,OAAO,CAACU,UAAR,CAAmBT,IAAnB,EAAyBE,QAAzB,EAAmCE,IAAnC,EAAyCC,MAAzC,EAAiDC,cAAjD,CAAb;;AACA,MAAIT,WAAJ,EAAiB;AACfW,QAAI,CAACZ,cAAL,CAAoBC,WAApB;AACD;;AACD,SAAOW,IAAP;AACD;AAED;;;;;;AAIA,MAAME,oBAAN,CAA0B;AACxBzE,cACYuE,IADZ,EAEE;AACUG,kBAHZ,EAG8D;AAFlD;AAEA;AACR;;AACJtC,kBAAgB,CAACtB,MAAD,EAAiBuB,OAAjB,EAAgC;AAC9C,SAAKkC,IAAL,CAAUnC,gBAAV,CAA2BtB,MAA3B,EAAmCuB,OAAnC;AACD;;AACDC,SAAO;AACL,WAAO,KAAKiC,IAAL,CAAUjC,OAAV,EAAP;AACD;;AACDqB,gBAAc,CAACC,WAAD,EAA6B;AACzC,SAAKW,IAAL,CAAUZ,cAAV,CAAyBC,WAAzB;AACD,GAduB,CAexB;;;AACAnB,wBAAsB,CAACc,OAAD,EAA0BtD,OAA1B,EAAsC;AAC1D,QAAI0E,UAAJ;;AACA,QAAI;AACFA,gBAAU,GAAG,KAAKD,gBAAL,CAAsBE,gBAAtB,CAAuC3E,OAAvC,CAAb;AACD,KAFD,CAEE,OAAO4E,CAAP,EAAU;AACV,WAAKN,IAAL,CAAUnC,gBAAV,CACE0C,mBAAOC,QADT,EAEE,0CAA0CF,CAAC,CAAC5E,OAAO,EAFrD;AAIA;AACD;;AACD,SAAKsE,IAAL,CAAU9B,sBAAV,CAAiCc,OAAjC,EAA0CoB,UAA1C;AACD,GA5BuB,CA6BxB;;;AACAvD,aAAW,CAACnB,OAAD,EAAa;AACtB,SAAKwC,sBAAL,CAA4B,EAA5B,EAAgCxC,OAAhC;AACD;;AACDiB,OAAK,CACHT,QADG,EAEHoC,oBAFG,EAEiD;AAEpD,QAAImC,SAAS,GAAwB,IAArC;AACA,SAAKT,IAAL,CAAUrD,KAAV,CAAgBT,QAAhB,EAA0B;AACxBD,uBAAiB,EAAGC,QAAD,IAAa;;;AAC9B,kCAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAED,iBAAtB,MAAuC,IAAvC,IAAuCwB,aAAvC,GAAuC,MAAvC,GAAuCA,QAAvCa,oBAAuC,EAAGpC,QAAH,CAAvC;AACD,OAHuB;AAIxBE,sBAAgB,EAAGV,OAAD,IAAY;eAAA,CAC5B;;;AACA,YAAIgF,YAAJ;;AACA,YAAI;AACFA,sBAAY,GAAG,KAAKP,gBAAL,CAAsBQ,mBAAtB,CAA0CjF,OAA1C,CAAf;AACD,SAFD,CAEE,OAAO4E,CAAP,EAAU;AACVG,mBAAS,GAAG;AACVG,gBAAI,EAAEL,mBAAOC,QADH;AAEV1C,mBAAO,EAAE,mCAAmCwC,CAAC,CAAC5E,OAAO,EAF3C;AAGVQ,oBAAQ,EAAE,IAAI2E,mBAAJ;AAHA,WAAZ;AAKA,eAAKb,IAAL,CAAUnC,gBAAV,CAA2B4C,SAAS,CAACG,IAArC,EAA2CH,SAAS,CAAC3C,OAArD;AACA;AACD;;AACD,kCAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAE1B,gBAAtB,MAAsC,IAAtC,IAAsCqB,aAAtC,GAAsC,MAAtC,GAAsCA,QAAtCa,oBAAsC,EAAGoC,YAAH,CAAtC;AACD,OAnBuB;AAoBxBpE,qBAAe,EAAGC,MAAD,IAAW;;;AAC1B,YAAIkE,SAAJ,EAAe;AACb,oCAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAEnE,eAAtB,MAAqC,IAArC,IAAqCmB,aAArC,GAAqC,MAArC,GAAqCA,QAArCa,oBAAqC,EAAGmC,SAAH,CAArC;AACD,SAFD,MAEO;AACL,oCAAoB,SAApB,wBAAoB,WAApB,GAAoB,MAApB,uBAAoB,CAAEnE,eAAtB,MAAqC,IAArC,IAAqCoB,aAArC,GAAqC,MAArC,GAAqCA,QAArCY,oBAAqC,EAAG/B,MAAH,CAArC;AACD;AACF;AA1BuB,KAA1B;AA4BD;;AACD4C,WAAS;AACP,SAAKa,IAAL,CAAUb,SAAV;AACD;;AACDpC,WAAS;AACP,SAAKiD,IAAL,CAAUjD,SAAV;AACD;;AAxEuB;AA2E1B;;;;;;AAIA,MAAM+D,yBAAN,SACUZ,oBADV,CAC8B;AAE5B;AACAzE,cAAYuE,IAAZ,EAAwBG,gBAAxB,EAA0E;AACxE,UAAMH,IAAN,EAAYG,gBAAZ;AACD;;AACDxD,OAAK,CAACT,QAAD,EAAqBmB,QAArB,EAA6D;;;AAChE,QAAI0D,eAAe,GAAG,KAAtB;AACA,UAAMC,eAAe,GAAyB;AAC5C/E,uBAAiB,cACfoB,QAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAEpB,iBADK,MACY,IADZ,IACYwB,aADZ,GACY,MADZ,GACYA,GAAEe,IAAF,CAAOnB,QAAP,CADZ,MAC2B,IAD3B,IAC2BK,aAD3B,GAC2BA,EAD3B,GACkCxB,QAAD,IAAa,CAAG,CAFtB;AAG5C;AACAE,sBAAgB,EAAGV,OAAD,IAAiB;;;AACjCqF,uBAAe,GAAG,IAAlB;AACA,sBAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAE3E,gBAAV,MAA0B,IAA1B,IAA0BqB,aAA1B,GAA0B,MAA1B,GAA0BA,QAA1BJ,QAA0B,EAAG3B,OAAH,CAA1B;AACD,OAP2C;AAQ5CY,qBAAe,EAAGC,MAAD,IAAyB;;;AACxC,YAAI,CAACwE,eAAL,EAAsB;AACpB,wBAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAE3E,gBAAV,MAA0B,IAA1B,IAA0BqB,aAA1B,GAA0B,MAA1B,GAA0BA,QAA1BJ,QAA0B,EAAG,IAAH,CAA1B;AACD;;AACD,sBAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAEf,eAAV,MAAyB,IAAzB,IAAyBoB,aAAzB,GAAyB,MAAzB,GAAyBA,QAAzBL,QAAyB,EAAGd,MAAH,CAAzB;AACD;AAb2C,KAA9C;AAeA,UAAMI,KAAN,CAAYT,QAAZ,EAAsB8E,eAAtB;AACA,SAAKhB,IAAL,CAAUb,SAAV;AACD;;AAzB2B;AA4B9B;;;;;;AAIA,MAAM8B,6BAAN,SACUf,oBADV,CAC8B;;AAG9B,SAASgB,yBAAT,CACE3B,OADF,EAEEE,OAFF,EAGE;AACAU,gBAJF,EAIoD;AAElD,QAAMH,IAAI,GAAGV,OAAO,CAACC,OAAD,EAAUY,gBAAgB,CAACX,IAA3B,EAAiCC,OAAjC,CAApB;;AACA,MAAIU,gBAAgB,CAACgB,cAArB,EAAqC;AACnC,WAAO,IAAIF,6BAAJ,CAAkCjB,IAAlC,EAAwCG,gBAAxC,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAIW,yBAAJ,CAA8Bd,IAA9B,EAAoCG,gBAApC,CAAP;AACD;AACF;;AAsBD,SAAgBiB,mBAAhB,CACEC,eADF,EAEE;AACAlB,gBAHF,EAIEV,OAJF,EAKEF,OALF,EAKkB;AAEhB,MACE8B,eAAe,CAACC,kBAAhB,CAAmCC,MAAnC,GAA4C,CAA5C,IACAF,eAAe,CAACG,0BAAhB,CAA2CD,MAA3C,GAAoD,CAFtD,EAGE;AACA,UAAM,IAAIhG,6BAAJ,CACJ,wEACE,0DAFE,CAAN;AAID;;AACD,MACE8F,eAAe,CAACI,gBAAhB,CAAiCF,MAAjC,GAA0C,CAA1C,IACAF,eAAe,CAACK,wBAAhB,CAAyCH,MAAzC,GAAkD,CAFpD,EAGE;AACA,UAAM,IAAIhG,6BAAJ,CACJ,qEACE,wCAFE,CAAN;AAID;;AACD,MAAIoG,YAAY,GAAkB,EAAlC,CApBgB,CAqBhB;;AACA,MACEN,eAAe,CAACI,gBAAhB,CAAiCF,MAAjC,GAA0C,CAA1C,IACAF,eAAe,CAACK,wBAAhB,CAAyCH,MAAzC,GAAkD,CAFpD,EAGE;AACAI,gBAAY,GAAI,GACbC,MADa,CAEZP,eAAe,CAACI,gBAFJ,EAGZJ,eAAe,CAACK,wBAAhB,CAAyCG,GAAzC,CAA8CC,QAAD,IAC3CA,QAAQ,CAAC3B,gBAAD,CADV,CAHY,EAOb4B,MAPa,CAOLC,WAAD,IAAiBA,WAPX,CAAhB,CADA,CASA;AACD,GAbD,MAaO;AACLL,gBAAY,GAAI,GACbC,MADa,CAEZP,eAAe,CAACC,kBAFJ,EAGZD,eAAe,CAACG,0BAAhB,CAA2CK,GAA3C,CAAgDC,QAAD,IAC7CA,QAAQ,CAAC3B,gBAAD,CADV,CAHY,EAOb4B,MAPa,CAOLC,WAAD,IAAiBA,WAPX,CAAhB,CADK,CASL;AACD;;AACD,QAAMC,kBAAkB,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB1C,OAAlB,EAA2B;AACpD2C,qBAAiB,EAAEjC;AADiC,GAA3B,CAA3B;AAGA;;;;;;;;AAOA,QAAMb,OAAO,GAAaqC,YAAY,CAACU,WAAb,CACxB,CAAC9E,QAAD,EAAqB+E,eAArB,KAAqD;AACnD,WAAQC,cAAD,IAAoBD,eAAe,CAACC,cAAD,EAAiBhF,QAAjB,CAA1C;AACD,GAHuB,EAIvBiF,YAAD,IACEtB,yBAAyB,CAAC3B,OAAD,EAAUiD,YAAV,EAAwBrC,gBAAxB,CALH,CAA1B;AAOA,SAAOb,OAAO,CAAC2C,kBAAD,CAAd;AACD;;AArEDpG","names":["InterceptorConfigurationError","Error","constructor","message","name","captureStackTrace","exports","ListenerBuilder","undefined","withOnReceiveMetadata","onReceiveMetadata","metadata","withOnReceiveMessage","onReceiveMessage","withOnReceiveStatus","onReceiveStatus","status","build","RequesterBuilder","withStart","start","withSendMessage","sendMessage","withHalfClose","halfClose","withCancel","cancel","defaultListener","next","defaultRequester","listener","InterceptingCall","nextCall","requester","_a","_b","_c","_d","cancelWithStatus","details","getPeer","processPendingMessage","pendingMessageContext","sendMessageWithContext","pendingMessage","processPendingHalfClose","pendingHalfClose","interceptingListener","fullInterceptingListener","bind","_e","_f","processingMetadata","md","finalInterceptingListener","call_stream_1","fullListener","context","processingMessage","finalMessage","startRead","setCredentials","credentials","getCall","channel","path","options","deadline","Infinity","host","parent","propagateFlags","propagate_flags","call","createCall","BaseInterceptingCall","methodDefinition","serialized","requestSerialize","e","constants_1","INTERNAL","readError","deserialized","responseDeserialize","code","metadata_1","BaseUnaryInterceptingCall","receivedMessage","wrapperListener","BaseStreamingInterceptingCall","getBottomInterceptingCall","responseStream","getInterceptingCall","interceptorArgs","clientInterceptors","length","clientInterceptorProviders","callInterceptors","callInterceptorProviders","interceptors","concat","map","provider","filter","interceptor","interceptorOptions","Object","assign","method_definition","reduceRight","nextInterceptor","currentOptions","finalOptions"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/client-interceptors.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\nimport {\n  StatusObject,\n  Listener,\n  MetadataListener,\n  MessageListener,\n  StatusListener,\n  FullListener,\n  InterceptingListener,\n  InterceptingListenerImpl,\n  isInterceptingListener,\n  MessageContext,\n  Call,\n} from './call-stream';\nimport { Status } from './constants';\nimport { Channel } from './channel';\nimport { CallOptions } from './client';\nimport { CallCredentials } from './call-credentials';\nimport { ClientMethodDefinition } from './make-client';\n\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nexport class InterceptorConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\n\nexport interface MetadataRequester {\n  (\n    metadata: Metadata,\n    listener: InterceptingListener,\n    next: (\n      metadata: Metadata,\n      listener: InterceptingListener | Listener\n    ) => void\n  ): void;\n}\n\nexport interface MessageRequester {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface CloseRequester {\n  (next: () => void): void;\n}\n\nexport interface CancelRequester {\n  (next: () => void): void;\n}\n\n/**\n * An object with methods for intercepting and modifying outgoing call operations.\n */\nexport interface FullRequester {\n  start: MetadataRequester;\n  sendMessage: MessageRequester;\n  halfClose: CloseRequester;\n  cancel: CancelRequester;\n}\n\nexport type Requester = Partial<FullRequester>;\n\nexport class ListenerBuilder {\n  private metadata: MetadataListener | undefined = undefined;\n  private message: MessageListener | undefined = undefined;\n  private status: StatusListener | undefined = undefined;\n\n  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage: MessageListener): this {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus: StatusListener): this {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build(): Listener {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status,\n    };\n  }\n}\n\nexport class RequesterBuilder {\n  private start: MetadataRequester | undefined = undefined;\n  private message: MessageRequester | undefined = undefined;\n  private halfClose: CloseRequester | undefined = undefined;\n  private cancel: CancelRequester | undefined = undefined;\n\n  withStart(start: MetadataRequester): this {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage: MessageRequester): this {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose: CloseRequester): this {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel: CancelRequester): this {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build(): Requester {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel,\n    };\n  }\n}\n\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener: FullListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  },\n};\n\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester: FullRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: (next) => {\n    next();\n  },\n  cancel: (next) => {\n    next();\n  },\n};\n\nexport interface InterceptorOptions extends CallOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  method_definition: ClientMethodDefinition<any, any>;\n}\n\nexport interface InterceptingCallInterface {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void;\n  startRead(): void;\n  halfClose(): void;\n\n  setCredentials(credentials: CallCredentials): void;\n}\n\nexport class InterceptingCall implements InterceptingCallInterface {\n  /**\n   * The requester that this InterceptingCall uses to modify outgoing operations\n   */\n  private requester: FullRequester;\n  /**\n   * Indicates that metadata has been passed to the requester's start\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMetadata = false;\n  /**\n   * Message context for a pending message that is waiting for\n   */\n  private pendingMessageContext: MessageContext | null = null;\n  private pendingMessage: any;\n  /**\n   * Indicates that a message has been passed to the requester's sendMessage\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMessage = false;\n  /**\n   * Indicates that a status was received but could not be propagated because\n   * a message was still being processed.\n   */\n  private pendingHalfClose = false;\n  constructor(\n    private nextCall: InterceptingCallInterface,\n    requester?: Requester\n  ) {\n    if (requester) {\n      this.requester = {\n        start: requester.start ?? defaultRequester.start,\n        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,\n        halfClose: requester.halfClose ?? defaultRequester.halfClose,\n        cancel: requester.cancel ?? defaultRequester.cancel,\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  private processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  private processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    const fullInterceptingListener: InterceptingListener = {\n      onReceiveMetadata:\n        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??\n        ((metadata) => {}),\n      onReceiveMessage:\n        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??\n        ((message) => {}),\n      onReceiveStatus:\n        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??\n        ((status) => {}),\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      this.processingMetadata = false;\n      let finalInterceptingListener: InterceptingListener;\n      if (isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener: FullListener = {\n          onReceiveMetadata:\n            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,\n          onReceiveMessage:\n            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,\n          onReceiveStatus:\n            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,\n        };\n        finalInterceptingListener = new InterceptingListenerImpl(\n          fullListener,\n          fullInterceptingListener\n        );\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, (finalMessage) => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead(): void {\n    this.nextCall.startRead();\n  }\n  halfClose(): void {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.nextCall.setCredentials(credentials);\n  }\n}\n\nfunction getCall(channel: Channel, path: string, options: CallOptions): Call {\n  const deadline = options.deadline ?? Infinity;\n  const host = options.host;\n  const parent = options.parent ?? null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall implements InterceptingCallInterface {\n  constructor(\n    protected call: Call,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected methodDefinition: ClientMethodDefinition<any, any>\n  ) {}\n  cancelWithStatus(status: Status, details: string): void {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.call.setCredentials(credentials);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    let serialized: Buffer;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(\n        Status.INTERNAL,\n        `Request message serialization failure: ${e.message}`\n      );\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    let readError: StatusObject | null = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: (metadata) => {\n        interceptingListener?.onReceiveMetadata?.(metadata);\n      },\n      onReceiveMessage: (message) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized: any;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new Metadata(),\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        interceptingListener?.onReceiveMessage?.(deserialized);\n      },\n      onReceiveStatus: (status) => {\n        if (readError) {\n          interceptingListener?.onReceiveStatus?.(readError);\n        } else {\n          interceptingListener?.onReceiveStatus?.(status);\n        }\n      },\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose(): void {\n    this.call.halfClose();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) {\n    super(call, methodDefinition);\n  }\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void {\n    let receivedMessage = false;\n    const wrapperListener: InterceptingListener = {\n      onReceiveMetadata:\n        listener?.onReceiveMetadata?.bind(listener) ?? ((metadata) => {}),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: (message: any) => {\n        receivedMessage = true;\n        listener?.onReceiveMessage?.(message);\n      },\n      onReceiveStatus: (status: StatusObject) => {\n        if (!receivedMessage) {\n          listener?.onReceiveMessage?.(null);\n        }\n        listener?.onReceiveStatus?.(status);\n      },\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {}\n\nfunction getBottomInterceptingCall(\n  channel: Channel,\n  options: InterceptorOptions,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>\n) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nexport interface NextCall {\n  (options: InterceptorOptions): InterceptingCallInterface;\n}\n\nexport interface Interceptor {\n  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;\n}\n\nexport interface InterceptorProvider {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;\n}\n\nexport interface InterceptorArguments {\n  clientInterceptors: Interceptor[];\n  clientInterceptorProviders: InterceptorProvider[];\n  callInterceptors: Interceptor[];\n  callInterceptorProviders: InterceptorProvider[];\n}\n\nexport function getInterceptingCall(\n  interceptorArgs: InterceptorArguments,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>,\n  options: CallOptions,\n  channel: Channel\n): InterceptingCallInterface {\n  if (\n    interceptorArgs.clientInterceptors.length > 0 &&\n    interceptorArgs.clientInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as options ' +\n        'to the client constructor. Only one of these is allowed.'\n    );\n  }\n  if (\n    interceptorArgs.callInterceptors.length > 0 &&\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as call ' +\n        'options. Only one of these is allowed.'\n    );\n  }\n  let interceptors: Interceptor[] = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (\n    interceptorArgs.callInterceptors.length > 0 ||\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.callInterceptors,\n        interceptorArgs.callInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.clientInterceptors,\n        interceptorArgs.clientInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition,\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall: NextCall = interceptors.reduceRight<NextCall>(\n    (nextCall: NextCall, nextInterceptor: Interceptor) => {\n      return (currentOptions) => nextInterceptor(currentOptions, nextCall);\n    },\n    (finalOptions: InterceptorOptions) =>\n      getBottomInterceptingCall(channel, finalOptions, methodDefinition)\n  );\n  return getCall(interceptorOptions);\n}\n"]},"metadata":{},"sourceType":"script"}