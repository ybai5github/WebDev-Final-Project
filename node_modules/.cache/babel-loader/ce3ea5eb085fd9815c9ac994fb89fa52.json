{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_1 = require(\"./filter\");\n\nconst units = [['m', 1], ['S', 1000], ['M', 60 * 1000], ['H', 60 * 60 * 1000]];\n\nfunction getDeadline(deadline) {\n  const now = new Date().getTime();\n  const timeoutMs = Math.max(deadline - now, 0);\n\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n\n  throw new Error('Deadline is too far in the future');\n}\n\nclass DeadlineFilter extends filter_1.BaseFilter {\n  constructor(channel, callStream) {\n    super();\n    this.channel = channel;\n    this.callStream = callStream;\n    this.timer = null;\n    this.deadline = Infinity;\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n\n  retreiveDeadline() {\n    const callDeadline = this.callStream.getDeadline();\n\n    if (callDeadline instanceof Date) {\n      this.deadline = callDeadline.getTime();\n    } else {\n      this.deadline = callDeadline;\n    }\n  }\n\n  runTimer() {\n    var _a, _b;\n\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n\n    const now = new Date().getTime();\n    const timeout = this.deadline - now;\n\n    if (timeout <= 0) {\n      process.nextTick(() => {\n        this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      });\n    } else if (this.deadline !== Infinity) {\n      this.timer = setTimeout(() => {\n        this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      }, timeout);\n      (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  refresh() {\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n\n  async sendMetadata(metadata) {\n    if (this.deadline === Infinity) {\n      return metadata;\n    }\n    /* The input metadata promise depends on the original channel.connect()\n     * promise, so when it is complete that implies that the channel is\n     * connected */\n\n\n    const finalMetadata = await metadata;\n    const timeoutString = getDeadline(this.deadline);\n    finalMetadata.set('grpc-timeout', timeoutString);\n    return finalMetadata;\n  }\n\n  receiveTrailers(status) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n\n    return status;\n  }\n\n}\n\nexports.DeadlineFilter = DeadlineFilter;\n\nclass DeadlineFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new DeadlineFilter(this.channel, callStream);\n  }\n\n}\n\nexports.DeadlineFilterFactory = DeadlineFilterFactory;","map":{"version":3,"mappings":"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","names":["units","getDeadline","deadline","now","Date","getTime","timeoutMs","Math","max","unit","factor","amount","String","ceil","Error","DeadlineFilter","filter_1","constructor","channel","callStream","Infinity","retreiveDeadline","runTimer","callDeadline","timer","clearTimeout","timeout","process","nextTick","cancelWithStatus","constants_1","DEADLINE_EXCEEDED","setTimeout","unref","_b","refresh","sendMetadata","metadata","finalMetadata","timeoutString","set","receiveTrailers","status","exports","DeadlineFilterFactory","createFilter"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/deadline-filter.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Call, StatusObject } from './call-stream';\nimport { Channel } from './channel';\nimport { Status } from './constants';\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport { Metadata } from './metadata';\n\nconst units: Array<[string, number]> = [\n  ['m', 1],\n  ['S', 1000],\n  ['M', 60 * 1000],\n  ['H', 60 * 60 * 1000],\n];\n\nfunction getDeadline(deadline: number) {\n  const now = new Date().getTime();\n  const timeoutMs = Math.max(deadline - now, 0);\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n  throw new Error('Deadline is too far in the future');\n}\n\nexport class DeadlineFilter extends BaseFilter implements Filter {\n  private timer: NodeJS.Timer | null = null;\n  private deadline = Infinity;\n  constructor(\n    private readonly channel: Channel,\n    private readonly callStream: Call\n  ) {\n    super();\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n\n  private retreiveDeadline() {\n    const callDeadline = this.callStream.getDeadline();\n    if (callDeadline instanceof Date) {\n      this.deadline = callDeadline.getTime();\n    } else {\n      this.deadline = callDeadline;\n    }\n  }\n\n  private runTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    const now: number = new Date().getTime();\n    const timeout = this.deadline - now;\n    if (timeout <= 0) {\n      process.nextTick(() => {\n        this.callStream.cancelWithStatus(\n          Status.DEADLINE_EXCEEDED,\n          'Deadline exceeded'\n        );\n      });\n    } else if (this.deadline !== Infinity) {\n      this.timer = setTimeout(() => {\n        this.callStream.cancelWithStatus(\n          Status.DEADLINE_EXCEEDED,\n          'Deadline exceeded'\n        );\n      }, timeout);\n      this.timer.unref?.();\n    }\n  }\n\n  refresh() {\n    this.retreiveDeadline();\n    this.runTimer();\n  }\n\n  async sendMetadata(metadata: Promise<Metadata>) {\n    if (this.deadline === Infinity) {\n      return metadata;\n    }\n    /* The input metadata promise depends on the original channel.connect()\n     * promise, so when it is complete that implies that the channel is\n     * connected */\n    const finalMetadata = await metadata;\n    const timeoutString = getDeadline(this.deadline);\n    finalMetadata.set('grpc-timeout', timeoutString);\n    return finalMetadata;\n  }\n\n  receiveTrailers(status: StatusObject) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n    return status;\n  }\n}\n\nexport class DeadlineFilterFactory implements FilterFactory<DeadlineFilter> {\n  constructor(private readonly channel: Channel) {}\n\n  createFilter(callStream: Call): DeadlineFilter {\n    return new DeadlineFilter(this.channel, callStream);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}