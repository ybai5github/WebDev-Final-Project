{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\n\nconst http2 = require(\"http2\");\n\nconst tls_1 = require(\"tls\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst net = require(\"net\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst channelz_1 = require(\"./channelz\");\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\n\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\n\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n\n    this.disconnectListeners = [];\n    /**\n     * The amount of time in between sending pings\n     */\n\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n\n    this.keepaliveWithoutCalls = false;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n\n    this.refcount = 0; // Channelz info\n\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker(); // Channelz socket info\n\n    this.channelzSocketRef = null;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null; // Build user-agent string.\n\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n\n    if (this.channelzEnabled) {\n      this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'subchannel',\n        id: -1,\n        name: ''\n      };\n    }\n\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  getChannelzSocketInfo() {\n    var _a, _b, _c;\n\n    if (this.session === null) {\n      return null;\n    }\n\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n\n  resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n\n    if (this.channelzSocketRef) {\n      channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n\n\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  sendPing() {\n    var _a, _b;\n\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + 'Sending ping');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.session.ping((err, duration, payload) => {\n      clearTimeout(this.keepaliveTimeoutId);\n    });\n  }\n\n  startKeepalivePings() {\n    var _a, _b;\n\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  createSession(proxyConnectionResult) {\n    var _a, _b, _c;\n\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n\n    const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    }\n\n    let addressScheme = 'http://';\n\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://'; // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost'; // We want to always set servername to support SNI\n\n        connectionOptions.servername = authorityHostname;\n      }\n\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n\n    const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n    this.session = session;\n\n    if (this.channelzEnabled) {\n      this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo());\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n        }\n\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n\n  startConnectingInternal() {\n    var _a, _b;\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n\n\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2']; // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n\n    http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then(result => {\n      this.createSession(result);\n    }, reason => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n\n\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n\n            for (const listener of this.disconnectListeners) {\n              listener();\n            }\n          }\n        });\n\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n\n        break;\n\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n\n        break;\n\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n\n\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n\n\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n\n      this.backoffTimeout.ref();\n\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n\n      this.backoffTimeout.unref();\n\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n\n\n  startCallStream(metadata, callStream, extraFilters) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n      throw e;\n    }\n\n    let headersString = '';\n\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' + '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' with headers\\n' + headersString);\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    const streamSession = this.session;\n    this.internalsTrace('session.closed=' + streamSession.closed + ' session.destroyed=' + streamSession.destroyed + ' session.socket.destroyed=' + streamSession.socket.destroyed);\n    let statsTracker;\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      };\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      };\n    }\n\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n\n\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n\n\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n\n\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n\n\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n\n  removeDisconnectListener(listener) {\n    const listenerIndex = this.disconnectListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.disconnectListeners.splice(listenerIndex, 1);\n    }\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel() {\n    return this;\n  }\n\n}\n\nexports.Subchannel = Subchannel;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;AAiBA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAGA;;AAKA;;AAGA,MAAMA,aAAa,GAAGC,OAAO,CAAC,oBAAD,CAAP,CAA8BC,OAApD;;AAEA,MAAMC,WAAW,GAAG,YAApB;AACA,MAAMC,wBAAwB,GAAG,qBAAjC;AAEA,MAAMC,sBAAsB,GAAG,KAA/B;AACA,MAAMC,kBAAkB,GAAG,IAA3B;AACA,MAAMC,kBAAkB,GAAG,GAA3B;AACA,MAAMC,cAAc,GAAG,MAAvB;AACA,MAAMC,cAAc,GAAG,GAAvB;AAEA;;;;AAGA,MAAMC,qBAAqB,GAAG,EAAE,KAAK,EAAP,CAA9B;AACA,MAAMC,oBAAoB,GAAG,KAA7B;AAOA,MAAM;AACJC,wBADI;AAEJC,2BAFI;AAGJC,qBAHI;AAIJC,mBAJI;AAKJC,iBALI;AAMJC;AANI,IAOFC,KAAK,CAACC,SAPV;AASA;;;;;;AAKA,SAASC,aAAT,CAAuBC,GAAvB,EAAoCC,GAApC,EAA+C;AAC7C,SAAOC,IAAI,CAACC,MAAL,MAAiBF,GAAG,GAAGD,GAAvB,IAA8BA,GAArC;AACD;;AAED,MAAMI,gBAAgB,GAAWC,MAAM,CAACC,IAAP,CAAY,gBAAZ,EAA8B,OAA9B,CAAjC;;AAEA,MAAaC,UAAb,CAAuB;AA4FrB;;;;;;;;;;AAUAC,cACUC,aADV,EAEUC,iBAFV,EAGUC,OAHV,EAIUC,WAJV,EAIyC;AAH/B;AACA;AACA;AACA;AAzGV;;;;;AAIQ,6BAAuCC,uCAAkBC,IAAzD;AACR;;;;AAGQ,mBAA2C,IAA3C;AACR;;;;;AAIQ,8BAAqB,KAArB;AACR;;;;;;AAKQ,0BAA8C,EAA9C;AAER;;;;;;AAKQ,+BAAyC,EAAzC;AASR;;;;AAGQ,2BAA0BzB,qBAA1B;AACR;;;;AAGQ,8BAA6BC,oBAA7B;AASR;;;;AAGQ,iCAAwB,KAAxB;AAER;;;;AAGQ,wBAAe,CAAf;AACR;;;;AAGQ,oBAAW,CAAX,CA0CiC,CAnCzC;;AACiB,2BAA2B,IAA3B;AAGT,uBAAc,IAAIyB,8BAAJ,EAAd;AACA,2BAAkB,IAAIA,kCAAJ,EAAlB,CA8BiC,CA5BzC;;AACQ,6BAAsC,IAAtC;AACR;;;;;AAIQ,sBAA4B,IAA5B;AACA,yBAAgB,IAAIA,8BAAJ,EAAhB;AACA,0BAAiB,CAAjB;AACA,wBAAe,CAAf;AACA,4BAAmB,CAAnB;AACA,oCAAwC,IAAxC;AACA,wCAA4C,IAA5C,CAgBiC,CAEvC;;AACA,SAAKC,SAAL,GAAiB,CACfL,OAAO,CAAC,yBAAD,CADQ,EAEf,gBAAgBhC,aAAa,EAFd,EAGfgC,OAAO,CAAC,2BAAD,CAHQ,EAKdM,MALc,CAKNC,CAAD,IAAOA,CALA,EAMdC,IANc,CAMT,GANS,CAAjB,CAHuC,CASzB;;AAEd,QAAI,4BAA4BR,OAAhC,EAAyC;AACvC,WAAKS,eAAL,GAAuBT,OAAO,CAAC,wBAAD,CAA9B;AACD;;AACD,QAAI,+BAA+BA,OAAnC,EAA4C;AAC1C,WAAKU,kBAAL,GAA0BV,OAAO,CAAC,2BAAD,CAAjC;AACD;;AACD,QAAI,yCAAyCA,OAA7C,EAAsD;AACpD,WAAKW,qBAAL,GACEX,OAAO,CAAC,qCAAD,CAAP,KAAmD,CADrD;AAED,KAHD,MAGO;AACL,WAAKW,qBAAL,GAA6B,KAA7B;AACD;;AACD,SAAKC,mBAAL,GAA2BC,UAAU,CAAC,MAAK,CAAG,CAAT,EAAW,CAAX,CAArC;AACAC,gBAAY,CAAC,KAAKF,mBAAN,CAAZ;AACA,SAAKG,kBAAL,GAA0BF,UAAU,CAAC,MAAK,CAAG,CAAT,EAAW,CAAX,CAApC;AACAC,gBAAY,CAAC,KAAKC,kBAAN,CAAZ;AACA,UAAMC,cAAc,GAAmB;AACrCC,kBAAY,EAAEjB,OAAO,CAAC,mCAAD,CADgB;AAErCkB,cAAQ,EAAElB,OAAO,CAAC,+BAAD;AAFoB,KAAvC;AAIA,SAAKmB,cAAL,GAAsB,IAAIC,gCAAJ,CAAmB,MAAK;AAC5C,WAAKC,kBAAL;AACD,KAFqB,EAEnBL,cAFmB,CAAtB;AAGA,SAAKM,uBAAL,GAA+BC,+CAA0BxB,iBAA1B,CAA/B;;AAEA,QAAIC,OAAO,CAAC,sBAAD,CAAP,KAAoC,CAAxC,EAA2C;AACzC,WAAKwB,eAAL,GAAuB,KAAvB;AACD;;AACD,SAAKC,aAAL,GAAqB,IAAIrB,wBAAJ,EAArB;;AACA,QAAI,KAAKoB,eAAT,EAA0B;AACxB,WAAKE,WAAL,GAAmBtB,sCAA2B,KAAKkB,uBAAhC,EAAyD,MAAM,KAAKK,eAAL,EAA/D,CAAnB;AACA,WAAKF,aAAL,CAAmBG,QAAnB,CAA4B,SAA5B,EAAuC,oBAAvC;AACD,KAHD,MAGO;AACL;AACA,WAAKF,WAAL,GAAmB;AACjBG,YAAI,EAAE,YADW;AAEjBC,UAAE,EAAE,CAAC,CAFY;AAGjBC,YAAI,EAAE;AAHW,OAAnB;AAKD;;AACD,SAAKC,KAAL,CAAW,yCAAyCC,IAAI,CAACC,SAAL,CAAelC,OAAf,EAAwBmC,SAAxB,EAAmC,CAAnC,CAApD;AACD;;AAEOR,iBAAe;AACrB,WAAO;AACLS,WAAK,EAAE,KAAKC,iBADP;AAELL,WAAK,EAAE,KAAKP,aAFP;AAGLa,iBAAW,EAAE,KAAKA,WAHb;AAILC,cAAQ,EAAE,KAAKC,eAAL,CAAqBC,aAArB,EAJL;AAKLC,YAAM,EAAE,KAAKpB;AALR,KAAP;AAOD;;AAEOqB,uBAAqB;;;AAC3B,QAAI,KAAKC,OAAL,KAAiB,IAArB,EAA2B;AACzB,aAAO,IAAP;AACD;;AACD,UAAMC,aAAa,GAAG,KAAKD,OAAL,CAAaE,MAAnC;AACA,UAAMC,aAAa,GAAGF,aAAa,CAACE,aAAd,GAA8BxB,+CAA0BsB,aAAa,CAACE,aAAxC,EAAuDF,aAAa,CAACG,UAArE,CAA9B,GAAiH,IAAvI;AACA,UAAMC,YAAY,GAAGJ,aAAa,CAACI,YAAd,GAA6B1B,+CAA0BsB,aAAa,CAACI,YAAxC,EAAsDJ,aAAa,CAACK,SAApE,CAA7B,GAA8G,IAAnI;AACA,QAAIC,OAAJ;;AACA,QAAI,KAAKP,OAAL,CAAaQ,SAAjB,EAA4B;AAC1B,YAAMC,SAAS,GAAcR,aAA7B;AACA,YAAMS,UAAU,GAAoDD,SAAS,CAACE,SAAV,EAApE;AACA,YAAMC,WAAW,GAAGH,SAAS,CAACI,cAAV,EAApB;AACA,YAAMC,eAAe,GAAGL,SAAS,CAACM,kBAAV,EAAxB;AACAR,aAAO,GAAG;AACRS,+BAAuB,QAAEN,UAAU,CAACO,YAAb,MAAyB,IAAzB,IAAyBC,aAAzB,GAAyBA,EAAzB,GAA6B,IAD5C;AAERC,4BAAoB,EAAET,UAAU,CAACO,YAAX,GAA0B,IAA1B,GAAiCP,UAAU,CAACvB,IAF1D;AAGRiC,wBAAgB,EAAGR,WAAW,IAAI,SAASA,WAAzB,GAAwCA,WAAW,CAACS,GAApD,GAA0D,IAHpE;AAIRC,yBAAiB,EAAGR,eAAe,IAAI,SAASA,eAA7B,GAAgDA,eAAe,CAACO,GAAhE,GAAsE;AAJjF,OAAV;AAMD,KAXD,MAWO;AACLd,aAAO,GAAG,IAAV;AACD;;AACD,UAAMgB,UAAU,GAAe;AAC7BpB,mBAAa,EAAEA,aADc;AAE7BE,kBAAY,EAAEA,YAFe;AAG7BmB,cAAQ,EAAEjB,OAHmB;AAI7BkB,gBAAU,EAAE,KAAKA,UAJY;AAK7BC,oBAAc,EAAE,KAAKC,aAAL,CAAmBC,YALN;AAM7BC,sBAAgB,EAAE,KAAKF,aAAL,CAAmBG,cANR;AAO7BC,mBAAa,EAAE,KAAKJ,aAAL,CAAmBK,WAPL;AAQ7BC,kBAAY,EAAE,KAAKA,YARU;AAS7BC,sBAAgB,EAAE,KAAKA,gBATM;AAU7BC,oBAAc,EAAE,KAAKC,cAVQ;AAW7BC,qCAA+B,EAAE,KAAKV,aAAL,CAAmBW,wBAXvB;AAY7BC,sCAAgC,EAAE,IAZL;AAa7BC,8BAAwB,EAAE,KAAKA,wBAbF;AAc7BC,kCAA4B,EAAE,KAAKA,4BAdN;AAe7BC,4BAAsB,QAAE,KAAK1C,OAAL,CAAaR,KAAb,CAAmBmD,eAArB,MAAoC,IAApC,IAAoCC,aAApC,GAAoCA,EAApC,GAAwC,IAfjC;AAgB7BC,6BAAuB,QAAE,KAAK7C,OAAL,CAAaR,KAAb,CAAmBsD,gBAArB,MAAqC,IAArC,IAAqCC,aAArC,GAAqCA,EAArC,GAAyC;AAhBnC,KAA/B;AAkBA,WAAOxB,UAAP;AACD;;AAEOyB,yBAAuB;AAC7B,QAAI,CAAC,KAAKpE,eAAV,EAA2B;AACzB;AACD;;AACD,QAAI,KAAKqE,iBAAT,EAA4B;AAC1BzF,uCAAsB,KAAKyF,iBAA3B;AACA,WAAKrD,eAAL,CAAqBsD,UAArB,CAAgC,KAAKD,iBAArC;AACA,WAAKA,iBAAL,GAAyB,IAAzB;AACD;;AACD,SAAKxB,UAAL,GAAkB,IAAlB;AACA,SAAKE,aAAL,GAAqB,IAAInE,8BAAJ,EAArB;AACA,SAAK4E,cAAL,GAAsB,CAAtB;AACA,SAAKH,YAAL,GAAoB,CAApB;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKM,wBAAL,GAAgC,IAAhC;AACA,SAAKC,4BAAL,GAAoC,IAApC;AACD;;AAEOrD,OAAK,CAAC+D,IAAD,EAAa;AACxBC,WAAO,CAAChE,KAAR,CAAciE,yBAAaC,KAA3B,EAAkC/H,WAAlC,EAA+C,MAAM,KAAKuD,WAAL,CAAiBI,EAAvB,GAA4B,IAA5B,GAAmC,KAAKR,uBAAxC,GAAkE,GAAlE,GAAwEyE,IAAvH;AACD;;AAEOI,UAAQ,CAACJ,IAAD,EAAa;AAC3BC,WAAO,CAAChE,KAAR,CAAciE,yBAAaC,KAA3B,EAAkC,qBAAlC,EAAyD,MAAM,KAAKxE,WAAL,CAAiBI,EAAvB,GAA4B,IAA5B,GAAmC,KAAKR,uBAAxC,GAAkE,GAAlE,GAAwEyE,IAAjI;AACD;;AAEOK,kBAAgB,CAACL,IAAD,EAAa;AACnCC,WAAO,CAAChE,KAAR,CAAciE,yBAAaC,KAA3B,EAAkC9H,wBAAlC,EAA4D,MAAM,KAAKsD,WAAL,CAAiBI,EAAvB,GAA4B,IAA5B,GAAmC,KAAKR,uBAAxC,GAAkE,GAAlE,GAAwEyE,IAApI;AACD;;AAEOM,gBAAc,CAACN,IAAD,EAAa;AACjCC,WAAO,CAAChE,KAAR,CAAciE,yBAAaC,KAA3B,EAAkC,sBAAlC,EAA0D,MAAM,KAAKxE,WAAL,CAAiBI,EAAvB,GAA4B,IAA5B,GAAmC,KAAKR,uBAAxC,GAAkE,GAAlE,GAAwEyE,IAAlI;AACD;;AAEO1E,oBAAkB;AACxB,QAAI,KAAKiF,kBAAT,EAA6B;AAC3B,WAAKC,iBAAL,CACE,CAACrG,uCAAkBsG,iBAAnB,CADF,EAEEtG,uCAAkBuG,UAFpB;AAID,KALD,MAKO;AACL,WAAKF,iBAAL,CACE,CAACrG,uCAAkBsG,iBAAnB,CADF,EAEEtG,uCAAkBC,IAFpB;AAID;AACF;AAED;;;;;AAGQuG,cAAY;AAClB,SAAKvF,cAAL,CAAoBwF,OAApB;AACD;;AAEOC,aAAW;AACjB,SAAKzF,cAAL,CAAoB0F,IAApB;AACA,SAAK1F,cAAL,CAAoB2F,KAApB;AACD;;AAEOC,UAAQ;;;AACd,QAAI,KAAKvF,eAAT,EAA0B;AACxB,WAAKwD,cAAL,IAAuB,CAAvB;AACD;;AACDgB,WAAO,CAAChE,KAAR,CACEiE,yBAAaC,KADf,EAEE,WAFF,EAGE,MAAM,KAAKxE,WAAL,CAAiBI,EAAvB,GAA4B,IAA5B,GAAmC,KAAKR,uBAAxC,GAAkE,GAAlE,GACA,cAJF;AAMA,SAAKP,kBAAL,GAA0BF,UAAU,CAAC,MAAK;AACxC,WAAK0F,iBAAL,CAAuB,CAACrG,uCAAkB8G,KAAnB,CAAvB,EAAkD9G,uCAAkBC,IAApE;AACD,KAFmC,EAEjC,KAAKO,kBAF4B,CAApC;AAGA,qBAAKK,kBAAL,EAAwBkG,KAAxB,MAA6B,IAA7B,IAA6BzB,aAA7B,GAA6B,MAA7B,GAA6BA,WAA7B;AACA,SAAK5C,OAAL,CAAcsE,IAAd,CACE,CAACC,GAAD,EAAoBC,QAApB,EAAsCC,OAAtC,KAAyD;AACvDvG,kBAAY,CAAC,KAAKC,kBAAN,CAAZ;AACD,KAHH;AAKD;;AAEOuG,qBAAmB;;;AACzB,SAAK1G,mBAAL,GAA2B2G,WAAW,CAAC,MAAK;AAC1C,WAAKR,QAAL;AACD,KAFqC,EAEnC,KAAKtG,eAF8B,CAAtC;AAGA,qBAAKG,mBAAL,EAAyBqG,KAAzB,MAA8B,IAA9B,IAA8BzB,aAA9B,GAA8B,MAA9B,GAA8BA,WAA9B;AACA;;AAED;;AAEOgC,oBAAkB;AACxBC,iBAAa,CAAC,KAAK7G,mBAAN,CAAb;AACAE,gBAAY,CAAC,KAAKC,kBAAN,CAAZ;AACD;;AAEO2G,eAAa,CAACC,qBAAD,EAA6C;;;AAChE,QAAIA,qBAAqB,CAACC,UAA1B,EAAsC;AACpC,WAAKvD,UAAL,GAAkBwD,yBAAYF,qBAAqB,CAACC,UAAlC,CAAlB;AACA,WAAK5F,KAAL,CAAW,8CAA8C2F,qBAAqB,CAACC,UAA/E;AACD,KAHD,MAGO;AACL,WAAKvD,UAAL,GAAkB,IAAlB;AACA,WAAKrC,KAAL,CAAW,yBAAX;AACD;;AACD,UAAM8F,eAAe,GAAGC,+BAAmB,MACzCJ,qBAAqB,CAACC,UADmB,MACT,IADS,IACT9D,aADS,GACTA,EADS,GACL,KAAKhE,aADnB,CAAxB;AAGA,QAAIkI,iBAAiB,GACnB,KAAK/H,WAAL,CAAiBgI,qBAAjB,MAA4C,EAD9C;AAEAD,qBAAiB,CAACE,wBAAlB,GAA6CC,MAAM,CAACC,gBAApD;;AACA,QAAI,kCAAkC,KAAKpI,OAA3C,EAAoD;AAClDgI,uBAAiB,CAACK,gBAAlB,GAAqC,KAAKrI,OAAL,CACnC,8BADmC,CAArC;AAGD;;AACD,QAAIsI,aAAa,GAAG,SAApB;;AACA,QAAI,mBAAmBN,iBAAvB,EAA0C;AACxCM,mBAAa,GAAG,UAAhB,CADwC,CAExC;AACA;AACA;;AACA,UAAI,KAAKtI,OAAL,CAAa,+BAAb,CAAJ,EAAmD;AACjD,cAAMuI,qBAAqB,GAAG,KAAKvI,OAAL,CAC5B,+BAD4B,CAA9B;;AAGAgI,yBAAiB,CAACQ,mBAAlB,GAAwC,CACtCC,IADsC,EAEtCC,IAFsC,KAGjB;AACrB,iBAAOC,0BAAoBJ,qBAApB,EAA2CG,IAA3C,CAAP;AACD,SALD;;AAMAV,yBAAiB,CAACY,UAAlB,GAA+BL,qBAA/B;AACD,OAXD,MAWO;AACL,cAAMM,iBAAiB,eACrBhB,2BAAcC,eAAd,CADqB,MACS,IADT,IACStC,aADT,GACS,MADT,GACSA,GAAEiD,IADX,MACe,IADf,IACe9C,aADf,GACeA,EADf,GACmB,WAD1C,CADK,CAGL;;AACAqC,yBAAiB,CAACY,UAAlB,GAA+BC,iBAA/B;AACD;;AACD,UAAIlB,qBAAqB,CAAC7E,MAA1B,EAAkC;AAChC;;;;;AAKAkF,yBAAiB,CAACc,gBAAlB,GAAqC,CAACC,SAAD,EAAYC,MAAZ,KAAsB;AACzD,iBAAOrB,qBAAqB,CAAC7E,MAA7B;AACD,SAFD;AAGD;AACF,KAhCD,MAgCO;AACL;;;AAGAkF,uBAAiB,CAACc,gBAAlB,GAAqC,CAACC,SAAD,EAAYC,MAAZ,KAAsB;AACzD,YAAIrB,qBAAqB,CAAC7E,MAA1B,EAAkC;AAChC,iBAAO6E,qBAAqB,CAAC7E,MAA7B;AACD,SAFD,MAEO;AACL;;;AAGA,iBAAOmG,GAAG,CAACC,OAAJ,CAAY,KAAKnJ,iBAAjB,CAAP;AACD;AACF,OATD;AAUD;;AAEDiI,qBAAiB,mCACZA,iBADY,GAEZ,KAAKjI,iBAFO,CAAjB;AAKA;;;;;;;;;;;;;;;;;;AAiBA,UAAM6C,OAAO,GAAG1D,KAAK,CAACgK,OAAN,CACdZ,aAAa,GAAGR,eADF,EAEdE,iBAFc,CAAhB;AAIA,SAAKpF,OAAL,GAAeA,OAAf;;AACA,QAAI,KAAKpB,eAAT,EAA0B;AACxB,WAAKqE,iBAAL,GAAyBzF,kCAAuB,KAAKkB,uBAA5B,EAAqD,MAAM,KAAKqB,qBAAL,EAA3D,CAAzB;AACA,WAAKH,eAAL,CAAqB2G,QAArB,CAA8B,KAAKtD,iBAAnC;AACD;;AACDjD,WAAO,CAACqE,KAAR;AACA;;;;;AAIArE,WAAO,CAACwG,IAAR,CAAa,SAAb,EAAwB,MAAK;AAC3B,UAAI,KAAKxG,OAAL,KAAiBA,OAArB,EAA8B;AAC5B,aAAK2D,iBAAL,CACE,CAACrG,uCAAkBuG,UAAnB,CADF,EAEEvG,uCAAkB8G,KAFpB;AAID;AACF,KAPD;AAQApE,WAAO,CAACwG,IAAR,CAAa,OAAb,EAAsB,MAAK;AACzB,UAAI,KAAKxG,OAAL,KAAiBA,OAArB,EAA8B;AAC5B,aAAKZ,KAAL,CAAW,mBAAX;AACA,aAAKuE,iBAAL,CACE,CAACrG,uCAAkBuG,UAAnB,CADF,EAEEvG,uCAAkBsG,iBAFpB;AAIA;;;;AAGA,aAAKD,iBAAL,CACE,CAACrG,uCAAkB8G,KAAnB,CADF,EAEE9G,uCAAkBC,IAFpB;AAID;AACF,KAfD;AAgBAyC,WAAO,CAACwG,IAAR,CACE,QADF,EAEE,CAACC,SAAD,EAAoBC,YAApB,EAA0CC,UAA1C,KAAgE;AAC9D,UAAI,KAAK3G,OAAL,KAAiBA,OAArB,EAA8B;AAC5B;;AAEA,YACEyG,SAAS,KAAKnK,KAAK,CAACC,SAAN,CAAgBqK,yBAA9B,IACAD,UAAU,CAACE,MAAX,CAAkBhK,gBAAlB,CAFF,EAGE;AACA,eAAKgB,eAAL,GAAuBlB,IAAI,CAACF,GAAL,CACrB,IAAI,KAAKoB,eADY,EAErB/B,qBAFqB,CAAvB;AAIAsH,iBAAO,CAAC0D,GAAR,CACEzD,yBAAa0D,KADf,EAEE,iBAAiB9B,yBAAY,KAAK/H,aAAjB,CAA+B,OAC9C,KAAKwB,uBACP,4EACE,KAAKb,eACP,KANF;AAQD;;AACD,aAAKuB,KAAL,CACE,2CACEqH,SAFJ;AAIA,aAAK9C,iBAAL,CACE,CAACrG,uCAAkBuG,UAAnB,EAA+BvG,uCAAkB8G,KAAjD,CADF,EAEE9G,uCAAkBC,IAFpB;AAID;AACF,KAhCH;AAkCAyC,WAAO,CAACwG,IAAR,CAAa,OAAb,EAAuBQ,KAAD,IAAU;AAC9B;;AAEA,WAAK5H,KAAL,CACE,kCACG4H,KAAe,CAACC,OAFrB;AAID,KAPD;;AAQA,QAAI7D,OAAO,CAAC8D,eAAR,CAAwB3L,WAAxB,CAAJ,EAA0C;AACxCyE,aAAO,CAACmH,EAAR,CAAW,gBAAX,EAA8BC,QAAD,IAA6B;AACxD,aAAKhI,KAAL,CACE,2BACG,KAAKY,OAAL,KAAiBA,OAAjB,GAA2B,wBAA3B,GAAsD,EADzD,IAEE,IAFF,GAGEX,IAAI,CAACC,SAAL,CAAe8H,QAAf,CAJJ;AAMD,OAPD;AAQApH,aAAO,CAACmH,EAAR,CAAW,eAAX,EAA6BC,QAAD,IAA6B;AACvD,aAAKhI,KAAL,CACE,2CACG,KAAKY,OAAL,KAAiBA,OAAjB,GAA2B,wBAA3B,GAAsD,EADzD,IAEE,IAFF,GAGEX,IAAI,CAACC,SAAL,CAAe8H,QAAf,CAJJ;AAMD,OAPD;AAQD;AACF;;AAEOC,yBAAuB;;AAC7B;;;;;;AAIA,UAAMjC,iBAAiB,GACrB,KAAK/H,WAAL,CAAiBgI,qBAAjB,MAA4C,EAD9C;;AAGA,QAAI,mBAAmBD,iBAAvB,EAA0C;AACxCA,uBAAiB,CAACkC,aAAlB,GAAkC,CAAC,IAAD,CAAlC,CADwC,CAExC;AACA;AACA;;AACA,UAAI,KAAKlK,OAAL,CAAa,+BAAb,CAAJ,EAAmD;AACjD,cAAMuI,qBAAqB,GAAG,KAAKvI,OAAL,CAC5B,+BAD4B,CAA9B;;AAGAgI,yBAAiB,CAACQ,mBAAlB,GAAwC,CACtCC,IADsC,EAEtCC,IAFsC,KAGjB;AACrB,iBAAOC,0BAAoBJ,qBAApB,EAA2CG,IAA3C,CAAP;AACD,SALD;;AAMAV,yBAAiB,CAACY,UAAlB,GAA+BL,qBAA/B;AACD,OAXD,MAWO;AACL,YAAI,8BAA8B,KAAKvI,OAAvC,EAAgD;AAC9C;;;;AAIA,gBAAMmK,UAAU,GAAGpC,+BAAmB,MACpCF,sBAAS,KAAK7H,OAAL,CAAa,0BAAb,CAAT,CADoC,MACwB,IADxB,IACwB8D,aADxB,GACwBA,EADxB,GAC4B;AAC9DsG,gBAAI,EAAE;AADwD,WAD/C,CAAnB;AAKA,gBAAMC,QAAQ,GAAGxC,2BAAcsC,UAAd,CAAjB;AACAnC,2BAAiB,CAACY,UAAlB,GAA4B,MAAGyB,QAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAE5B,IAAb,MAAiB,IAAjB,IAAiBjD,aAAjB,GAAiBA,EAAjB,GAAqB2E,UAAjD;AACD;AACF;AACF;;AAEDG,sCACE,KAAKvK,iBADP,EAEE,KAAKC,OAFP,EAGEgI,iBAHF,EAIEuC,IAJF,CAKGC,MAAD,IAAW;AACT,WAAK9C,aAAL,CAAmB8C,MAAnB;AACD,KAPH,EAQGC,MAAD,IAAW;AACT,WAAKlE,iBAAL,CACE,CAACrG,uCAAkBuG,UAAnB,CADF,EAEEvG,uCAAkBsG,iBAFpB;AAID,KAbH;AAeD;AAED;;;;;;;;;AAOQD,mBAAiB,CACvBmE,SADuB,EAEvBC,QAFuB,EAEI;AAE3B,QAAID,SAAS,CAACE,OAAV,CAAkB,KAAKvI,iBAAvB,MAA8C,CAAC,CAAnD,EAAsD;AACpD,aAAO,KAAP;AACD;;AACD,SAAKL,KAAL,CACE9B,uCAAkB,KAAKmC,iBAAvB,IACE,MADF,GAEEnC,uCAAkByK,QAAlB,CAHJ;;AAKA,QAAI,KAAKnJ,eAAT,EAA0B;AACxB,WAAKC,aAAL,CAAmBG,QAAnB,CAA4B,SAA5B,EAAuC1B,uCAAkB,KAAKmC,iBAAvB,IAA4C,MAA5C,GAAqDnC,uCAAkByK,QAAlB,CAA5F;AACD;;AACD,UAAME,aAAa,GAAG,KAAKxI,iBAA3B;AACA,SAAKA,iBAAL,GAAyBsI,QAAzB;;AACA,YAAQA,QAAR;AACE,WAAKzK,uCAAkB8G,KAAvB;AACE,aAAKJ,WAAL;AACA,cAAMhE,OAAO,GAAG,KAAKA,OAArB;AACAA,eAAO,CAACE,MAAR,CAAesG,IAAf,CAAoB,OAApB,EAA6B,MAAK;AAChC,cAAI,KAAKxG,OAAL,KAAiBA,OAArB,EAA8B;AAC5B,iBAAK2D,iBAAL,CACE,CAACrG,uCAAkB8G,KAAnB,CADF,EAEE9G,uCAAkBsG,iBAFpB;;AAGA,iBAAK,MAAMsE,QAAX,IAAuB,KAAKC,mBAA5B,EAAiD;AAC/CD,sBAAQ;AACT;AACF;AACF,SATD;;AAUA,YAAI,KAAKnK,qBAAT,EAAgC;AAC9B,eAAK2G,mBAAL;AACD;;AACD;;AACF,WAAKpH,uCAAkBuG,UAAvB;AACE,aAAKC,YAAL;AACA,aAAKuD,uBAAL;AACA,aAAK3D,kBAAL,GAA0B,KAA1B;AACA;;AACF,WAAKpG,uCAAkBsG,iBAAvB;AACE,YAAI,KAAK5D,OAAT,EAAkB;AAChB,eAAKA,OAAL,CAAaoI,KAAb;AACD;;AACD,aAAKpI,OAAL,GAAe,IAAf;AACA,aAAKgD,uBAAL;AACA,aAAK4B,kBAAL;AACA;;;;AAGA,YAAI,CAAC,KAAKrG,cAAL,CAAoB8J,SAApB,EAAL,EAAsC;AACpCC,iBAAO,CAACC,QAAR,CAAiB,MAAK;AACpB,iBAAK9J,kBAAL;AACD,WAFD;AAGD;;AACD;;AACF,WAAKnB,uCAAkBC,IAAvB;AACE,YAAI,KAAKyC,OAAT,EAAkB;AAChB,eAAKA,OAAL,CAAaoI,KAAb;AACD;;AACD,aAAKpI,OAAL,GAAe,IAAf;AACA,aAAKgD,uBAAL;AACA,aAAK4B,kBAAL;AACA;;AACF;AACE,cAAM,IAAI4D,KAAJ,CAAU,4CAA4CT,QAAQ,EAA9D,CAAN;AAhDJ;AAkDA;;;;AAEA,SAAK,MAAMG,QAAX,IAAuB,CAAC,GAAG,KAAKO,cAAT,CAAvB,EAAiD;AAC/CP,cAAQ,CAAC,IAAD,EAAOD,aAAP,EAAsBF,QAAtB,CAAR;AACD;;AACD,WAAO,IAAP;AACD;AAED;;;;;;AAIQW,oBAAkB;AACxB;;AAEA,QAAI,KAAKC,YAAL,KAAsB,CAAtB,IAA2B,KAAKC,QAAL,KAAkB,CAAjD,EAAoD;AAClD,UAAI,KAAKhK,eAAT,EAA0B;AACxB,aAAKC,aAAL,CAAmBG,QAAnB,CAA4B,SAA5B,EAAuC,eAAvC;AACD;;AACD,WAAK2E,iBAAL,CACE,CAACrG,uCAAkBuG,UAAnB,EAA+BvG,uCAAkB8G,KAAjD,CADF,EAEE9G,uCAAkBsG,iBAFpB;;AAIA,UAAI,KAAKhF,eAAT,EAA0B;AACxBpB,yCAAsB,KAAKsB,WAA3B;AACD;AACF;AACF;;AAED+J,SAAO;AACL,SAAKtF,QAAL,CACE,kBACE,KAAKoF,YADP,GAEE,MAFF,IAGG,KAAKA,YAAL,GAAoB,CAHvB,CADF;;AAMA,QAAI,KAAKA,YAAL,KAAsB,CAA1B,EAA6B;AAC3B,UAAI,KAAK3I,OAAT,EAAkB;AAChB,aAAKA,OAAL,CAAa8I,GAAb;AACD;;AACD,WAAKvK,cAAL,CAAoBuK,GAApB;;AACA,UAAI,CAAC,KAAK/K,qBAAV,EAAiC;AAC/B,aAAK2G,mBAAL;AACD;AACF;;AACD,SAAKiE,YAAL,IAAqB,CAArB;AACD;;AAEDI,WAAS;AACP,SAAKxF,QAAL,CACE,kBACE,KAAKoF,YADP,GAEE,MAFF,IAGG,KAAKA,YAAL,GAAoB,CAHvB,CADF;AAMA,SAAKA,YAAL,IAAqB,CAArB;;AACA,QAAI,KAAKA,YAAL,KAAsB,CAA1B,EAA6B;AAC3B,UAAI,KAAK3I,OAAT,EAAkB;AAChB,aAAKA,OAAL,CAAaqE,KAAb;AACD;;AACD,WAAK9F,cAAL,CAAoB8F,KAApB;;AACA,UAAI,CAAC,KAAKtG,qBAAV,EAAiC;AAC/B,aAAK6G,kBAAL;AACD;;AACD,WAAK8D,kBAAL;AACD;AACF;;AAEDI,KAAG;AACD,SAAKvF,QAAL,CACE,cACE,KAAKqF,QADP,GAEE,MAFF,IAGG,KAAKA,QAAL,GAAgB,CAHnB,CADF;AAMA,SAAKA,QAAL,IAAiB,CAAjB;AACD;;AAEDvE,OAAK;AACH,SAAKd,QAAL,CACE,cACE,KAAKqF,QADP,GAEE,MAFF,IAGG,KAAKA,QAAL,GAAgB,CAHnB,CADF;AAMA,SAAKA,QAAL,IAAiB,CAAjB;AACA,SAAKF,kBAAL;AACD;;AAEDM,eAAa;AACX,QAAI,KAAKJ,QAAL,KAAkB,CAAtB,EAAyB;AACvB,WAAKvE,KAAL;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;AAED;;;;;;;;;AAOA4E,iBAAe,CACbC,QADa,EAEbC,UAFa,EAGbC,YAHa,EAGS;AAEtB,UAAMC,OAAO,GAAGH,QAAQ,CAACI,cAAT,EAAhB;AACAD,WAAO,CAACrN,sBAAD,CAAP,GAAkCmN,UAAU,CAACI,OAAX,EAAlC;AACAF,WAAO,CAAChN,uBAAD,CAAP,GAAmC,KAAKoB,SAAxC;AACA4L,WAAO,CAACpN,yBAAD,CAAP,GAAqC,kBAArC;AACAoN,WAAO,CAACnN,mBAAD,CAAP,GAA+B,MAA/B;AACAmN,WAAO,CAAClN,iBAAD,CAAP,GAA6BgN,UAAU,CAACK,SAAX,EAA7B;AACAH,WAAO,CAACjN,eAAD,CAAP,GAA2B,UAA3B;AACA,QAAIqN,WAAJ;AACA;;;;;;;;;AAQA,QAAI;AACFA,iBAAW,GAAG,KAAKzJ,OAAL,CAAc0J,OAAd,CAAsBL,OAAtB,CAAd;AACD,KAFD,CAEE,OAAO1L,CAAP,EAAU;AACV,WAAKgG,iBAAL,CACE,CAACrG,uCAAkB8G,KAAnB,CADF,EAEE9G,uCAAkBsG,iBAFpB;AAIA,YAAMjG,CAAN;AACD;;AACD,QAAIgM,aAAa,GAAG,EAApB;;AACA,SAAK,MAAMC,MAAX,IAAqBC,MAAM,CAACC,IAAP,CAAYT,OAAZ,CAArB,EAA2C;AACzCM,mBAAa,IAAI,SAASC,MAAT,GAAkB,IAAlB,GAAyBP,OAAO,CAACO,MAAD,CAAhC,GAA2C,IAA5D;AACD;;AACDxG,WAAO,CAAChE,KAAR,CACEiE,yBAAaC,KADf,EAEE,aAFF,EAGE,sBAAsB6F,UAAU,CAACY,aAAX,EAAtB,GAAmD,kBAAnD,GACE,GADF,GACQ,KAAKjL,WAAL,CAAiBI,EADzB,GAC8B,IAD9B,GAEE,KAAKR,uBAFP,GAGE,iBAHF,GAIEiL,aAPJ;AASA,SAAKnG,gBAAL,CACE,wBACE,KAAKxD,OAAL,CAAcR,KAAd,CAAoBmD,eADtB,GAEE,uBAFF,GAGE,KAAK3C,OAAL,CAAcR,KAAd,CAAoBsD,gBAJxB;AAMA,UAAMkH,aAAa,GAAG,KAAKhK,OAA3B;AACA,SAAKyD,cAAL,CACE,oBACAuG,aAAc,CAACC,MADf,GAEA,qBAFA,GAGAD,aAAc,CAACE,SAHf,GAIA,4BAJA,GAKAF,aAAc,CAAC9J,MAAf,CAAsBgK,SANxB;AAOA,QAAIC,YAAJ;;AACA,QAAI,KAAKvL,eAAT,EAA0B;AACxB,WAAKc,WAAL,CAAiB0K,cAAjB;AACAjB,gBAAU,CAACkB,gBAAX,CAA4BC,MAAM,IAAG;AACnC,YAAIA,MAAM,CAACC,IAAP,KAAgBlH,mBAAOmH,EAA3B,EAA+B;AAC7B,eAAK9K,WAAL,CAAiB+K,gBAAjB;AACD,SAFD,MAEO;AACL,eAAK/K,WAAL,CAAiBgL,aAAjB;AACD;AACF,OAND;AAOA,WAAK/I,aAAL,CAAmByI,cAAnB;AACAjB,gBAAU,CAACwB,mBAAX,CAA+BC,OAAO,IAAG;AACvC,YAAIZ,aAAa,KAAK,KAAKhK,OAA3B,EAAoC;AAClC,cAAI4K,OAAJ,EAAa;AACX,iBAAKjJ,aAAL,CAAmB8I,gBAAnB;AACD,WAFD,MAEO;AACL,iBAAK9I,aAAL,CAAmB+I,aAAnB;AACD;AACF;AACF,OARD;AASAP,kBAAY,GAAG;AACbU,sBAAc,EAAE,MAAK;AACnB,eAAK5I,YAAL,IAAqB,CAArB;AACA,eAAKO,wBAAL,GAAgC,IAAIsI,IAAJ,EAAhC;AACD,SAJY;AAKbC,0BAAkB,EAAE,MAAK;AACvB,eAAK7I,gBAAL,IAAyB,CAAzB;AACD;AAPY,OAAf;AASD,KA5BD,MA4BO;AACLiI,kBAAY,GAAG;AACbU,sBAAc,EAAE,MAAK,CAAG,CADX;AAEbE,0BAAkB,EAAE,MAAK,CAAG;AAFf,OAAf;AAID;;AACD5B,cAAU,CAAC6B,iBAAX,CAA6BvB,WAA7B,EAA0C,IAA1C,EAAgDL,YAAhD,EAA8De,YAA9D;AACD;AAED;;;;;;;;AAMAc,iBAAe;AACb;;;;AAIA,QACE,CAAC,KAAKtH,iBAAL,CACC,CAACrG,uCAAkBC,IAAnB,CADD,EAECD,uCAAkBuG,UAFnB,CADH,EAKE;AACA,UAAI,KAAKpE,iBAAL,KAA2BnC,uCAAkBsG,iBAAjD,EAAoE;AAClE,aAAKF,kBAAL,GAA0B,IAA1B;AACD;AACF;AACF;AAED;;;;;AAGAwH,sBAAoB;AAClB,WAAO,KAAKzL,iBAAZ;AACD;AAED;;;;;;;AAKA0L,8BAA4B,CAACjD,QAAD,EAAoC;AAC9D,SAAKO,cAAL,CAAoB2C,IAApB,CAAyBlD,QAAzB;AACD;AAED;;;;;;;AAKAmD,iCAA+B,CAACnD,QAAD,EAAoC;AACjE,UAAMoD,aAAa,GAAG,KAAK7C,cAAL,CAAoBT,OAApB,CAA4BE,QAA5B,CAAtB;;AACA,QAAIoD,aAAa,GAAG,CAAC,CAArB,EAAwB;AACtB,WAAK7C,cAAL,CAAoB8C,MAApB,CAA2BD,aAA3B,EAA0C,CAA1C;AACD;AACF;;AAEDE,uBAAqB,CAACtD,QAAD,EAAqB;AACxC,SAAKC,mBAAL,CAAyBiD,IAAzB,CAA8BlD,QAA9B;AACD;;AAEDuD,0BAAwB,CAACvD,QAAD,EAAqB;AAC3C,UAAMoD,aAAa,GAAG,KAAKnD,mBAAL,CAAyBH,OAAzB,CAAiCE,QAAjC,CAAtB;;AACA,QAAIoD,aAAa,GAAG,CAAC,CAArB,EAAwB;AACtB,WAAKnD,mBAAL,CAAyBoD,MAAzB,CAAgCD,aAAhC,EAA+C,CAA/C;AACD;AACF;AAED;;;;;AAGAI,cAAY;AACV,SAAKnN,cAAL,CAAoB2F,KAApB;AACA,SAAKP,iBAAL,CACE,CAACrG,uCAAkBsG,iBAAnB,CADF,EAEEtG,uCAAkBuG,UAFpB;AAID;;AAED8H,YAAU;AACR,WAAO,KAAKjN,uBAAZ;AACD;;AAEDkN,gBAAc;AACZ,WAAO,KAAK9M,WAAZ;AACD;;AAED+M,mBAAiB;AACf,WAAO,IAAP;AACD;;AAh5BoB;;AAAvBC","names":["clientVersion","require","version","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","MIN_CONNECT_TIMEOUT_MS","INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","http2","constants","uniformRandom","min","max","Math","random","tooManyPingsData","Buffer","from","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connectivity_state_1","IDLE","channelz_1","userAgent","filter","e","join","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","keepaliveIntervalId","setTimeout","clearTimeout","keepaliveTimeoutId","backoffOptions","initialDelay","maxDelay","backoffTimeout","backoff_timeout_1","handleBackoffTimer","subchannelAddressString","subchannel_address_1","channelzEnabled","channelzTrace","channelzRef","getChannelzInfo","addTrace","kind","id","name","trace","JSON","stringify","undefined","state","connectivityState","callTracker","children","childrenTracker","getChildLists","target","getChannelzSocketInfo","session","sessionSocket","socket","remoteAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","_a","cipherSuiteOtherName","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","keepalivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","localWindowSize","_b","remoteFlowControlWindow","remoteWindowSize","_c","resetChannelzSocketInfo","channelzSocketRef","unrefChild","text","logging","constants_1","DEBUG","refTrace","flowControlTrace","internalsTrace","continueConnecting","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","sendPing","READY","unref","ping","err","duration","payload","startKeepalivePings","setInterval","stopKeepalivePings","clearInterval","createSession","proxyConnectionResult","realTarget","uri_parser_1","targetAuthority","resolver_1","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","host","cert","tls_1","servername","authorityHostname","createConnection","authority","option","net","connect","refChild","once","errorCode","lastStreamID","opaqueData","NGHTTP2_ENHANCE_YOUR_CALM","equals","log","ERROR","error","message","isTracerEnabled","on","settings","startConnectingInternal","ALPNProtocols","targetPath","path","hostPort","http_proxy_1","then","result","reason","oldStates","newState","indexOf","previousState","listener","disconnectListeners","close","isRunning","process","nextTick","Error","stateListeners","checkBothRefcounts","callRefcount","refcount","callRef","ref","callUnref","unrefIfOneRef","startCallStream","metadata","callStream","extraFilters","headers","toHttp2Headers","getHost","getMethod","http2Stream","request","headersString","header","Object","keys","getCallNumber","streamSession","closed","destroyed","statsTracker","addCallStarted","addStatusWatcher","status","code","OK","addCallSucceeded","addCallFailed","addStreamEndWatcher","success","addMessageSent","Date","addMessageReceived","attachHttp2Stream","startConnecting","getConnectivityState","addConnectivityStateListener","push","removeConnectivityStateListener","listenerIndex","splice","addDisconnectListener","removeDisconnectListener","resetBackoff","getAddress","getChannelzRef","getRealSubchannel","exports"],"sources":["/Users/felixyamano/Documents/NEU/CS5610/facerecognition/node_modules/@grpc/grpc-js/src/subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { Call, Http2CallStream, WriteObject } from './call-stream';\nimport { ChannelOptions } from './channel-options';\nimport { PeerCertificate, checkServerIdentity, TLSSocket, CipherNameAndProtocol } from 'tls';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport { getDefaultAuthority } from './resolver';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as net from 'net';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { ConnectionOptions } from 'tls';\nimport { FilterFactory, Filter, BaseFilter } from './filter';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { SubchannelRef, ChannelzTrace, ChannelzChildrenTracker, SubchannelInfo, registerChannelzSubchannel, ChannelzCallTracker, SocketInfo, SocketRef, unregisterChannelzRef, registerChannelzSocket, TlsInfo } from './channelz';\nimport { ConnectivityStateListener } from './subchannel-interface';\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\n\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface SubchannelCallStatsTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n}\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private session: http2.ClientHttp2Session | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: ConnectivityStateListener[] = [];\n\n  /**\n   * A list of listener functions that will be called when the underlying\n   * socket disconnects. Used for ending active calls with an UNAVAILABLE\n   * status.\n   */\n  private disconnectListeners: Array<() => void> = [];\n\n  private backoffTimeout: BackoffTimeout;\n\n  /**\n   * The complete user agent string constructed using channel args.\n   */\n  private userAgent: string;\n\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs: number = KEEPALIVE_MAX_TIME_MS;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveIntervalId: NodeJS.Timer;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  /**\n   * Tracks calls with references to this subchannel\n   */\n  private callRefcount = 0;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private channelzSocketRef: SocketRef | null = null;\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  private remoteName: string | null = null;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials\n  ) {\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter((e) => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    if (this.channelzEnabled) {\n      this.channelzRef = registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'subchannel',\n        id: -1,\n        name: ''\n      };\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  private getChannelzSocketInfo(): SocketInfo | null {\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n        remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null\n    };\n    return socketInfo;\n  }\n\n  private resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private sendPing() {\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' +\n      'Sending ping'\n    );\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.transitionToState([ConnectivityState.READY], ConnectivityState.IDLE);\n    }, this.keepaliveTimeoutMs);\n    this.keepaliveTimeoutId.unref?.();\n    this.session!.ping(\n      (err: Error | null, duration: number, payload: Buffer) => {\n        clearTimeout(this.keepaliveTimeoutId);\n      }\n    );\n  }\n\n  private startKeepalivePings() {\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.keepaliveIntervalId.unref?.();\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  private stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  private createSession(proxyConnectionResult: ProxyConnectionResult) {\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = getDefaultAuthority(\n      proxyConnectionResult.realTarget ?? this.channelTarget\n    );\n    let connectionOptions: http2.SecureClientSessionOptions =\n      this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options[\n        'grpc-node.max_session_memory'\n      ];\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname =\n          splitHostPort(targetAuthority)?.host ?? 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket!;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = {\n      ...connectionOptions,\n      ...this.subchannelAddress,\n    };\n\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(\n      addressScheme + targetAuthority,\n      connectionOptions\n    );\n    this.session = session;\n    if (this.channelzEnabled) {\n      this.channelzSocketRef = registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo()!);\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.READY\n        );\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState(\n          [ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      }\n    });\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n        if (this.session === session) {\n          /* See the last paragraph of\n           * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n          if (\n            errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n            opaqueData.equals(tooManyPingsData)\n          ) {\n            this.keepaliveTimeMs = Math.min(\n              2 * this.keepaliveTimeMs,\n              KEEPALIVE_MAX_TIME_MS\n            );\n            logging.log(\n              LogVerbosity.ERROR,\n              `Connection to ${uriToString(this.channelTarget)} at ${\n                this.subchannelAddressString\n              } rejected by server because of excess pings. Increasing ping interval to ${\n                this.keepaliveTimeMs\n              } ms`\n            );\n          }\n          this.trace(\n            'connection closed by GOAWAY with code ' +\n              errorCode\n          );\n          this.transitionToState(\n            [ConnectivityState.CONNECTING, ConnectivityState.READY],\n            ConnectivityState.IDLE\n          );\n        }\n      }\n    );\n    session.once('error', (error) => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace(\n        'connection closed with error ' +\n          (error as Error).message\n      );\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n  }\n\n  private startConnectingInternal() {\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(this.options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n    }\n\n    getProxiedConnection(\n      this.subchannelAddress,\n      this.options,\n      connectionOptions\n    ).then(\n      (result) => {\n        this.createSession(result);\n      },\n      (reason) => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n      }\n    );\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session!;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.transitionToState(\n              [ConnectivityState.READY],\n              ConnectivityState.TRANSIENT_FAILURE);\n            for (const listener of this.disconnectListeners) {\n              listener();\n            }\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  private checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState(\n        [ConnectivityState.CONNECTING, ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount + 1)\n    );\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount - 1)\n    );\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount + 1)\n    );\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount - 1)\n    );\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n  startCallStream(\n    metadata: Metadata,\n    callStream: Http2CallStream,\n    extraFilters: Filter[]\n  ) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.transitionToState(\n        [ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n      throw e;\n    }\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'call_stream',\n      'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' +\n        '(' + this.channelzRef.id + ') ' +\n        this.subchannelAddressString +\n        ' with headers\\n' +\n        headersString\n    );\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session!.state.localWindowSize +\n        ' remote window size: ' +\n        this.session!.state.remoteWindowSize\n    );\n    const streamSession = this.session;\n    this.internalsTrace(\n      'session.closed=' + \n      streamSession!.closed + \n      ' session.destroyed=' + \n      streamSession!.destroyed + \n      ' session.socket.destroyed=' + \n      streamSession!.socket.destroyed);\n    let statsTracker: SubchannelCallStatsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      }\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      }\n    }\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (\n      !this.transitionToState(\n        [ConnectivityState.IDLE],\n        ConnectivityState.CONNECTING\n      )\n    ) {\n      if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener: () => void) {\n    this.disconnectListeners.push(listener);\n  }\n\n  removeDisconnectListener(listener: () => void) {\n    const listenerIndex = this.disconnectListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.disconnectListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState(\n      [ConnectivityState.TRANSIENT_FAILURE],\n      ConnectivityState.CONNECTING\n    );\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}